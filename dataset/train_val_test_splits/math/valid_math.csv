sentence,terms,source,label
формальные грамматики и языки.,грамматики,gramm,1
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",грамматик,gramm,1
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",формальных грамматик,gramm,1
излагаемые методы трансляции проиллюстрированы на примере модельного языка.,модельного языка,gramm,1
"- издание второе (переработанное и дополненное) издательский отдел факультета вмик мгу (лицензия лр no040777 от 23.07.96), 1998.-62 с. печатается по решению редакционно-издательского совета факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова 4 isbn 5-89407-032-5 издательский отдел факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова, 1999 5 элементы теори и формальных языков и грамматик введение.",грамматик,gramm,1
"- издание второе (переработанное и дополненное) издательский отдел факультета вмик мгу (лицензия лр no040777 от 23.07.96), 1998.-62 с. печатается по решению редакционно-издательского совета факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова 4 isbn 5-89407-032-5 издательский отдел факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова, 1999 5 элементы теори и формальных языков и грамматик введение.",формальных языков,gramm,1
"в этом разделе изложены некоторые аспекты теории формальных языков, существенные с точки зрения трансляции.",формальных языков,gramm,1
"здесь введены базовые понятия и даны определения, связанные с одним из основных механизмов определения языков - грамматиками, приведена наиболее распространенная классификация грамматик (по хомскому).",грамматик,gramm,1
"здесь введены базовые понятия и даны определения, связанные с одним из основных механизмов определения языков - грамматиками, приведена наиболее распространенная классификация грамматик (по хомскому).",грамматиками,gramm,1
"особое внимание уделяется контекстно-свободным грамматикам и, в частности, их важному подклассу - регулярным грамматикам.",регулярным грамматикам,gramm,1
"особое внимание уделяется контекстно-свободным грамматикам и, в частности, их важному подклассу - регулярным грамматикам.",грамматикам,gramm,1
грамматики этих классов широко используются при трансляции языков программирования.,грамматики,gramm,1
определение: цепочкой символов в алфавите v называется любая конечная последовательность символов этого алфавита.,цепочкой,gramm,1
"определение: цепочка, которая не содержит ни одного символа, называется пустой цепочкой.",цепочка,gramm,1
"определение: цепочка, которая не содержит ни одного символа, называется пустой цепочкой.",цепочкой,gramm,1
"определение: цепочка, которая не содержит ни одного символа, называется пустой цепочкой.",пустой цепочкой,gramm,1
"более формально цепочка символов в алфавите v определяется следующим образом: (1) - цепочка в алфавите v; (2) если - цепочка в алфавите v и a - символ этого алфавита, то a - цепочка в алфавите v; (3) - цепочка в алфавите v тогда и только тогда, когда она является таковой в силу (1) и (2).",цепочка,gramm,1
"определение: если и - цепочки, то цепочка называется конкатенацией (или сцеплением) цепочек и .",цепочки,gramm,1
"определение: если и - цепочки, то цепочка называется конкатенацией (или сцеплением) цепочек и .",цепочек,gramm,1
"определение: если и - цепочки, то цепочка называется конкатенацией (или сцеплением) цепочек и .",цепочка,gramm,1
для любой цепочки всегда = = .,цепочки,gramm,1
"6 определение: обращением (или реверсом) цепочки называется цепочка, символы которой записаны в обратном порядке.",цепочки,gramm,1
"6 определение: обращением (или реверсом) цепочки называется цепочка, символы которой записаны в обратном порядке.",цепочка,gramm,1
"обращение цепочки будем обозначать r. например, если = abcdef, то r = fedcba.",цепочки,gramm,1
для пустой цепочки: = r. определение: n-ой степенью цепочки (будем обозначать n) называется конкатенация n цепочек .,цепочки,gramm,1
для пустой цепочки: = r. определение: n-ой степенью цепочки (будем обозначать n) называется конкатенация n цепочек .,цепочек,gramm,1
для пустой цепочки: = r. определение: n-ой степенью цепочки (будем обозначать n) называется конкатенация n цепочек .,пустой цепочки,gramm,1
определение: длина цепочки - это число составляющих ее символов.,цепочки,gramm,1
длину цепочки будем обозначать .,цепочки,gramm,1
определение: язык в алфавите v - это подмножество цепочек конечной длины в этом алфавите.,цепочек,gramm,1
"определение: обозначим через v множество, содержащее все цепочки конечной длины в алфавите v, включая пустую цепочку .",пустую цепочку,gramm,1
"определение: обозначим через v множество, содержащее все цепочки конечной длины в алфавите v, включая пустую цепочку .",цепочки,gramm,1
"определение: обозначим через v множество, содержащее все цепочки конечной длины в алфавите v, включая пустую цепочку .",цепочку,gramm,1
"определение: обозначим через v+ множество, содержащее все цепочки конечной длины в алфавите v, исключая пустую цепочку .",пустую цепочку,gramm,1
"определение: обозначим через v+ множество, содержащее все цепочки конечной длины в алфавите v, исключая пустую цепочку .",цепочки,gramm,1
"определение: обозначим через v+ множество, содержащее все цепочки конечной длины в алфавите v, исключая пустую цепочку .",цепочку,gramm,1
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",грамматики,gramm,1
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",терминальных символов,gramm,1
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",нетерминальных символов,gramm,1
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",грамматика,gramm,1
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",терминалов,gramm,1
"каждое i , i = 1, 2, ... ,n , будем называть альтернативой правила вывода из цепочки .",цепочки,gramm,1
"каждое i , i = 1, 2, ... ,n , будем называть альтернативой правила вывода из цепочки .",альтернативой правила вывода,gramm,1
"пример грамматики: g1 = ({0,1}, {a,s}, p, s), где p состоит из правил s 0a1 0a 00a1 a определение: цепочка (vt vn) непосредственно выводима из цепочки (vt vn)+ в грамматике g = (vt, vn, p, s) (обозначим ), если = 1 2, = 1 2, где 1, 2, (vt vn) , (vt vn)+ и правило вывода содержится в p. например, цепочка 00a11 непосредственно выводима из 0a1 в грамматике g1.",грамматики,gramm,1
"пример грамматики: g1 = ({0,1}, {a,s}, p, s), где p состоит из правил s 0a1 0a 00a1 a определение: цепочка (vt vn) непосредственно выводима из цепочки (vt vn)+ в грамматике g = (vt, vn, p, s) (обозначим ), если = 1 2, = 1 2, где 1, 2, (vt vn) , (vt vn)+ и правило вывода содержится в p. например, цепочка 00a11 непосредственно выводима из 0a1 в грамматике g1.",грамматике,gramm,1
"пример грамматики: g1 = ({0,1}, {a,s}, p, s), где p состоит из правил s 0a1 0a 00a1 a определение: цепочка (vt vn) непосредственно выводима из цепочки (vt vn)+ в грамматике g = (vt, vn, p, s) (обозначим ), если = 1 2, = 1 2, где 1, 2, (vt vn) , (vt vn)+ и правило вывода содержится в p. например, цепочка 00a11 непосредственно выводима из 0a1 в грамматике g1.",цепочки,gramm,1
"пример грамматики: g1 = ({0,1}, {a,s}, p, s), где p состоит из правил s 0a1 0a 00a1 a определение: цепочка (vt vn) непосредственно выводима из цепочки (vt vn)+ в грамматике g = (vt, vn, p, s) (обозначим ), если = 1 2, = 1 2, где 1, 2, (vt vn) , (vt vn)+ и правило вывода содержится в p. например, цепочка 00a11 непосредственно выводима из 0a1 в грамматике g1.",цепочка,gramm,1
"определение: цепочка (vt vn) выводима из цепочки (vt vn)+ в грамматике g = (vt, vn, p, s) (обозначим ), если существуют цепочки 0, 1, ... , n (n>=0), такие, что = 0 1 ...",цепочки,gramm,1
"определение: цепочка (vt vn) выводима из цепочки (vt vn)+ в грамматике g = (vt, vn, p, s) (обозначим ), если существуют цепочки 0, 1, ... , n (n>=0), такие, что = 0 1 ...",грамматике,gramm,1
"определение: цепочка (vt vn) выводима из цепочки (vt vn)+ в грамматике g = (vt, vn, p, s) (обозначим ), если существуют цепочки 0, 1, ... , n (n>=0), такие, что = 0 1 ...",цепочка,gramm,1
"например, s 000a111 в грамматике g1 (см. пример выше), т.к. существует вывод s 0a1 00a11 000a111.",грамматике,gramm,1
"определение: языком, порождаемым грамматикой g = (vt, vn, p, s), называется множество l(g) = { vt s }.",грамматикой,gramm,1
"другими словами, l(g) - это все цепочки в алфавите vt, которые выводимы из s с помощью p. например, l(g1) = {0n1n n>0}.",цепочки,gramm,1
"определение: цепочка (vt vn) , для которой s , называется сентенциальной формой в грамматике g = (vt, vn, p, s).",сентенциальной формой,gramm,1
"определение: цепочка (vt vn) , для которой s , называется сентенциальной формой в грамматике g = (vt, vn, p, s).",грамматике,gramm,1
"определение: цепочка (vt vn) , для которой s , называется сентенциальной формой в грамматике g = (vt, vn, p, s).",цепочка,gramm,1
"таким образом, язык, порождаемый грамматикой, можно определить как множество терминальных сентенциальных форм.",сентенциальных форм,gramm,1
"таким образом, язык, порождаемый грамматикой, можно определить как множество терминальных сентенциальных форм.",грамматикой,gramm,1
"определение: грамматики g1 и g2 называются эквивалентными, если l(g1) = l(g2).",грамматики,gramm,1
"определение: грамматики g1 и g2 почти эквивалентны, если l(g1) { } = l(g2) { }.",грамматики,gramm,1
"другими словами, грамматики почти эквивалентны, если языки, ими порождаемые, отличаются не более, чем на .",грамматики,gramm,1
"например, g1 = ({0,1}, {a,s}, p1, s) и g2 = ({0,1}, {s}, p2, s) p1: s 0a1 p2: s 0s1 0a 00a1 a почти эквивалентны, т.к. l(g1)={0n1n n>0}, а l(g2)={0n1n n>=0}, т.е. l(g2) состоит из всех цепочек языка l(g1) и пустой цепочки, которая в l(g1) не входит.",цепочек языка,gramm,1
"например, g1 = ({0,1}, {a,s}, p1, s) и g2 = ({0,1}, {s}, p2, s) p1: s 0a1 p2: s 0s1 0a 00a1 a почти эквивалентны, т.к. l(g1)={0n1n n>0}, а l(g2)={0n1n n>=0}, т.е. l(g2) состоит из всех цепочек языка l(g1) и пустой цепочки, которая в l(g1) не входит.",цепочек,gramm,1
"например, g1 = ({0,1}, {a,s}, p1, s) и g2 = ({0,1}, {s}, p2, s) p1: s 0a1 p2: s 0s1 0a 00a1 a почти эквивалентны, т.к. l(g1)={0n1n n>0}, а l(g2)={0n1n n>=0}, т.е. l(g2) состоит из всех цепочек языка l(g1) и пустой цепочки, которая в l(g1) не входит.",пустой цепочки,gramm,1
"например, g1 = ({0,1}, {a,s}, p1, s) и g2 = ({0,1}, {s}, p2, s) p1: s 0a1 p2: s 0s1 0a 00a1 a почти эквивалентны, т.к. l(g1)={0n1n n>0}, а l(g2)={0n1n n>=0}, т.е. l(g2) состоит из всех цепочек языка l(g1) и пустой цепочки, которая в l(g1) не входит.",цепочки,gramm,1
"классификация грамматик и языков по хомскому (грамматики классифицируются по виду их правил вывода) тип 0: грамматика g = (vt, vn, p, s) называется грамматикой типа 0, если на правила вывода не накладывается никаких ограничений (кроме тех, которые указаны в определении грамматики).",грамматики,gramm,1
"классификация грамматик и языков по хомскому (грамматики классифицируются по виду их правил вывода) тип 0: грамматика g = (vt, vn, p, s) называется грамматикой типа 0, если на правила вывода не накладывается никаких ограничений (кроме тех, которые указаны в определении грамматики).",грамматикой,gramm,1
"классификация грамматик и языков по хомскому (грамматики классифицируются по виду их правил вывода) тип 0: грамматика g = (vt, vn, p, s) называется грамматикой типа 0, если на правила вывода не накладывается никаких ограничений (кроме тех, которые указаны в определении грамматики).",грамматик,gramm,1
"классификация грамматик и языков по хомскому (грамматики классифицируются по виду их правил вывода) тип 0: грамматика g = (vt, vn, p, s) называется грамматикой типа 0, если на правила вывода не накладывается никаких ограничений (кроме тех, которые указаны в определении грамматики).",грамматика,gramm,1
"классификация грамматик и языков по хомскому (грамматики классифицируются по виду их правил вывода) тип 0: грамматика g = (vt, vn, p, s) называется грамматикой типа 0, если на правила вывода не накладывается никаких ограничений (кроме тех, которые указаны в определении грамматики).",грамматикой типа,gramm,1
"тип 1: грамматика g = (vt, vn, p, s) называется неукорачивающей грамматикой, если каждое правило из p имеет вид , где (vt vn)+, (vt vn)+ и <= .",грамматикой,gramm,1
"тип 1: грамматика g = (vt, vn, p, s) называется неукорачивающей грамматикой, если каждое правило из p имеет вид , где (vt vn)+, (vt vn)+ и <= .",грамматика,gramm,1
"грамматика g = (vt, vn, p, s) называется контекстно- зависимой ( кз ), если каждое правило из p имеет вид , где = 1a 2; = 1 2; a vn; (vt vn)+; 1, 2 (vt vn) .",грамматика,gramm,1
грамматику типа 1 можно определить как неукорачивающую либо как контекстно-зависимую.,грамматику,gramm,1
грамматику типа 1 можно определить как неукорачивающую либо как контекстно-зависимую.,грамматику типа,gramm,1
"выбор определения не влияет на множество языков, порождаемых грамматиками этого класса, поскольку доказано, что множество языков, порождаемых неукорачивающими 9 грамматиками, совпадает с множеством языков, порождаемых кз- грамматиками.",грамматиками,gramm,1
"тип 2: грамматика g = (vt, vn, p, s) называется контекстно- свободной ( кс ), если каждое правило из р имеет вид a , где a vn, (vt vn)+.",грамматика,gramm,1
"грамматика g = (vt, vn, p, s) называется укорачивающей контекстно-свободной ( укс ), если каждое правило из р имеет вид a , где a vn, (vt vn) .",грамматика,gramm,1
грамматику типа 2 можно определить как контекстно- свободную либо как укорачивающую контекстно-свободную.,грамматику,gramm,1
грамматику типа 2 можно определить как контекстно- свободную либо как укорачивающую контекстно-свободную.,грамматику типа,gramm,1
"возможность выбора обусловлена тем, что для каждой укс- грамматики существует почти эквивалентная кс-грамматика.",грамматики,gramm,1
"возможность выбора обусловлена тем, что для каждой укс- грамматики существует почти эквивалентная кс-грамматика.",грамматика,gramm,1
"тип 3: грамматика g = (vt, vn, p, s) называется праволинейной, если каждое правило из р имеет вид a tb либо a t, где a vn, b vn, t vt.",грамматика,gramm,1
"грамматика g = (vt, vn, p, s) называется леволинейной, если каждое правило из р имеет вид a bt либо a t, где a vn, b vn, t vt.",грамматика,gramm,1
"грамматику типа 3 (регулярную, р-грамматику) можно определить как праволинейную либо как леволинейную.",грамматику,gramm,1
"грамматику типа 3 (регулярную, р-грамматику) можно определить как праволинейную либо как леволинейную.",грамматику типа,gramm,1
"выбор определения не влияет на множество языков, порождаемых грамматиками этого класса, поскольку доказано, что множество языков, порождаемых праволинейными грамматиками, совпадает с множеством языков, порождаемых леволинейными грамматиками.",грамматиками,gramm,1
соотношения между типами грамматик: (1) любая регулярная грамматика является кс-грамматикой; (2) любая регулярная грамматика является укс-грамматикой; (3) любая кс- грамматика является укс-грамматикой; (4) любая кс-грамматика является кз-грамматикой; (5) любая кс-грамматика является неукорачивающей грамматикой; (6) любая кз-грамматика является грамматикой типа 0.,грамматикой,gramm,1
соотношения между типами грамматик: (1) любая регулярная грамматика является кс-грамматикой; (2) любая регулярная грамматика является укс-грамматикой; (3) любая кс- грамматика является укс-грамматикой; (4) любая кс-грамматика является кз-грамматикой; (5) любая кс-грамматика является неукорачивающей грамматикой; (6) любая кз-грамматика является грамматикой типа 0.,грамматик,gramm,1
соотношения между типами грамматик: (1) любая регулярная грамматика является кс-грамматикой; (2) любая регулярная грамматика является укс-грамматикой; (3) любая кс- грамматика является укс-грамматикой; (4) любая кс-грамматика является кз-грамматикой; (5) любая кс-грамматика является неукорачивающей грамматикой; (6) любая кз-грамматика является грамматикой типа 0.,грамматика,gramm,1
соотношения между типами грамматик: (1) любая регулярная грамматика является кс-грамматикой; (2) любая регулярная грамматика является укс-грамматикой; (3) любая кс- грамматика является укс-грамматикой; (4) любая кс-грамматика является кз-грамматикой; (5) любая кс-грамматика является неукорачивающей грамматикой; (6) любая кз-грамматика является грамматикой типа 0.,грамматикой типа,gramm,1
соотношения между типами грамматик: (1) любая регулярная грамматика является кс-грамматикой; (2) любая регулярная грамматика является укс-грамматикой; (3) любая кс- грамматика является укс-грамматикой; (4) любая кс-грамматика является кз-грамматикой; (5) любая кс-грамматика является неукорачивающей грамматикой; (6) любая кз-грамматика является грамматикой типа 0.,регулярная грамматика,gramm,1
любая неукорачивающая грамматика является грамматикой типа 0.,грамматикой,gramm,1
любая неукорачивающая грамматика является грамматикой типа 0.,грамматика,gramm,1
любая неукорачивающая грамматика является грамматикой типа 0.,грамматикой типа,gramm,1
(8) любая укс-грамматика является грамматикой типа 0.,грамматикой,gramm,1
(8) любая укс-грамматика является грамматикой типа 0.,грамматика,gramm,1
(8) любая укс-грамматика является грамматикой типа 0.,грамматикой типа,gramm,1
"10 замечание: укс-грамматика, содержащая правила вида a , не является кз-грамматикой и не является неукорачивающей грамматикой.",грамматикой,gramm,1
"10 замечание: укс-грамматика, содержащая правила вида a , не является кз-грамматикой и не является неукорачивающей грамматикой.",грамматика,gramm,1
"10 замечание: укс-грамматика, содержащая правила вида a , не является кз-грамматикой и не является неукорачивающей грамматикой.",укс-грамматика,gramm,1
"определение: язык l(g) является языком типа k, если его можно описать грамматикой типа k. соотношения между типами языков: (1) каждый регулярный язык является кс-языком, но существуют кс-языки, которые не являются регулярными ( например, l = {anbn n>0}).",кс-языки,gramm,1
"определение: язык l(g) является языком типа k, если его можно описать грамматикой типа k. соотношения между типами языков: (1) каждый регулярный язык является кс-языком, но существуют кс-языки, которые не являются регулярными ( например, l = {anbn n>0}).",кс-языком,gramm,1
"(2) каждый кс-язык является кз-языком, но существуют кз- языки, которые не являются кс-языками ( например, l = {anbncn n>0}).",кс-язык,gramm,1
"замечание: укс-язык, содержащий пустую цепочку, не является кз-языком.",пустую цепочку,gramm,1
"замечание: укс-язык, содержащий пустую цепочку, не является кз-языком.",цепочку,gramm,1
"замечание: следует подчеркнуть, что если язык задан грамматикой типа k, то это не значит, что не существует грамматики типа k (k >k), описывающей тот же язык.",грамматики,gramm,1
"замечание: следует подчеркнуть, что если язык задан грамматикой типа k, то это не значит, что не существует грамматики типа k (k >k), описывающей тот же язык.",грамматики типа,gramm,1
"поэтому, когда говорят о языке типа k, обычно имеют в виду максимально возможный номер k. например, грамматика типа 0 g1 = ({0,1}, {a,s}, p1, s) и кс-грамматика g2 = ({0,1}, {s}, p2, s), где p1: s 0a1 p2: s 0s1 01 0a 00a1 a описывают один и тот же язык l = l(g1) = l(g2) = { 0n1n n>0}.",кс-грамматика,gramm,1
"поэтому, когда говорят о языке типа k, обычно имеют в виду максимально возможный номер k. например, грамматика типа 0 g1 = ({0,1}, {a,s}, p1, s) и кс-грамматика g2 = ({0,1}, {s}, p2, s), где p1: s 0a1 p2: s 0s1 01 0a 00a1 a описывают один и тот же язык l = l(g1) = l(g2) = { 0n1n n>0}.",грамматика,gramm,1
"язык l называют кс-языком, т.к. существует кс-грамматика, его описывающая.",грамматика,gramm,1
"язык l называют кс-языком, т.к. существует кс-грамматика, его описывающая.",кс-языком,gramm,1
"но он не является регулярным языком, т.к. не существует регулярной грамматики, описывающей этот язык [3].",грамматики,gramm,1
"но он не является регулярным языком, т.к. не существует регулярной грамматики, описывающей этот язык [3].",регулярной грамматики,gramm,1
примеры грамматик и языков.,грамматик,gramm,1
"замечание: если при описании грамматики указаны только правила вывода р, то будем считать, что большие латинские буквы обозначают нетерминальные символы, s - цель грамматики, все остальные символы - терминальные.",грамматики,gramm,1
"замечание: если при описании грамматики указаны только правила вывода р, то будем считать, что большие латинские буквы обозначают нетерминальные символы, s - цель грамматики, все остальные символы - терминальные.",нетерминальные символы,gramm,1
"1) язык типа 0: l(g) = {a2 bn2-1 n >= 1} g: s aacfd f afb ab ab bba ab ba ad d cb bc 11 cb c bcd 2) язык типа 1: l(g) = { an bn cn, n >= 1} g: s asbc abc cb bc bb bb bc bc cc cc 3) язык типа 2: l(g) = {(ac)n (cb)n n > 0} g: s aqb accb q csc 4) язык типа 3: l(g) = { {a,b}+, где нет двух рядом стоящих а} g: s a b a a ba b b bb ab разбор цепочек цепочка принадлежит языку, порождаемому грамматикой, только в том случае, если существует ее вывод из цели этой грамматики.",грамматики,gramm,1
"1) язык типа 0: l(g) = {a2 bn2-1 n >= 1} g: s aacfd f afb ab ab bba ab ba ad d cb bc 11 cb c bcd 2) язык типа 1: l(g) = { an bn cn, n >= 1} g: s asbc abc cb bc bb bb bc bc cc cc 3) язык типа 2: l(g) = {(ac)n (cb)n n > 0} g: s aqb accb q csc 4) язык типа 3: l(g) = { {a,b}+, где нет двух рядом стоящих а} g: s a b a a ba b b bb ab разбор цепочек цепочка принадлежит языку, порождаемому грамматикой, только в том случае, если существует ее вывод из цели этой грамматики.",грамматикой,gramm,1
"1) язык типа 0: l(g) = {a2 bn2-1 n >= 1} g: s aacfd f afb ab ab bba ab ba ad d cb bc 11 cb c bcd 2) язык типа 1: l(g) = { an bn cn, n >= 1} g: s asbc abc cb bc bb bb bc bc cc cc 3) язык типа 2: l(g) = {(ac)n (cb)n n > 0} g: s aqb accb q csc 4) язык типа 3: l(g) = { {a,b}+, где нет двух рядом стоящих а} g: s a b a a ba b b bb ab разбор цепочек цепочка принадлежит языку, порождаемому грамматикой, только в том случае, если существует ее вывод из цели этой грамматики.",цепочек,gramm,1
"1) язык типа 0: l(g) = {a2 bn2-1 n >= 1} g: s aacfd f afb ab ab bba ab ba ad d cb bc 11 cb c bcd 2) язык типа 1: l(g) = { an bn cn, n >= 1} g: s asbc abc cb bc bb bb bc bc cc cc 3) язык типа 2: l(g) = {(ac)n (cb)n n > 0} g: s aqb accb q csc 4) язык типа 3: l(g) = { {a,b}+, где нет двух рядом стоящих а} g: s a b a a ba b b bb ab разбор цепочек цепочка принадлежит языку, порождаемому грамматикой, только в том случае, если существует ее вывод из цели этой грамматики.",разбор,gramm,1
"1) язык типа 0: l(g) = {a2 bn2-1 n >= 1} g: s aacfd f afb ab ab bba ab ba ad d cb bc 11 cb c bcd 2) язык типа 1: l(g) = { an bn cn, n >= 1} g: s asbc abc cb bc bb bb bc bc cc cc 3) язык типа 2: l(g) = {(ac)n (cb)n n > 0} g: s aqb accb q csc 4) язык типа 3: l(g) = { {a,b}+, где нет двух рядом стоящих а} g: s a b a a ba b b bb ab разбор цепочек цепочка принадлежит языку, порождаемому грамматикой, только в том случае, если существует ее вывод из цели этой грамматики.",цепочка,gramm,1
"процесс построения такого вывода ( а, следовательно, и определения принадлежности цепочки языку) называется разбором.",цепочки,gramm,1
"процесс построения такого вывода ( а, следовательно, и определения принадлежности цепочки языку) называется разбором.",разбором,gramm,1
"процесс построения такого вывода ( а, следовательно, и определения принадлежности цепочки языку) называется разбором.",цепочки языку,gramm,1
с практической точки зрения наибольший интерес представляет разбор по контекстно-свободным (кс и укс) грамматикам.,разбор,gramm,1
с практической точки зрения наибольший интерес представляет разбор по контекстно-свободным (кс и укс) грамматикам.,грамматикам,gramm,1
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",грамматик,gramm,1
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",кс-грамматик,gramm,1
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",разбора,gramm,1
"рассмотрим основные понятия и определения, связанные с разбором по кс-грамматике.",разбором,gramm,1
"рассмотрим основные понятия и определения, связанные с разбором по кс-грамматике.",грамматике,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется левым (левосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого левого нетерминала.",цепочки,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется левым (левосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого левого нетерминала.",грамматике,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется левым (левосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого левого нетерминала.",вывод цепочки,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется левым (левосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого левого нетерминала.",сентенциальная форма,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется правым (правосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого правого нетерминала.",цепочки,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется правым (правосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого правого нетерминала.",грамматике,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется правым (правосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого правого нетерминала.",вывод цепочки,gramm,1
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется правым (правосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого правого нетерминала.",сентенциальная форма,gramm,1
"12 в грамматике для одной и той же цепочки может быть несколько выводов, эквивалентных в том смысле, что в них в одних и тех же местах применяются одни и те же правила вывода, но в различном порядке.",цепочки,gramm,1
"12 в грамматике для одной и той же цепочки может быть несколько выводов, эквивалентных в том смысле, что в них в одних и тех же местах применяются одни и те же правила вывода, но в различном порядке.",грамматике,gramm,1
"например, для цепочки a+b+a в грамматике g = ({a,b,+}, {s,t}, {s t t+s; t a b}, s) можно построить выводы: (1) s t+s t+t+s t+t+t a+t+t a+b+t a+b+a (2) s t+s a+s a+t+s a+b+s a+b+t a+b+a (3) s t+s t+t+s t+t+t t+t+a t+b+a a+b+a здесь (2) - левосторонний вывод, (3) - правосторонний, а (1) не является ни левосторонним, ни правосторонним, но все эти выводы являются эквивалентными в указанном выше смысле.",цепочки,gramm,1
"например, для цепочки a+b+a в грамматике g = ({a,b,+}, {s,t}, {s t t+s; t a b}, s) можно построить выводы: (1) s t+s t+t+s t+t+t a+t+t a+b+t a+b+a (2) s t+s a+s a+t+s a+b+s a+b+t a+b+a (3) s t+s t+t+s t+t+t t+t+a t+b+a a+b+a здесь (2) - левосторонний вывод, (3) - правосторонний, а (1) не является ни левосторонним, ни правосторонним, но все эти выводы являются эквивалентными в указанном выше смысле.",левосторонний вывод,gramm,1
"например, для цепочки a+b+a в грамматике g = ({a,b,+}, {s,t}, {s t t+s; t a b}, s) можно построить выводы: (1) s t+s t+t+s t+t+t a+t+t a+b+t a+b+a (2) s t+s a+s a+t+s a+b+s a+b+t a+b+a (3) s t+s t+t+s t+t+t t+t+a t+b+a a+b+a здесь (2) - левосторонний вывод, (3) - правосторонний, а (1) не является ни левосторонним, ни правосторонним, но все эти выводы являются эквивалентными в указанном выше смысле.",грамматике,gramm,1
"для кс-грамматик можно ввести удобное графическое представление вывода, называемое деревом вывода, причем для всех эквивалентных выводов деревья вывода совпадают.",деревом вывода,gramm,1
"для кс-грамматик можно ввести удобное графическое представление вывода, называемое деревом вывода, причем для всех эквивалентных выводов деревья вывода совпадают.",грамматик,gramm,1
"для кс-грамматик можно ввести удобное графическое представление вывода, называемое деревом вывода, причем для всех эквивалентных выводов деревья вывода совпадают.",кс-грамматик,gramm,1
"для кс-грамматик можно ввести удобное графическое представление вывода, называемое деревом вывода, причем для всех эквивалентных выводов деревья вывода совпадают.",деревья вывода,gramm,1
"определение: дерево называется деревом вывода (или деревом разбора) в кс-грамматике g = {vt, vn, p, s), если выполнены следующие условия: (1) каждая вершина дерева помечена символом из множества (vn vt ) , при этом корень дерева помечен символом s; листья - символами из (vt ); (2) если вершина дерева помечена символом a vn, а ее непосредственные потомки - символами a1, a2, ... , an, где каждое ai (vt vn), то a a1a2...an - правило вывода в этой грамматике; (3) если вершина дерева помечена символом a vn, а ее единственный непосредственный потомок помечен символом , то a - правило вывода в этой грамматике.",деревом вывода,gramm,1
"определение: дерево называется деревом вывода (или деревом разбора) в кс-грамматике g = {vt, vn, p, s), если выполнены следующие условия: (1) каждая вершина дерева помечена символом из множества (vn vt ) , при этом корень дерева помечен символом s; листья - символами из (vt ); (2) если вершина дерева помечена символом a vn, а ее непосредственные потомки - символами a1, a2, ... , an, где каждое ai (vt vn), то a a1a2...an - правило вывода в этой грамматике; (3) если вершина дерева помечена символом a vn, а ее единственный непосредственный потомок помечен символом , то a - правило вывода в этой грамматике.",деревом разбора,gramm,1
"определение: дерево называется деревом вывода (или деревом разбора) в кс-грамматике g = {vt, vn, p, s), если выполнены следующие условия: (1) каждая вершина дерева помечена символом из множества (vn vt ) , при этом корень дерева помечен символом s; листья - символами из (vt ); (2) если вершина дерева помечена символом a vn, а ее непосредственные потомки - символами a1, a2, ... , an, где каждое ai (vt vn), то a a1a2...an - правило вывода в этой грамматике; (3) если вершина дерева помечена символом a vn, а ее единственный непосредственный потомок помечен символом , то a - правило вывода в этой грамматике.",грамматике,gramm,1
"определение: дерево называется деревом вывода (или деревом разбора) в кс-грамматике g = {vt, vn, p, s), если выполнены следующие условия: (1) каждая вершина дерева помечена символом из множества (vn vt ) , при этом корень дерева помечен символом s; листья - символами из (vt ); (2) если вершина дерева помечена символом a vn, а ее непосредственные потомки - символами a1, a2, ... , an, где каждое ai (vt vn), то a a1a2...an - правило вывода в этой грамматике; (3) если вершина дерева помечена символом a vn, а ее единственный непосредственный потомок помечен символом , то a - правило вывода в этой грамматике.",разбора,gramm,1
"пример дерева вывода для цепочки a+b+a в грамматике g: t a t t s a s b + + s определение: кс-грамматика g называется неоднозначной, если существует хотя бы одна цепочка l(g), для которой может быть построено два или более различных деревьев вывода.",цепочки,gramm,1
"пример дерева вывода для цепочки a+b+a в грамматике g: t a t t s a s b + + s определение: кс-грамматика g называется неоднозначной, если существует хотя бы одна цепочка l(g), для которой может быть построено два или более различных деревьев вывода.",грамматике,gramm,1
"пример дерева вывода для цепочки a+b+a в грамматике g: t a t t s a s b + + s определение: кс-грамматика g называется неоднозначной, если существует хотя бы одна цепочка l(g), для которой может быть построено два или более различных деревьев вывода.",дерева вывода,gramm,1
"пример дерева вывода для цепочки a+b+a в грамматике g: t a t t s a s b + + s определение: кс-грамматика g называется неоднозначной, если существует хотя бы одна цепочка l(g), для которой может быть построено два или более различных деревьев вывода.",деревьев вывода,gramm,1
"пример дерева вывода для цепочки a+b+a в грамматике g: t a t t s a s b + + s определение: кс-грамматика g называется неоднозначной, если существует хотя бы одна цепочка l(g), для которой может быть построено два или более различных деревьев вывода.",грамматика,gramm,1
"пример дерева вывода для цепочки a+b+a в грамматике g: t a t t s a s b + + s определение: кс-грамматика g называется неоднозначной, если существует хотя бы одна цепочка l(g), для которой может быть построено два или более различных деревьев вывода.",цепочка,gramm,1
"13 это утверждение эквивалентно тому, что цепочка имеет два или более разных левосторонних (или правосторонних) выводов.",цепочка,gramm,1
определение: в противном случае грамматика называется однозначной.,грамматика,gramm,1
"определение: язык, порождаемый грамматикой, называется неоднозначным, если он не может быть порожден никакой однозначной грамматикой.",грамматикой,gramm,1
"определение: язык, порождаемый грамматикой, называется неоднозначным, если он не может быть порожден никакой однозначной грамматикой.",однозначной грамматикой,gramm,1
"пример неоднозначной грамматики: g = ({if, then, else, a, b}, {s}, p, s), где p = {s if b then s else s if b then s a}.",неоднозначной грамматики,gramm,1
"пример неоднозначной грамматики: g = ({if, then, else, a, b}, {s}, p, s), где p = {s if b then s else s if b then s a}.",грамматики,gramm,1
в этой грамматике для цепочки if b then if b then a else a можно построить два различных дерева вывода.,цепочки,gramm,1
в этой грамматике для цепочки if b then if b then a else a можно построить два различных дерева вывода.,грамматике,gramm,1
в этой грамматике для цепочки if b then if b then a else a можно построить два различных дерева вывода.,дерева вывода,gramm,1
"определенная нами неоднозначность - это свойство грамматики, а не языка, т.е. для некоторых неоднозначных грамматик существуют эквивалентные им однозначные грамматики.",грамматики,gramm,1
"определенная нами неоднозначность - это свойство грамматики, а не языка, т.е. для некоторых неоднозначных грамматик существуют эквивалентные им однозначные грамматики.",неоднозначных грамматик,gramm,1
"определенная нами неоднозначность - это свойство грамматики, а не языка, т.е. для некоторых неоднозначных грамматик существуют эквивалентные им однозначные грамматики.",грамматик,gramm,1
"если грамматика используется для определения языка программирования, то она должна быть однозначной.",грамматика,gramm,1
в приведенном выше примере разные деревья вывода предполагают соответствие else разным then.,деревья вывода,gramm,1
"если договориться, что else должно соответствовать ближайшему к нему then, и подправить грамматику g, то неоднозначность будет устранена: s if b then s if b then s else s a s if b then s else s a проблема, порождает ли данная кс-грамматика однозначный язык (т.е. существует ли эквивалентная ей однозначная грамматика), является алгоритмически неразрешимой.",грамматика,gramm,1
"если договориться, что else должно соответствовать ближайшему к нему then, и подправить грамматику g, то неоднозначность будет устранена: s if b then s if b then s else s a s if b then s else s a проблема, порождает ли данная кс-грамматика однозначный язык (т.е. существует ли эквивалентная ей однозначная грамматика), является алгоритмически неразрешимой.",грамматику,gramm,1
"если договориться, что else должно соответствовать ближайшему к нему then, и подправить грамматику g, то неоднозначность будет устранена: s if b then s if b then s else s a s if b then s else s a проблема, порождает ли данная кс-грамматика однозначный язык (т.е. существует ли эквивалентная ей однозначная грамматика), является алгоритмически неразрешимой.",однозначная грамматика,gramm,1
"однако можно указать некоторые виды правил вывода, которые приводят к неоднозначности: (1)a aa (2)a a a (3)a a a (4)a a a a пример неоднозначного кс-языка: l = {ai bj ck i = j или j = k}.",кс-языка,gramm,1
"интуитивно это объясняется тем, что цепочки с i = j должны порождаться группой правил вывода, отличных от правил, порождающих цепочки с j = k. но тогда, по крайней мере, некоторые из цепочек с i = j = k будут порождаться обеими группами правил и, следовательно, будут иметь по два разных 14 дерева вывода.",цепочки,gramm,1
"интуитивно это объясняется тем, что цепочки с i = j должны порождаться группой правил вывода, отличных от правил, порождающих цепочки с j = k. но тогда, по крайней мере, некоторые из цепочек с i = j = k будут порождаться обеими группами правил и, следовательно, будут иметь по два разных 14 дерева вывода.",цепочек,gramm,1
"интуитивно это объясняется тем, что цепочки с i = j должны порождаться группой правил вывода, отличных от правил, порождающих цепочки с j = k. но тогда, по крайней мере, некоторые из цепочек с i = j = k будут порождаться обеими группами правил и, следовательно, будут иметь по два разных 14 дерева вывода.",дерева вывода,gramm,1
"доказательство того, что кс-язык l неоднозначный, приведено в [3, стр. 235-236].",кс-язык,gramm,1
"одна из грамматик, порождающих l, такова: s ab dc a aa b bbc c cc d adb очевидно, что она неоднозначна.",грамматик,gramm,1
дерево вывода можно строить нисходящим либо восходящим способом.,дерево вывода,gramm,1
"при нисходящем разборе дерево вывода формируется от корня к листьям; на каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти такое правило вывода, чтобы имеющиеся в нем терминальные символы проектировались на символы исходной цепочки.",цепочки,gramm,1
"при нисходящем разборе дерево вывода формируется от корня к листьям; на каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти такое правило вывода, чтобы имеющиеся в нем терминальные символы проектировались на символы исходной цепочки.",дерево вывода,gramm,1
"при нисходящем разборе дерево вывода формируется от корня к листьям; на каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти такое правило вывода, чтобы имеющиеся в нем терминальные символы проектировались на символы исходной цепочки.",нетерминальным символом,gramm,1
"при нисходящем разборе дерево вывода формируется от корня к листьям; на каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти такое правило вывода, чтобы имеющиеся в нем терминальные символы проектировались на символы исходной цепочки.",терминальные символы,gramm,1
"при нисходящем разборе дерево вывода формируется от корня к листьям; на каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти такое правило вывода, чтобы имеющиеся в нем терминальные символы проектировались на символы исходной цепочки.",разборе,gramm,1
"метод восходящего разбора заключается в том, что исходную цепочку пытаются свернуть к начальному символу s; на каждом шаге ищут подцепочку, которая совпадает с правой частью какого-либо правила вывода; если такая подцепочка находится, то она заменяется нетерминалом из левой части этого правила.",восходящего разбора,gramm,1
"метод восходящего разбора заключается в том, что исходную цепочку пытаются свернуть к начальному символу s; на каждом шаге ищут подцепочку, которая совпадает с правой частью какого-либо правила вывода; если такая подцепочка находится, то она заменяется нетерминалом из левой части этого правила.",цепочку,gramm,1
"метод восходящего разбора заключается в том, что исходную цепочку пытаются свернуть к начальному символу s; на каждом шаге ищут подцепочку, которая совпадает с правой частью какого-либо правила вывода; если такая подцепочка находится, то она заменяется нетерминалом из левой части этого правила.",разбора,gramm,1
"если грамматика однозначная, то при любом способе построения будет получено одно и то же дерево разбора.",дерево разбора,gramm,1
"если грамматика однозначная, то при любом способе построения будет получено одно и то же дерево разбора.",грамматика,gramm,1
"если грамматика однозначная, то при любом способе построения будет получено одно и то же дерево разбора.",разбора,gramm,1
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",цепочек языка,gramm,1
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",грамматики,gramm,1
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",цепочек,gramm,1
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",бесплодные символы,gramm,1
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",кс-грамматика,gramm,1
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",грамматик,gramm,1
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",грамматика,gramm,1
"определение: символ x (vt vn) называется недостижимым в грамматике g = (vt, vn, p, s), если он не появляется ни в одной сентенциальной форме этой грамматики.",грамматики,gramm,1
"определение: символ x (vt vn) называется недостижимым в грамматике g = (vt, vn, p, s), если он не появляется ни в одной сентенциальной форме этой грамматики.",грамматике,gramm,1
"определение: символ x (vt vn) называется недостижимым в грамматике g = (vt, vn, p, s), если он не появляется ни в одной сентенциальной форме этой грамматики.",сентенциальной форме,gramm,1
"алгоритм удаления недостижимых символов: вход: кс-грамматика g = (vt, vn, p, s) выход: кс-грамматика g = (vt , vn , p , s), не содержащая недостижимых символов, для которой l(g) = l(g ).",грамматика,gramm,1
"определение: символ a vn называется бесплодным в грамматике g = (vt, vn, p, s), если множество { vt a } пусто.",грамматике,gramm,1
"алгоритм удаления бесплодных символов: вход: кс-грамматика g = (vt, vn, p, s).",бесплодных символов,gramm,1
"алгоритм удаления бесплодных символов: вход: кс-грамматика g = (vt, vn, p, s).",грамматика,gramm,1
"выход: кс-грамматика g = (vt, vn , p , s), не содержащая бесплодных символов, для которой l(g) = l(g ).",бесплодных символов,gramm,1
"выход: кс-грамматика g = (vt, vn , p , s), не содержащая бесплодных символов, для которой l(g) = l(g ).",грамматика,gramm,1
"определение: кс-грамматика g называется приведенной, если в ней нет недостижимых и бесплодных символов.",бесплодных символов,gramm,1
"определение: кс-грамматика g называется приведенной, если в ней нет недостижимых и бесплодных символов.",грамматика,gramm,1
алгоритм приведения грамматики: (1)обнаруживаются и удаляются все бесплодные нетерминалы.,грамматики,gramm,1
"замечание: если в этом алгоритме переставить шаги (1) и (2), то не всегда результатом будет приведенная грамматика.",грамматика,gramm,1
для описания синтаксиса языков программирования стараются использовать однозначные приведенные кс- грамматики.,грамматики,gramm,1
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",синтаксический анализ,gramm,1
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",семантический анализ,gramm,1
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",лексический анализ,gramm,1
"описание модельного языка p program d1; b d1 var d {,d} d i {,i}: [ int bool ] b begin s {;s} end s i := e if e then s else s while e do s b read (i) write (e) e e1 [ = < > != ] e1 e1 e1 t {[ + - or ] t} t f {[ / and ] f} f i n l not f (e) l true false i c ic ir n r nr c a b ... z a b ... z 22 r 0 1 2 ...",модельного языка,gramm,1
"9 замечание: a) запись вида { } означает итерацию цепочки , т.е. в порождаемой цепочке в этом месте может находиться либо , либо , либо , либо и т.д. b) запись вида [ ] означает, что в порождаемой цепочке в этом месте может находиться либо , либо . c) p - цель грамматики; символ - маркер конца текста программы.",грамматики,gramm,1
"9 замечание: a) запись вида { } означает итерацию цепочки , т.е. в порождаемой цепочке в этом месте может находиться либо , либо , либо , либо и т.д. b) запись вида [ ] означает, что в порождаемой цепочке в этом месте может находиться либо , либо . c) p - цель грамматики; символ - маркер конца текста программы.",цепочке,gramm,1
"9 замечание: a) запись вида { } означает итерацию цепочки , т.е. в порождаемой цепочке в этом месте может находиться либо , либо , либо , либо и т.д. b) запись вида [ ] означает, что в порождаемой цепочке в этом месте может находиться либо , либо . c) p - цель грамматики; символ - маркер конца текста программы.",цепочки,gramm,1
контекстные условия: 1.,контекстные условия,gramm,1
"лексический анализ рассмотрим методы и средства, которые обычно используются при построении лексических анализаторов.",лексический анализ,gramm,1
"лексический анализ рассмотрим методы и средства, которые обычно используются при построении лексических анализаторов.",лексических анализаторов,gramm,1
"в основе таких анализаторов лежат регулярные грамматики, поэтому рассмотрим грамматики этого класса более подробно.",грамматики,gramm,1
"в основе таких анализаторов лежат регулярные грамматики, поэтому рассмотрим грамматики этого класса более подробно.",регулярные грамматики,gramm,1
"соглашение: в дальнейшем, если особо не оговорено, под регулярной грамматикой будем понимать леволинейную грамматику.",грамматикой,gramm,1
"соглашение: в дальнейшем, если особо не оговорено, под регулярной грамматикой будем понимать леволинейную грамматику.",грамматику,gramm,1
"соглашение: в дальнейшем, если особо не оговорено, под регулярной грамматикой будем понимать леволинейную грамматику.",регулярной грамматикой,gramm,1
"напомним, что грамматика g = (vt, vn, p, s) называется леволинейной, если каждое правило из р имеет вид a bt либо a t, где a vn, b vn, t vt.",грамматика,gramm,1
"соглашение: предположим, что анализируемая цепочка заканчивается специальным символом - признаком конца цепочки.",цепочки,gramm,1
"соглашение: предположим, что анализируемая цепочка заканчивается специальным символом - признаком конца цепочки.",цепочка,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",свертку,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",цепочки,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",дерева разбора,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",грамматике,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",грамматикой,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",разбора,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",нетерминал,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",грамматик,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",терминал,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",терминала,gramm,1
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",цепочка,gramm,1
"при работе этого алгоритма возможны следующие ситуации: (1) прочитана вся цепочка; на каждом шаге находилась единственная нужная ""свертка""; на последнем шаге свертка произошла к символу s. это означает, что исходная цепочка a1a2...an l(g).",свертка,gramm,1
"при работе этого алгоритма возможны следующие ситуации: (1) прочитана вся цепочка; на каждом шаге находилась единственная нужная ""свертка""; на последнем шаге свертка произошла к символу s. это означает, что исходная цепочка a1a2...an l(g).",цепочка,gramm,1
"прочитана вся цепочка; на каждом шаге находилась единственная нужная ""свертка""; на последнем шаге свертка произошла к символу, отличному от s. это означает, что исходная цепочка a1a2...an l(g).",свертка,gramm,1
"прочитана вся цепочка; на каждом шаге находилась единственная нужная ""свертка""; на последнем шаге свертка произошла к символу, отличному от s. это означает, что исходная цепочка a1a2...an l(g).",цепочка,gramm,1
"(3) на некотором шаге не нашлось нужной свертки, т.е. для полученного на предыдущем шаге нетерминала a и расположенного непосредственно справа от него очередного терминала ai исходной цепочки не нашлось нетерминала b, для которого в грамматике было бы правило вывода b aai.",цепочки,gramm,1
"(3) на некотором шаге не нашлось нужной свертки, т.е. для полученного на предыдущем шаге нетерминала a и расположенного непосредственно справа от него очередного терминала ai исходной цепочки не нашлось нетерминала b, для которого в грамматике было бы правило вывода b aai.",грамматике,gramm,1
"(3) на некотором шаге не нашлось нужной свертки, т.е. для полученного на предыдущем шаге нетерминала a и расположенного непосредственно справа от него очередного терминала ai исходной цепочки не нашлось нетерминала b, для которого в грамматике было бы правило вывода b aai.",терминала,gramm,1
"(3) на некотором шаге не нашлось нужной свертки, т.е. для полученного на предыдущем шаге нетерминала a и расположенного непосредственно справа от него очередного терминала ai исходной цепочки не нашлось нетерминала b, для которого в грамматике было бы правило вывода b aai.",свертки,gramm,1
"это означает, что исходная цепочка a1a2...an l(g).",цепочка,gramm,1
"(4) на некотором шаге работы алгоритма оказалось, что есть более одной подходящей свертки, т.е. в грамматике разные нетерминалы имеют правила вывода с одинаковыми правыми частями, и поэтому непонятно, к какому из них производить свертку.",свертку,gramm,1
"(4) на некотором шаге работы алгоритма оказалось, что есть более одной подходящей свертки, т.е. в грамматике разные нетерминалы имеют правила вывода с одинаковыми правыми частями, и поэтому непонятно, к какому из них производить свертку.",грамматике,gramm,1
"(4) на некотором шаге работы алгоритма оказалось, что есть более одной подходящей свертки, т.е. в грамматике разные нетерминалы имеют правила вывода с одинаковыми правыми частями, и поэтому непонятно, к какому из них производить свертку.",свертки,gramm,1
это говорит о недетерминированности разбора.,разбора,gramm,1
"допустим, что разбор на каждом шаге детерминированный.",разбор,gramm,1
"для того, чтобы быстрее находить правило с подходящей правой частью, зафиксируем все возможные свертки (это определяется только грамматикой и не зависит от вида анализируемой цепочки).",цепочки,gramm,1
"24 это можно сделать в виде таблицы, строки которой помечены нетерминальными символами грамматики, столбцы - терминальными.",грамматики,gramm,1
"24 это можно сделать в виде таблицы, строки которой помечены нетерминальными символами грамматики, столбцы - терминальными.",нетерминальными символами,gramm,1
"значение каждого элемента таблицы - это нетерминальный символ, к которому можно свернуть пару ""нетерминал-терминал"", которыми помечены соответствующие строка и столбец.",нетерминал,gramm,1
"значение каждого элемента таблицы - это нетерминальный символ, к которому можно свернуть пару ""нетерминал-терминал"", которыми помечены соответствующие строка и столбец.",нетерминальный символ,gramm,1
"значение каждого элемента таблицы - это нетерминальный символ, к которому можно свернуть пару ""нетерминал-терминал"", которыми помечены соответствующие строка и столбец.",терминал,gramm,1
"например, для грамматики g = ({a, b, }, {s, a, b, c}, p, s), такая таблица будет выглядеть следующим образом: a b p: s c c a b s c ab ba a - c - a a ca b c - - b b cb s - - - знак ""-"" ставится в том случае, если для пары ""терминал- нетерминал"" свертки нет.",нетерминал,gramm,1
"например, для грамматики g = ({a, b, }, {s, a, b, c}, p, s), такая таблица будет выглядеть следующим образом: a b p: s c c a b s c ab ba a - c - a a ca b c - - b b cb s - - - знак ""-"" ставится в том случае, если для пары ""терминал- нетерминал"" свертки нет.",грамматики,gramm,1
"например, для грамматики g = ({a, b, }, {s, a, b, c}, p, s), такая таблица будет выглядеть следующим образом: a b p: s c c a b s c ab ba a - c - a a ca b c - - b b cb s - - - знак ""-"" ставится в том случае, если для пары ""терминал- нетерминал"" свертки нет.",свертки,gramm,1
"но чаще информацию о возможных свертках представляют в виде диаграммы состояний (дс) - неупорядоченного ориентированного помеченного графа, который строится следующим образом: (1) строят вершины графа, помеченные нетерминалами грамматики (для каждого нетерминала - одну вершину), и еще одну вершину, помеченную символом, отличным от нетерминальных (например, h).",грамматики,gramm,1
"но чаще информацию о возможных свертках представляют в виде диаграммы состояний (дс) - неупорядоченного ориентированного помеченного графа, который строится следующим образом: (1) строят вершины графа, помеченные нетерминалами грамматики (для каждого нетерминала - одну вершину), и еще одну вершину, помеченную символом, отличным от нетерминальных (например, h).",диаграммы состояний,gramm,1
"но чаще информацию о возможных свертках представляют в виде диаграммы состояний (дс) - неупорядоченного ориентированного помеченного графа, который строится следующим образом: (1) строят вершины графа, помеченные нетерминалами грамматики (для каждого нетерминала - одну вершину), и еще одну вершину, помеченную символом, отличным от нетерминальных (например, h).",свертках,gramm,1
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",цепочки,gramm,1
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",грамматики,gramm,1
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",диаграмме состояний,gramm,1
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",разбора,gramm,1
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",диаграмма состояний,gramm,1
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",цепочки,gramm,1
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",регулярной грамматике,gramm,1
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",грамматике,gramm,1
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",разборе,gramm,1
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",цепочка,gramm,1
"это означает, что исходная цепочка принадлежит l(g).",цепочка,gramm,1
"прочитана вся цепочка; на каждом шаге находилась единственная ""нужная"" дуга; в результате последнего шага оказались в состоянии, отличном от s. это означает, что исходная цепочка не принадлежит l(g).",цепочка,gramm,1
"это означает, что исходная цепочка не принадлежит l(g).",цепочка,gramm,1
"диаграмма состояний определяет конечный автомат, построенный по регулярной грамматике, который допускает множество цепочек, составляющих язык, определяемый этой грамматикой.",регулярной грамматике,gramm,1
"диаграмма состояний определяет конечный автомат, построенный по регулярной грамматике, который допускает множество цепочек, составляющих язык, определяемый этой грамматикой.",грамматике,gramm,1
"диаграмма состояний определяет конечный автомат, построенный по регулярной грамматике, который допускает множество цепочек, составляющих язык, определяемый этой грамматикой.",цепочек,gramm,1
"диаграмма состояний определяет конечный автомат, построенный по регулярной грамматике, который допускает множество цепочек, составляющих язык, определяемый этой грамматикой.",грамматикой,gramm,1
"диаграмма состояний определяет конечный автомат, построенный по регулярной грамматике, который допускает множество цепочек, составляющих язык, определяемый этой грамматикой.",диаграмма состояний,gramm,1
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",функции переходов,gramm,1
"среди всех состояний выделяется начальное (считается, что в начальный момент своей работы автомат находится в этом состоянии) и конечное (если автомат завершает работу переходом в это состояние, то анализируемая цепочка им допускается).",цепочка,gramm,1
"определение: конечный автомат (ка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt k, определяющее поведение автомата; отображение f часто называют функцией переходов; h k - начальное состояние; 26 s k - заключительное состояние (либо конечное множество заключительных состояний).",функцией переходов,gramm,1
"f(a, t) = b означает, что из состояния a по входному символу t происходит переход в состояние b. определение: конечный автомат допускает цепочку a1a2...an, если f(h,a1) = a1; f(a1,a2) = a2; . . .",цепочку,gramm,1
"определение: множество цепочек, допускаемых конечным автоматом, составляет определяемый им язык.",цепочек,gramm,1
"введем состояние ошибки (er); переход в это состояние будет означать, что исходная цепочка языку не принадлежит.",цепочка языку,gramm,1
"введем состояние ошибки (er); переход в это состояние будет означать, что исходная цепочка языку не принадлежит.",цепочка,gramm,1
по диаграмме состояний легко написать анализатор для регулярной грамматики.,грамматики,gramm,1
по диаграмме состояний легко написать анализатор для регулярной грамматики.,регулярной грамматики,gramm,1
по диаграмме состояний легко написать анализатор для регулярной грамматики.,диаграмме состояний,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",свертку,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",регулярной грамматике,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",грамматике,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",грамматики,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",разборе,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",недетерминированном разборе,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",цепочка,gramm,1
"в терминах диаграммы состояний это означает, что из одного состояния выходит несколько дуг, ведущих в разные состояния, но помеченных одним и тем же символом.",диаграммы состояний,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b}, p, s), где p: s a a a bb b b bb разбор будет недетерминированным (т.к. у нетерминалов a и b есть одинаковые правые части - bb).",грамматики,gramm,1
"например, для грамматики g = ({a,b, }, {s,a,b}, p, s), где p: s a a a bb b b bb разбор будет недетерминированным (т.к. у нетерминалов a и b есть одинаковые правые части - bb).",разбор,gramm,1
такой грамматике будет соответствовать недетерминированный конечный автомат.,грамматике,gramm,1
"f(a,t) = {b1,b2,...,bn} означает, что из состояния a по входному символу t можно осуществить переход в любое из состояний bi, i = 1, 2, ... ,n. в этом случае можно предложить алгоритм, который будет перебирать все возможные варианты сверток (переходов) один за другим; если цепочка принадлежит языку, то будет найден путь, ведущий к успеху; если будут просмотрены все варианты, и 28 каждый из них будет завершаться неудачей, то цепочка языку не принадлежит.",сверток,gramm,1
"f(a,t) = {b1,b2,...,bn} означает, что из состояния a по входному символу t можно осуществить переход в любое из состояний bi, i = 1, 2, ... ,n. в этом случае можно предложить алгоритм, который будет перебирать все возможные варианты сверток (переходов) один за другим; если цепочка принадлежит языку, то будет найден путь, ведущий к успеху; если будут просмотрены все варианты, и 28 каждый из них будет завершаться неудачей, то цепочка языку не принадлежит.",цепочка языку,gramm,1
"f(a,t) = {b1,b2,...,bn} означает, что из состояния a по входному символу t можно осуществить переход в любое из состояний bi, i = 1, 2, ... ,n. в этом случае можно предложить алгоритм, который будет перебирать все возможные варианты сверток (переходов) один за другим; если цепочка принадлежит языку, то будет найден путь, ведущий к успеху; если будут просмотрены все варианты, и 28 каждый из них будет завершаться неудачей, то цепочка языку не принадлежит.",цепочка,gramm,1
"таким образом, m = ({[h], [b], [a], [bs]}, {0, 1}, f , h, {[bs]}), где f ([a], 1) = [bs] f ([h], 1) = [b] f ([b], 0) = [a] f ([bs], 0) = [a] задачи лексического анализа лексический анализ (ла) - это первый этап процесса компиляции.",лексический анализ,gramm,1
"таким образом, m = ({[h], [b], [a], [bs]}, {0, 1}, f , h, {[bs]}), где f ([a], 1) = [bs] f ([h], 1) = [b] f ([b], 0) = [a] f ([bs], 0) = [a] задачи лексического анализа лексический анализ (ла) - это первый этап процесса компиляции.",лексического анализа,gramm,1
"на этом этапе символы, составляющие исходную программу, группируются в отдельные лексические элементы, называемые лексемами.",лексемами,gramm,1
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",лексическом анализаторе,gramm,1
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",лексический анализ,gramm,1
"каждой лексеме сопоставляется пара (тип лексемы, указатель на информацию о ней).",лексемы,gramm,1
"каждой лексеме сопоставляется пара (тип лексемы, указатель на информацию о ней).",лексеме,gramm,1
"таким образом, лексический анализатор - это транслятор, входом которого служит цепочка символов, представляющих исходную программу, а выходом - последовательность лексем.",лексический анализатор,gramm,1
"таким образом, лексический анализатор - это транслятор, входом которого служит цепочка символов, представляющих исходную программу, а выходом - последовательность лексем.",цепочка,gramm,1
"очевидно, что лексемы перечисленных выше типов можно описать с помощью регулярных грамматик.",грамматик,gramm,1
"очевидно, что лексемы перечисленных выше типов можно описать с помощью регулярных грамматик.",регулярных грамматик,gramm,1
"для грамматик этого класса, как мы уже видели, существует простой и эффективный алгоритм анализа того, принадлежит ли заданная цепочка языку, порождаемому этой грамматикой.",грамматик,gramm,1
"для грамматик этого класса, как мы уже видели, существует простой и эффективный алгоритм анализа того, принадлежит ли заданная цепочка языку, порождаемому этой грамматикой.",грамматикой,gramm,1
"для грамматик этого класса, как мы уже видели, существует простой и эффективный алгоритм анализа того, принадлежит ли заданная цепочка языку, порождаемому этой грамматикой.",цепочка,gramm,1
"однако перед лексическим анализатором стоит более сложная задача: он должен сам выделить в исходном тексте цепочку символов, представляющую лексему, а также преобразовать ее в пару (тип лексемы, указатель на информацию о ней).",лексемы,gramm,1
"однако перед лексическим анализатором стоит более сложная задача: он должен сам выделить в исходном тексте цепочку символов, представляющую лексему, а также преобразовать ее в пару (тип лексемы, указатель на информацию о ней).",лексему,gramm,1
"однако перед лексическим анализатором стоит более сложная задача: он должен сам выделить в исходном тексте цепочку символов, представляющую лексему, а также преобразовать ее в пару (тип лексемы, указатель на информацию о ней).",цепочку,gramm,1
"однако перед лексическим анализатором стоит более сложная задача: он должен сам выделить в исходном тексте цепочку символов, представляющую лексему, а также преобразовать ее в пару (тип лексемы, указатель на информацию о ней).",лексическим анализатором,gramm,1
"для того, чтобы решить эту задачу, опираясь на способ анализа с помощью диаграммы состояний, введем на дугах дополнительный вид пометок - пометки-действия.",диаграммы состояний,gramm,1
лексический анализатор для м-языка вход лексического анализатора - символы исходной программы на м-языке; результат работы - исходная программа в виде последовательности лексем (их внутреннего представления).,лексического анализатора,gramm,1
лексический анализатор для м-языка вход лексического анализатора - символы исходной программы на м-языке; результат работы - исходная программа в виде последовательности лексем (их внутреннего представления).,лексический анализатор,gramm,1
лексический анализатор для м-языка вход лексического анализатора - символы исходной программы на м-языке; результат работы - исходная программа в виде последовательности лексем (их внутреннего представления).,м-языка,gramm,1
лексический анализатор для м-языка вход лексического анализатора - символы исходной программы на м-языке; результат работы - исходная программа в виде последовательности лексем (их внутреннего представления).,м-языке,gramm,1
"лексический анализатор для модельного языка будем писать в два этапа: сначала построим диаграмму состояний с действиями для распознавания и формирования внутреннего представления лексем, а затем по ней напишем программу анализатора.",лексический анализатор,gramm,1
"лексический анализатор для модельного языка будем писать в два этапа: сначала построим диаграмму состояний с действиями для распознавания и формирования внутреннего представления лексем, а затем по ней напишем программу анализатора.",модельного языка,gramm,1
"лексический анализатор для модельного языка будем писать в два этапа: сначала построим диаграмму состояний с действиями для распознавания и формирования внутреннего представления лексем, а затем по ней напишем программу анализатора.",диаграмму состояний,gramm,1
"представление лексем: все лексемы м-языка разделим на несколько классов; классы перенумеруем: служебные слова - 1, ограничители - 2, константы (целые числа) - 3, идентификаторы - 4.",м-языка,gramm,1
"соглашение об используемых переменных, типах и функциях: 1) пусть есть переменные: buf - буфер для накопления символов лексемы;",лексемы,gramm,1
"31 c - очередной входной символ; d - переменная для формирования числового значения константы; tw - таблица служебных слов м-языка; td - таблица ограничителей м-языка; tid - таблица идентификаторов анализируемой программы; tnum - таблица чисел-констант, используемых в программе.",м-языка,gramm,1
"пусть есть функции: void clear (void); - очистка буфера buf; void add (void); - добавление символа с в конец буфера buf; int look (ptabl т); - поиск в таблице т лексемы из буфера buf; результат: номер строки таблицы с информацией о лексеме либо 0, если такой лексемы в таблице т нет; int putl (ptabl т);",лексеме,gramm,1
"результат: номер строки таблицы с информацией о лексеме; int putnum (); - запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum с информацией о константе-лексеме; void makelex (int k, int i); - формирование и вывод внутреннего представления лексемы; k - номер класса, i - номер в классе; void gc (void) - функция, читающая из входного потока очередной символ исходной программы и заносящая его в переменную с; void id or word (void); - функция, определяющая является слово в буфере buf идентификатором или служебным словом и формирующая лексему соответствующего класса; void is dlm (void); - если символ в буфере buf является разделителем, то формирует соответствующую лексему, иначе производится переход в состояние er.",лексемы,gramm,1
"результат: номер строки таблицы с информацией о лексеме; int putnum (); - запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum с информацией о константе-лексеме; void makelex (int k, int i); - формирование и вывод внутреннего представления лексемы; k - номер класса, i - номер в классе; void gc (void) - функция, читающая из входного потока очередной символ исходной программы и заносящая его в переменную с; void id or word (void); - функция, определяющая является слово в буфере buf идентификатором или служебным словом и формирующая лексему соответствующего класса; void is dlm (void); - если символ в буфере buf является разделителем, то формирует соответствующую лексему, иначе производится переход в состояние er.",лексему,gramm,1
"результат: номер строки таблицы с информацией о лексеме; int putnum (); - запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum с информацией о константе-лексеме; void makelex (int k, int i); - формирование и вывод внутреннего представления лексемы; k - номер класса, i - номер в классе; void gc (void) - функция, читающая из входного потока очередной символ исходной программы и заносящая его в переменную с; void id or word (void); - функция, определяющая является слово в буфере buf идентификатором или служебным словом и формирующая лексему соответствующего класса; void is dlm (void); - если символ в буфере buf является разделителем, то формирует соответствующую лексему, иначе производится переход в состояние er.",лексеме,gramm,1
диаграмма состояний для лексического анализатора приведена на следующей странице.,лексического анализатора,gramm,1
диаграмма состояний для лексического анализатора приведена на следующей странице.,диаграмма состояний,gramm,1
"32 буква,цифра gc(); makelex(2,n:=); makelex(2,n:); add();gc(); gc(); id or word(); makelex(3,putnum()); is dlm(); makelex(2,j) h : { цифра makelex (2, n ); gc(); gc(); d=c- 0 ; gc(); clear(); add(); clear(); add(); gc(); буква id = num цифра d=d 10+(c- 0 ); gc(); com } gc(); er ass fin dlm gc(); замечания: 1) символом nx в диаграмме (и в тексте программы) обозначен номер лексемы x в ее классе.",лексемы,gramm,1
"по нашей диаграмме знак ""!="" представлен двумя лексемами, хотя нужно сделать одну лексему, по аналогии с "":="".",лексему,gramm,1
соответствующие изменения надо сделать и в синтаксическом анализаторе.,синтаксическом анализаторе,gramm,1
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",лексемы,gramm,1
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",лексема,gramm,1
"\n""); else printf(""o.k.!!!\n""); } синтаксический и семантический анализ на этапе синтаксического анализа нужно установить, имеет ли цепочка лексем структуру, заданную синтаксисом языка, и зафиксировать эту структуру.",синтаксического анализа,gramm,1
"\n""); else printf(""o.k.!!!\n""); } синтаксический и семантический анализ на этапе синтаксического анализа нужно установить, имеет ли цепочка лексем структуру, заданную синтаксисом языка, и зафиксировать эту структуру.",семантический анализ,gramm,1
"\n""); else printf(""o.k.!!!\n""); } синтаксический и семантический анализ на этапе синтаксического анализа нужно установить, имеет ли цепочка лексем структуру, заданную синтаксисом языка, и зафиксировать эту структуру.",цепочка,gramm,1
"следовательно, снова надо решать задачу разбора: дана цепочка лексем, и надо определить, выводима ли она в грамматике, определяющей синтаксис языка.",грамматике,gramm,1
"следовательно, снова надо решать задачу разбора: дана цепочка лексем, и надо определить, выводима ли она в грамматике, определяющей синтаксис языка.",разбора,gramm,1
"следовательно, снова надо решать задачу разбора: дана цепочка лексем, и надо определить, выводима ли она в грамматике, определяющей синтаксис языка.",цепочка,gramm,1
"поэтому для описания синтаксиса языков программирования нужны более мощные грамматики, чем регулярные.",грамматики,gramm,1
"грамматики этого класса, с одной стороны, позволяют достаточно полно описать синтаксическую структуру реальных языков программирования; с другой стороны, для разных подклассов укс-грамматик существуют достаточно эффективные алгоритмы разбора.",грамматики,gramm,1
"грамматики этого класса, с одной стороны, позволяют достаточно полно описать синтаксическую структуру реальных языков программирования; с другой стороны, для разных подклассов укс-грамматик существуют достаточно эффективные алгоритмы разбора.",грамматик,gramm,1
"грамматики этого класса, с одной стороны, позволяют достаточно полно описать синтаксическую структуру реальных языков программирования; с другой стороны, для разных подклассов укс-грамматик существуют достаточно эффективные алгоритмы разбора.",разбора,gramm,1
"с теоретической точки зрения существует алгоритм, который по любой данной кс-грамматике и данной цепочке выясняет, принадлежит ли цепочка языку, порождаемому этой грамматикой.",цепочка языку,gramm,1
"с теоретической точки зрения существует алгоритм, который по любой данной кс-грамматике и данной цепочке выясняет, принадлежит ли цепочка языку, порождаемому этой грамматикой.",грамматикой,gramm,1
"с теоретической точки зрения существует алгоритм, который по любой данной кс-грамматике и данной цепочке выясняет, принадлежит ли цепочка языку, порождаемому этой грамматикой.",цепочке,gramm,1
"с теоретической точки зрения существует алгоритм, который по любой данной кс-грамматике и данной цепочке выясняет, принадлежит ли цепочка языку, порождаемому этой грамматикой.",цепочка,gramm,1
"но время работы такого алгоритма (синтаксического анализа с возвратами) экспоненциально зависит от длины цепочки, что с практической точки зрения совершенно неприемлемо.",синтаксического анализа,gramm,1
"но время работы такого алгоритма (синтаксического анализа с возвратами) экспоненциально зависит от длины цепочки, что с практической точки зрения совершенно неприемлемо.",цепочки,gramm,1
"существуют табличные методы анализа ([3]), применимые ко всему классу кс-грамматик и требующие для разбора цепочек длины n времени cn3 (алгоритм кока-янгера-касами) либо cn2 (алгоритм эрли).",цепочек,gramm,1
"существуют табличные методы анализа ([3]), применимые ко всему классу кс-грамматик и требующие для разбора цепочек длины n времени cn3 (алгоритм кока-янгера-касами) либо cn2 (алгоритм эрли).",кс-грамматик,gramm,1
"существуют табличные методы анализа ([3]), применимые ко всему классу кс-грамматик и требующие для разбора цепочек длины n времени cn3 (алгоритм кока-янгера-касами) либо cn2 (алгоритм эрли).",грамматик,gramm,1
"существуют табличные методы анализа ([3]), применимые ко всему классу кс-грамматик и требующие для разбора цепочек длины n времени cn3 (алгоритм кока-янгера-касами) либо cn2 (алгоритм эрли).",разбора,gramm,1
"их разумно применять только в том случае, если для интересующего нас языка не существует грамматики, по которой можно построить анализатор с линейной временной зависимостью.",грамматики,gramm,1
"алгоритмы анализа, расходующие на обработку входной цепочки линейное время, применимы только к некоторым подклассам кс-грамматик.",цепочки,gramm,1
"алгоритмы анализа, расходующие на обработку входной цепочки линейное время, применимы только к некоторым подклассам кс-грамматик.",кс-грамматик,gramm,1
"алгоритмы анализа, расходующие на обработку входной цепочки линейное время, применимы только к некоторым подклассам кс-грамматик.",грамматик,gramm,1
"метод рекурсивного спуска пример: пусть дана грамматика g =({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba и надо определить, принадлежит ли цепочка caba языку l(g).",рекурсивного спуска,gramm,1
"метод рекурсивного спуска пример: пусть дана грамматика g =({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba и надо определить, принадлежит ли цепочка caba языку l(g).",грамматика,gramm,1
"метод рекурсивного спуска пример: пусть дана грамматика g =({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba и надо определить, принадлежит ли цепочка caba языку l(g).",метод рекурсивного спуска,gramm,1
"метод рекурсивного спуска пример: пусть дана грамматика g =({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba и надо определить, принадлежит ли цепочка caba языку l(g).",цепочка,gramm,1
"построим вывод этой цепочки: s ab cab cab caba caba следовательно, цепочка принадлежит языку l(g).",цепочки,gramm,1
"построим вывод этой цепочки: s ab cab cab caba caba следовательно, цепочка принадлежит языку l(g).",цепочка,gramm,1
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",цепочки,gramm,1
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",дерева разбора,gramm,1
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",рс-метод,gramm,1
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",грамматики,gramm,1
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",разбора,gramm,1
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",рекурсивного спуска,gramm,1
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",метод рекурсивного спуска,gramm,1
"если такую подцепочку считать не удается, то процедура завершает свою работу вызовом процедуры обработки ошибки, которая выдает сообщение о том, что цепочка не принадлежит языку, и останавливает разбор.",разбор,gramm,1
"если такую подцепочку считать не удается, то процедура завершает свою работу вызовом процедуры обработки ошибки, которая выдает сообщение о том, что цепочка не принадлежит языку, и останавливает разбор.",цепочка,gramm,1
"при этом терминалы распознаются самой процедурой, а нетерминалы соответствуют вызовам процедур, носящих их имена.",терминалы,gramm,1
"пример: совокупность процедур рекурсивного спуска для грамматики g = ({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba будет такой: #include <stdio.h> int c; file fp;/ указатель на файл, в котором находится анализируе-мая цепочка / void a(); void b(); void error(); / функция обработки ошибок / void s() {a(); b(); 40 if (c != ' ') error(); } void a() {if (c=='a') c = fgetc(fp); else if (c == 'c') {c = fgetc(fp); a();} else error(); } void b() {if (c == 'b') {c = fgetc(fp); a();} else error(); } void error() {printf(""error !!!",процедур рекурсивного спуска,gramm,1
"пример: совокупность процедур рекурсивного спуска для грамматики g = ({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba будет такой: #include <stdio.h> int c; file fp;/ указатель на файл, в котором находится анализируе-мая цепочка / void a(); void b(); void error(); / функция обработки ошибок / void s() {a(); b(); 40 if (c != ' ') error(); } void a() {if (c=='a') c = fgetc(fp); else if (c == 'c') {c = fgetc(fp); a();} else error(); } void b() {if (c == 'b') {c = fgetc(fp); a();} else error(); } void error() {printf(""error !!!",рекурсивного спуска,gramm,1
"пример: совокупность процедур рекурсивного спуска для грамматики g = ({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba будет такой: #include <stdio.h> int c; file fp;/ указатель на файл, в котором находится анализируе-мая цепочка / void a(); void b(); void error(); / функция обработки ошибок / void s() {a(); b(); 40 if (c != ' ') error(); } void a() {if (c=='a') c = fgetc(fp); else if (c == 'c') {c = fgetc(fp); a();} else error(); } void b() {if (c == 'b') {c = fgetc(fp); a();} else error(); } void error() {printf(""error !!!",грамматики,gramm,1
"пример: совокупность процедур рекурсивного спуска для грамматики g = ({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba будет такой: #include <stdio.h> int c; file fp;/ указатель на файл, в котором находится анализируе-мая цепочка / void a(); void b(); void error(); / функция обработки ошибок / void s() {a(); b(); 40 if (c != ' ') error(); } void a() {if (c=='a') c = fgetc(fp); else if (c == 'c') {c = fgetc(fp); a();} else error(); } void b() {if (c == 'b') {c = fgetc(fp); a();} else error(); } void error() {printf(""error !!!",цепочка,gramm,1
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",метода рекурсивного спуска,gramm,1
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",рекурсивного спуска,gramm,1
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",метод рекурсивного спуска,gramm,1
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",грамматики,gramm,1
"если для нетерминала а правил вывода несколько, то они должны начинаться с терминалов, причем все эти терминалы должны быть различными.",терминалов,gramm,1
"если для нетерминала а правил вывода несколько, то они должны начинаться с терминалов, причем все эти терминалы должны быть различными.",терминалы,gramm,1
"ясно, что если правила вывода имеют такой вид, то рекурсивный спуск может быть реализован по выше изложенной схеме.",рекурсивный спуск,gramm,1
"естественно, возникает вопрос: если грамматика не удовлетворяет этим условиям, то существует ли эквивалентная кс-грамматика, для которой метод рекурсивного спуска применим?",рекурсивного спуска,gramm,1
"естественно, возникает вопрос: если грамматика не удовлетворяет этим условиям, то существует ли эквивалентная кс-грамматика, для которой метод рекурсивного спуска применим?",грамматика,gramm,1
"естественно, возникает вопрос: если грамматика не удовлетворяет этим условиям, то существует ли эквивалентная кс-грамматика, для которой метод рекурсивного спуска применим?",метод рекурсивного спуска,gramm,1
"попытаемся ослабить требования на вид правил грамматики: (1) при описании синтаксиса языков программирования часто встречаются правила, описывающие последовательность однотипных конструкций, отделенных друг от друга каким-либо знаком-разделителем (например, список идентификаторов при описании переменных, список параметров при вызове процедур и функций и т.п.).",грамматики,gramm,1
"общий вид этих правил: l a a,l ( либо в сокращенной форме l a {,a} ) 41 формально здесь не выполняются условия применимости метода рекурсивного спуска, т.к. две альтернативы начинаются одинаковыми терминальными символами.",метода рекурсивного спуска,gramm,1
"общий вид этих правил: l a a,l ( либо в сокращенной форме l a {,a} ) 41 формально здесь не выполняются условия применимости метода рекурсивного спуска, т.к. две альтернативы начинаются одинаковыми терминальными символами.",рекурсивного спуска,gramm,1
"общий вид этих правил: l a a,l ( либо в сокращенной форме l a {,a} ) 41 формально здесь не выполняются условия применимости метода рекурсивного спуска, т.к. две альтернативы начинаются одинаковыми терминальными символами.",терминальными символами,gramm,1
"действительно, в цепочке a,a,a,a,a из нетерминала l может выводиться и подцепочка a , и подцепочка a,a , и вся цепочка a,a,a,a,a. неясно, какую из них выбрать в качестве подцепочки, выводимой из l. если принять решение, что в таких случаях будем выбирать самую длинную подцепочку (что и требуется при разборе реальных языков), то разбор становится детерминированным.",разборе,gramm,1
"действительно, в цепочке a,a,a,a,a из нетерминала l может выводиться и подцепочка a , и подцепочка a,a , и вся цепочка a,a,a,a,a. неясно, какую из них выбрать в качестве подцепочки, выводимой из l. если принять решение, что в таких случаях будем выбирать самую длинную подцепочку (что и требуется при разборе реальных языков), то разбор становится детерминированным.",разбор,gramm,1
"действительно, в цепочке a,a,a,a,a из нетерминала l может выводиться и подцепочка a , и подцепочка a,a , и вся цепочка a,a,a,a,a. неясно, какую из них выбрать в качестве подцепочки, выводимой из l. если принять решение, что в таких случаях будем выбирать самую длинную подцепочку (что и требуется при разборе реальных языков), то разбор становится детерминированным.",цепочке,gramm,1
"действительно, в цепочке a,a,a,a,a из нетерминала l может выводиться и подцепочка a , и подцепочка a,a , и вся цепочка a,a,a,a,a. неясно, какую из них выбрать в качестве подцепочки, выводимой из l. если принять решение, что в таких случаях будем выбирать самую длинную подцепочку (что и требуется при разборе реальных языков), то разбор становится детерминированным.",цепочка,gramm,1
"тогда для метода рекурсивного спуска процедура l будет такой: void l() { if (c != 'a') error(); while ((c = fgetc(fp)) == ',') if ((c = fgetc(fp)) !",метода рекурсивного спуска,gramm,1
"тогда для метода рекурсивного спуска процедура l будет такой: void l() { if (c != 'a') error(); while ((c = fgetc(fp)) == ',') if ((c = fgetc(fp)) !",рекурсивного спуска,gramm,1
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",цепочки,gramm,1
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",грамматике,gramm,1
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",грамматики,gramm,1
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",цепочкой,gramm,1
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",сентенциальной форме,gramm,1
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",рс-методом,gramm,1
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",цепочка,gramm,1
"(2) если грамматика не удовлетворяет требованиям применимости метода рекурсивного спуска, то можно попытаться преобразовать ее, т.е. получить эквивалентную грамматику, пригодную для анализа этим методом.",метода рекурсивного спуска,gramm,1
"(2) если грамматика не удовлетворяет требованиям применимости метода рекурсивного спуска, то можно попытаться преобразовать ее, т.е. получить эквивалентную грамматику, пригодную для анализа этим методом.",грамматику,gramm,1
"(2) если грамматика не удовлетворяет требованиям применимости метода рекурсивного спуска, то можно попытаться преобразовать ее, т.е. получить эквивалентную грамматику, пригодную для анализа этим методом.",эквивалентную грамматику,gramm,1
"(2) если грамматика не удовлетворяет требованиям применимости метода рекурсивного спуска, то можно попытаться преобразовать ее, т.е. получить эквивалентную грамматику, пригодную для анализа этим методом.",рекурсивного спуска,gramm,1
"(2) если грамматика не удовлетворяет требованиям применимости метода рекурсивного спуска, то можно попытаться преобразовать ее, т.е. получить эквивалентную грамматику, пригодную для анализа этим методом.",грамматика,gramm,1
"a) если в грамматике есть нетерминалы, правила вывода которых леворекурсивны, т.е. имеют вид a a 1 ... a n 1 ... m, где i (vt vn)+, j (vt vn) , i = 1, 2, ..., n; j =1, 2 ,..., m, то непосредственно применять рс-метод нельзя.",грамматике,gramm,1
"a) если в грамматике есть нетерминалы, правила вывода которых леворекурсивны, т.е. имеют вид a a 1 ... a n 1 ... m, где i (vt vn)+, j (vt vn) , i = 1, 2, ..., n; j =1, 2 ,..., m, то непосредственно применять рс-метод нельзя.",рс-метод,gramm,1
"левую рекурсию всегда можно заменить правой: a 1a ... ma a 1a ... na будет получена грамматика, эквивалентная данной, т.к. из нетерминала a по-прежнему выводятся цепочки вида j { i}, где i = 1,2,...,n; j = 1,2,...,m.",цепочки,gramm,1
"левую рекурсию всегда можно заменить правой: a 1a ... ma a 1a ... na будет получена грамматика, эквивалентная данной, т.к. из нетерминала a по-прежнему выводятся цепочки вида j { i}, где i = 1,2,...,n; j = 1,2,...,m.",грамматика,gramm,1
"42 b) если в грамматике есть нетерминал, у которого несколько правил вывода начинаются одинаковыми терминальными символами, т.е. имеют вид a a 1 a 2 ... a n 1 ... m, где a vt; i, j (vt vn) , то непосредственно применять рс-метод нельзя.",нетерминал,gramm,1
"42 b) если в грамматике есть нетерминал, у которого несколько правил вывода начинаются одинаковыми терминальными символами, т.е. имеют вид a a 1 a 2 ... a n 1 ... m, где a vt; i, j (vt vn) , то непосредственно применять рс-метод нельзя.",грамматике,gramm,1
"42 b) если в грамматике есть нетерминал, у которого несколько правил вывода начинаются одинаковыми терминальными символами, т.е. имеют вид a a 1 a 2 ... a n 1 ... m, где a vt; i, j (vt vn) , то непосредственно применять рс-метод нельзя.",рс-метод,gramm,1
"42 b) если в грамматике есть нетерминал, у которого несколько правил вывода начинаются одинаковыми терминальными символами, т.е. имеют вид a a 1 a 2 ... a n 1 ... m, где a vt; i, j (vt vn) , то непосредственно применять рс-метод нельзя.",терминальными символами,gramm,1
"можно преобразовать правила вывода данного нетерминала, объединив правила с общими началами в одно правило: a aa 1 ... m a 1 2 ... n будет получена грамматика, эквивалентная данной.",грамматика,gramm,1
"c) если в грамматике есть нетерминал, у которого несколько правил вывода, и среди них есть правила, начинающиеся нетерминальными символами, т.е. имеют вид a b1 1 ...",нетерминал,gramm,1
"c) если в грамматике есть нетерминал, у которого несколько правил вывода, и среди них есть правила, начинающиеся нетерминальными символами, т.е. имеют вид a b1 1 ...",грамматике,gramm,1
"c) если в грамматике есть нетерминал, у которого несколько правил вывода, и среди них есть правила, начинающиеся нетерминальными символами, т.е. имеют вид a b1 1 ...",нетерминальными символами,gramm,1
"bn n1 ... np, где bi vn; aj vt; i, j, ij (vt vn) , то можно заменить вхождения нетерминалов bi их правилами вывода в надежде, что правило нетерминала a станет удовлетворять требованиям метода рекурсивного спуска: a 11 1 ...",метода рекурсивного спуска,gramm,1
"bn n1 ... np, где bi vn; aj vt; i, j, ij (vt vn) , то можно заменить вхождения нетерминалов bi их правилами вывода в надежде, что правило нетерминала a станет удовлетворять требованиям метода рекурсивного спуска: a 11 1 ...",рекурсивного спуска,gramm,1
"если допустить в правилах вывода грамматики пустую альтернативу, т.е. правила вида a a1 1 ... an n , то метод рекурсивного спуска может оказаться неприменимым (несмотря на то, что в остальном достаточные условия применимости выполняются).",рекурсивного спуска,gramm,1
"если допустить в правилах вывода грамматики пустую альтернативу, т.е. правила вида a a1 1 ... an n , то метод рекурсивного спуска может оказаться неприменимым (несмотря на то, что в остальном достаточные условия применимости выполняются).",метод рекурсивного спуска,gramm,1
"если допустить в правилах вывода грамматики пустую альтернативу, т.е. правила вида a a1 1 ... an n , то метод рекурсивного спуска может оказаться неприменимым (несмотря на то, что в остальном достаточные условия применимости выполняются).",пустую альтернативу,gramm,1
"если допустить в правилах вывода грамматики пустую альтернативу, т.е. правила вида a a1 1 ... an n , то метод рекурсивного спуска может оказаться неприменимым (несмотря на то, что в остальном достаточные условия применимости выполняются).",грамматики,gramm,1
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",грамматики,gramm,1
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",грамматикой,gramm,1
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",цепочки,gramm,1
"43 проблема заключается в том, что подцепочка, следующая за цепочкой, выводимой из a, начинается таким же символом, как и цепочка, выводимая из а.",цепочкой,gramm,1
"43 проблема заключается в том, что подцепочка, следующая за цепочкой, выводимой из a, начинается таким же символом, как и цепочка, выводимая из а.",цепочка,gramm,1
"однако в грамматике g = ({a,b,с}, {s,a}, p, s), где p: s baс a aa нет проблем с применением метода рекурсивного спуска.",метода рекурсивного спуска,gramm,1
"однако в грамматике g = ({a,b,с}, {s,a}, p, s), где p: s baс a aa нет проблем с применением метода рекурсивного спуска.",рекурсивного спуска,gramm,1
"однако в грамматике g = ({a,b,с}, {s,a}, p, s), где p: s baс a aa нет проблем с применением метода рекурсивного спуска.",грамматике,gramm,1
"выпишем условие, при котором -правило вывода делает неприменимым рс-метод.",рс-метод,gramm,1
"определение: множество first(a) - это множество терминальных символов, которыми начинаются цепочки, выводимые из а в грамматике g = (vt, vn, p, s), т.е. first(a) = { a vt a a , a vn, (vt vn) }.",терминальных символов,gramm,1
"определение: множество first(a) - это множество терминальных символов, которыми начинаются цепочки, выводимые из а в грамматике g = (vt, vn, p, s), т.е. first(a) = { a vt a a , a vn, (vt vn) }.",грамматике,gramm,1
"определение: множество first(a) - это множество терминальных символов, которыми начинаются цепочки, выводимые из а в грамматике g = (vt, vn, p, s), т.е. first(a) = { a vt a a , a vn, (vt vn) }.",цепочки,gramm,1
"определение: множество follow(a) -это множество терминальных символов, которые следуют за цепочками, выводимыми из а в грамматике g = (vt, vn, p, s), т.е. follow(a) = { a vt s a , a , a vn, , , (vt vn) }.",терминальных символов,gramm,1
"определение: множество follow(a) -это множество терминальных символов, которые следуют за цепочками, выводимыми из а в грамматике g = (vt, vn, p, s), т.е. follow(a) = { a vt s a , a , a vn, , , (vt vn) }.",цепочками,gramm,1
"определение: множество follow(a) -это множество терминальных символов, которые следуют за цепочками, выводимыми из а в грамматике g = (vt, vn, p, s), т.е. follow(a) = { a vt s a , a , a vn, , , (vt vn) }.",грамматике,gramm,1
"тогда, если first(a) follow(a) , то метод рекурсивного спуска неприменим к данной грамматике.",рекурсивного спуска,gramm,1
"тогда, если first(a) follow(a) , то метод рекурсивного спуска неприменим к данной грамматике.",метод рекурсивного спуска,gramm,1
"тогда, если first(a) follow(a) , то метод рекурсивного спуска неприменим к данной грамматике.",грамматике,gramm,1
"если a 1a ... na 1 ... m b a и first(a) follow(a) (из-за вхождения а в правила вывода для в), то можно попытаться преобразовать такую грамматику: b a a 1a ... na 1 ... m a 1a ... na 1 ...",грамматику,gramm,1
"m полученная грамматика будет эквивалентна исходной, т.к. из b по-прежнему выводятся цепочки вида { i} j либо { i} .",цепочки,gramm,1
"m полученная грамматика будет эквивалентна исходной, т.к. из b по-прежнему выводятся цепочки вида { i} j либо { i} .",грамматика,gramm,1
"однако правило вывода для нетерминального символа a будет иметь альтернативы, начинающиеся одинаковыми терминальными символами, следовательно, потребуются дальнейшие преобразования, и успех не гарантирован.",нетерминального символа,gramm,1
"однако правило вывода для нетерминального символа a будет иметь альтернативы, начинающиеся одинаковыми терминальными символами, следовательно, потребуются дальнейшие преобразования, и успех не гарантирован.",терминальными символами,gramm,1
метод рекурсивного спуска применим к достаточно узкому подклассу кс-грамматик.,рекурсивного спуска,gramm,1
метод рекурсивного спуска применим к достаточно узкому подклассу кс-грамматик.,кс-грамматик,gramm,1
метод рекурсивного спуска применим к достаточно узкому подклассу кс-грамматик.,метод рекурсивного спуска,gramm,1
метод рекурсивного спуска применим к достаточно узкому подклассу кс-грамматик.,грамматик,gramm,1
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",цепочки,gramm,1
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",разбора,gramm,1
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",рекурсивного спуска,gramm,1
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",грамматик,gramm,1
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",методом рекурсивного спуска,gramm,1
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",цепочка,gramm,1
"к таким грамматикам относятся ll(k)- 44 грамматики, lr(k)-грамматики, грамматики предшествования и некоторые другие (см., например, [2], [3]).",грамматики,gramm,1
"к таким грамматикам относятся ll(k)- 44 грамматики, lr(k)-грамматики, грамматики предшествования и некоторые другие (см., например, [2], [3]).",грамматикам,gramm,1
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",лексему,gramm,1
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",лексического анализатора,gramm,1
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",синтаксический анализатор,gramm,1
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",синтаксического анализатора,gramm,1
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",лексема,gramm,1
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",м-языка,gramm,1
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",лексический анализаторы,gramm,1
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",лексему,gramm,1
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",лексическим анализатором,gramm,1
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",синтаксического анализаторов,gramm,1
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",лексемы,gramm,1
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",лексический анализатор,gramm,1
"тогда метод рекурсивного спуска реализуется с помощью следующих процедур, создаваемых для каждого нетерминала грамматики: для p program d1 ; b void p (void){ if (eq (""program"")) curr lex = getlex(); else error(); d1(); if (eq ("";"")) curr lex = getlex(); else error(); b(); if (!",рекурсивного спуска,gramm,1
"тогда метод рекурсивного спуска реализуется с помощью следующих процедур, создаваемых для каждого нетерминала грамматики: для p program d1 ; b void p (void){ if (eq (""program"")) curr lex = getlex(); else error(); d1(); if (eq ("";"")) curr lex = getlex(); else error(); b(); if (!",метод рекурсивного спуска,gramm,1
"тогда метод рекурсивного спуска реализуется с помощью следующих процедур, создаваемых для каждого нетерминала грамматики: для p program d1 ; b void p (void){ if (eq (""program"")) curr lex = getlex(); else error(); d1(); if (eq ("";"")) curr lex = getlex(); else error(); b(); if (!",грамматики,gramm,1
"eq ("":"")) error(); else {curr lex = getlex(); if (eq (""int"") eq (""bool"")) curr lex = getlex(); else error();} } } для e1 t {[ + - or ] t} void e1 (void){ t(); while (eq (""+"") eq (""-"") eq (""or"")) {curr lex = getlex(); t();} } для остальных нетерминалов грамматики модельного языка процедуры рекурсивного спуска пишутся аналогично.",рекурсивного спуска,gramm,1
"eq ("":"")) error(); else {curr lex = getlex(); if (eq (""int"") eq (""bool"")) curr lex = getlex(); else error();} } } для e1 t {[ + - or ] t} void e1 (void){ t(); while (eq (""+"") eq (""-"") eq (""or"")) {curr lex = getlex(); t();} } для остальных нетерминалов грамматики модельного языка процедуры рекурсивного спуска пишутся аналогично.",процедуры рекурсивного спуска,gramm,1
"eq ("":"")) error(); else {curr lex = getlex(); if (eq (""int"") eq (""bool"")) curr lex = getlex(); else error();} } } для e1 t {[ + - or ] t} void e1 (void){ t(); while (eq (""+"") eq (""-"") eq (""or"")) {curr lex = getlex(); t();} } для остальных нетерминалов грамматики модельного языка процедуры рекурсивного спуска пишутся аналогично.",модельного языка,gramm,1
"eq ("":"")) error(); else {curr lex = getlex(); if (eq (""int"") eq (""bool"")) curr lex = getlex(); else error();} } } для e1 t {[ + - or ] t} void e1 (void){ t(); while (eq (""+"") eq (""-"") eq (""or"")) {curr lex = getlex(); t();} } для остальных нетерминалов грамматики модельного языка процедуры рекурсивного спуска пишутся аналогично.",грамматики,gramm,1
"""запуск"" синтаксического анализатора: ... curr lex = getlex(); p(); ...",синтаксического анализатора,gramm,1
"о семантическом анализе контекстно-свободные грамматики, с помощью которых описывают синтаксис языков программирования, не позволяют задавать контекстные условия, имеющиеся в любом языке.",грамматики,gramm,1
"о семантическом анализе контекстно-свободные грамматики, с помощью которых описывают синтаксис языков программирования, не позволяют задавать контекстные условия, имеющиеся в любом языке.",семантическом анализе,gramm,1
"о семантическом анализе контекстно-свободные грамматики, с помощью которых описывают синтаксис языков программирования, не позволяют задавать контекстные условия, имеющиеся в любом языке.",контекстно-свободные грамматики,gramm,1
"о семантическом анализе контекстно-свободные грамматики, с помощью которых описывают синтаксис языков программирования, не позволяют задавать контекстные условия, имеющиеся в любом языке.",контекстные условия,gramm,1
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",семантическим анализом,gramm,1
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",контекстных условий,gramm,1
"его можно выполнять сразу после синтаксического анализа, некоторые требования можно контролировать во время генерации кода (например, ограничения на типы операндов в выражении), а можно совместить с синтаксическим анализом.",синтаксического анализа,gramm,1
"его можно выполнять сразу после синтаксического анализа, некоторые требования можно контролировать во время генерации кода (например, ограничения на типы операндов в выражении), а можно совместить с синтаксическим анализом.",синтаксическим анализом,gramm,1
"мы выберем последний вариант: как только синтаксический анализатор распознает конструкцию, на компоненты которой наложены некоторые ограничения, проверяется их выполнение.",синтаксический анализатор,gramm,1
"это означает, что на этапе синтаксического анализа придется выполнять некоторые дополнительные действия, осуществляющие семантический контроль.",синтаксического анализа,gramm,1
"если для синтаксического анализа используется метод рекурсивного спуска, то в тела процедур рс-метода необходимо вставить вызовы дополнительных ""семантических"" процедур (семантические действия).",синтаксического анализа,gramm,1
"если для синтаксического анализа используется метод рекурсивного спуска, то в тела процедур рс-метода необходимо вставить вызовы дополнительных ""семантических"" процедур (семантические действия).",рекурсивного спуска,gramm,1
"если для синтаксического анализа используется метод рекурсивного спуска, то в тела процедур рс-метода необходимо вставить вызовы дополнительных ""семантических"" процедур (семантические действия).",рс-метода,gramm,1
"если для синтаксического анализа используется метод рекурсивного спуска, то в тела процедур рс-метода необходимо вставить вызовы дополнительных ""семантических"" процедур (семантические действия).",метод рекурсивного спуска,gramm,1
"причем, как показывает практика, удобнее вставить их сначала в синтаксические правила, а потом по этим расширенным правилам строить процедуры рс-метода.",рс-метода,gramm,1
"чтобы отличать вызовы семантических процедур от других символов грамматики, будем заключать их в угловые скобки.",грамматики,gramm,1
"замечание: фактически, мы расширили понятие контекстно- свободной грамматики, добавив в ее правила вывода символы- действия.",грамматики,gramm,1
"например, пусть в грамматике есть правило a a<d1>b<d1;d2> bc<d3> , здесь a,b,c vn; a,b vt; <di> означает вызов семантической процедуры di, i = 1, 2, 3.",грамматике,gramm,1
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",цепочки,gramm,1
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",метода рекурсивного спуска,gramm,1
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",грамматики,gramm,1
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",грамматику,gramm,1
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",рекурсивного спуска,gramm,1
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",цепочки языка,gramm,1
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",синтаксический анализ,gramm,1
"этого можно добиться, пытаясь чисто синтаксическими средствами описать цепочки, обладающие этим свойством.",цепочки,gramm,1
"но гораздо проще с помощью синтаксических правил описать произвольные цепочки из 0 и 1, а потом вставить действия для отбора цепочек с равным количеством 0 и 1: s <k0 = 0; k1 = 0;> a a 0 <k0 = k0+1> a 1 <k1 = k1+1> a 0 <k0 = k0+1; check()> 1 <k1 = k1+1; check()>, где void check() 47 { if (k0 != k1) { printf(""error !!!"")",цепочки,gramm,1
"но гораздо проще с помощью синтаксических правил описать произвольные цепочки из 0 и 1, а потом вставить действия для отбора цепочек с равным количеством 0 и 1: s <k0 = 0; k1 = 0;> a a 0 <k0 = k0+1> a 1 <k1 = k1+1> a 0 <k0 = k0+1; check()> 1 <k1 = k1+1; check()>, где void check() 47 { if (k0 != k1) { printf(""error !!!"")",цепочек,gramm,1
"\n"");exit(0);} } теперь по этой грамматике легко построить анализатор, распознающий цепочки с нужными свойствами.",цепочки,gramm,1
"\n"");exit(0);} } теперь по этой грамматике легко построить анализатор, распознающий цепочки с нужными свойствами.",грамматике,gramm,1
"семантический анализатор для м-языка контекстные условия, выполнение которых нам надо контролировать в программах на м-языке, таковы: 1.",контекстные условия,gramm,1
"семантический анализатор для м-языка контекстные условия, выполнение которых нам надо контролировать в программах на м-языке, таковы: 1.",м-языка,gramm,1
"семантический анализатор для м-языка контекстные условия, выполнение которых нам надо контролировать в программах на м-языке, таковы: 1.",м-языке,gramm,1
проверку контекстных условий совместим с синтаксическим анализом.,контекстных условий,gramm,1
проверку контекстных условий совместим с синтаксическим анализом.,синтаксическим анализом,gramm,1
"для этого в синтаксические правила вставим вызовы процедур, осуществляющих необходимый контроль, а затем перенесем их в процедуры рекурсивного спуска.",рекурсивного спуска,gramm,1
"для этого в синтаксические правила вставим вызовы процедур, осуществляющих необходимый контроль, а затем перенесем их в процедуры рекурсивного спуска.",процедуры рекурсивного спуска,gramm,1
"эта информация становится известной в тот момент, когда синтаксический анализатор обрабатывает описания.",синтаксический анализатор,gramm,1
"лексический анализатор запомнил в таблице идентификаторов tid все идентификаторы-лексемы, которые были им обнаружены в тексте исходной программы.",лексический анализатор,gramm,1
"1-""да"", 0-""нет"" / char type; / тип переменной / ... }; тогда таблица идентификаторов tid - это массив структур #define maxsize tid 1000 struct record tid [maxsize tid]; 48 причем i-ая строка соответствует идентификатору-лексеме вида (4,i).",лексеме,gramm,1
лексический анализатор заполнил поле name; значения полей declare и type будем заполнять на этапе семантического анализа.,семантического анализа,gramm,1
лексический анализатор заполнил поле name; значения полей declare и type будем заполнять на этапе семантического анализа.,лексический анализатор,gramm,1
"для этого нам потребуется следующая функция: void decid (int i, char t) - в i-той строке таблицы tid контролирует и заполняет поле declare и, если лексема (4,i) впервые встретилась в разделе описаний, заполняет поле type: void decid (int i, char t) {if (tid [i].declare) error(); / повторное описание / else {tid [i].declare = 1; / описан ! / strcpy (tid [i].type, t);} / тип t ! / } раздел описаний имеет вид d i {,i}: [int bool], т.е. имени типа (int или bool) предшествует список идентификаторов.",лексема,gramm,1
"тогда функция void dec (char t) {int i; while ((i = ipop()) != -1) decid(i,t); } считывает из стека номера строк tid и заносит в них информацию о наличии описания и о типе t. с учетом этих функций правило вывода с действиями для обработки описаний будет таким: d < ipush (-1) > i < ipush (curr lex.value) > {, i < ipush (curr lex.value) >}: [ int < dec (""int"") > bool < dec (""bool"") > ] контроль контекстных условий в выражении пусть есть функция char gettype (char op, char t1, char t2), которая проверяет допустимость сочетания операндов типа t1 (первый операнд) и типа t2 (второй операнд) в операции op; если типы совместимы, то выдает тип результата этой операции; иначе - строку ""no"".",контекстных условий,gramm,1
"типы операндов и обозначение операции будем хранить в стеке; для этого нам нужны функции для работы со стеком строк: 49 void spush (char s); / значение s - в стек / char spop (void); / из стека - строку / если в выражении встречается лексема-целое число или логические константы true или false, то соответствующий тип сразу заносим в стек с помощью spush(""int"") или spush(""bool"").",лексема,gramm,1
"если операнд - лексема-переменная, то необходимо проверить, описана ли она; если описана, то ее тип надо занести в стек.",лексема,gramm,1
"эти действия можно выполнить с помощью функции checkid: void checkid (void) {int i; i = curr lex.value; if (tid [i].declare) / описан? / spush (tid [i].type); / тип - в стек / else error(); / описание отсутствует / } тогда для контроля контекстных условий каждой тройки - ""операнд-операция-операнд"" будем использовать функцию checkop: void checkop (void) {char op; char t1;char t2; char res; t2 = spop(); / из стека - тип второго операнда / op = spop(); / из стека - обозначение операции / t1 = spop(); / из стека - тип первого операнда / res = gettype (op,t1,t2); / допустимо ? / if (strcmp (res, ""no"")) spush (res); / да! / else error(); / нет! / } для контроля за типом операнда одноместной операции not будем использовать функцию checknot: void checknot (void) { if (strcmp (spop (), ""bool"")) error(); else spush (""bool"");} теперь главный вопрос: когда вызывать эти функции?",контекстных условий,gramm,1
"в грамматике модельного языка задано старшинство операций: наивысший приоритет имеет операция отрицания, затем в порядке убывания приоритета - группа операций умножения ( , /, and), группа операций сложения (+,-,or), операции отношения.",модельного языка,gramm,1
"в грамматике модельного языка задано старшинство операций: наивысший приоритет имеет операция отрицания, затем в порядке убывания приоритета - группа операций умножения ( , /, and), группа операций сложения (+,-,or), операции отношения.",грамматике,gramm,1
e e1 e1 [ = < > ] e1 e1 t {[ + - or ] t} t f {[ / and ] f} f i n [ true false ] not f (e) 50 именно это свойство грамматики позволит провести синтаксически-управляемый контроль контекстных условий.,грамматики,gramm,1
e e1 e1 [ = < > ] e1 e1 t {[ + - or ] t} t f {[ / and ] f} f i n [ true false ] not f (e) 50 именно это свойство грамматики позволит провести синтаксически-управляемый контроль контекстных условий.,контекстных условий,gramm,1
"замечание: сравните грамматики, описывающие выражения, состоящие из символов +, , (, ), i: g1: e e+e e e (e) i g4: e t e+t g2: e e+t e t t t f t f t i (e) f i (e) g3: e t+e t e t g5: e t t+e t i (e) t f f t f i (e) оцените, насколько они удобны для трансляции выражений.",грамматики,gramm,1
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",лексемы,gramm,1
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",контекстных условий,gramm,1
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",модельного языка,gramm,1
контроль контекстных условий в операторах s i := e if e then s else e while e do s b read (i) write (e) 1) оператор присваивания i := e контекстное условие: в операторе присваивания типы переменной i и выражения e должны совпадать.,контекстных условий,gramm,1
контроль контекстных условий в операторах s i := e if e then s else e while e do s b read (i) write (e) 1) оператор присваивания i := e контекстное условие: в операторе присваивания типы переменной i и выражения e должны совпадать.,контекстное условие,gramm,1
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); если при анализе идентификатора i проверить, описан ли он, и занести его тип в тот же стек ( для этого можно использовать функцию checkid() ), то достаточно будет в нужный момент считать из стека два элемента и сравнить их: void eqtype (void) { if (strcmp (spop (), spop ())) error();} следовательно, правило для оператора присваивания: i <checkid()> := e <eqtype()> 51 2) условный оператор и оператор цикла if e then s else s while e do s контекстные условия: в условном операторе и в операторе цикла в качестве условия возможны только логические выражения.",контекстных условий,gramm,1
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); если при анализе идентификатора i проверить, описан ли он, и занести его тип в тот же стек ( для этого можно использовать функцию checkid() ), то достаточно будет в нужный момент считать из стека два элемента и сравнить их: void eqtype (void) { if (strcmp (spop (), spop ())) error();} следовательно, правило для оператора присваивания: i <checkid()> := e <eqtype()> 51 2) условный оператор и оператор цикла if e then s else s while e do s контекстные условия: в условном операторе и в операторе цикла в качестве условия возможны только логические выражения.",контекстные условия,gramm,1
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); следовательно, достаточно извлечь его из стека и проверить: void eqbool (void) {if (strcmp (spop(), ""bool"")) error();} тогда правила для условного оператора и оператора цикла будут такими: if e <eqbool()> then s else s while e <eqbool()> do s в итоге получаем процедуры для синтаксического анализа методом рекурсивного спуска с синтаксически-управляемым контролем контекстных условий, которые легко написать по правилам грамматики с действиями.",синтаксического анализа,gramm,1
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); следовательно, достаточно извлечь его из стека и проверить: void eqbool (void) {if (strcmp (spop(), ""bool"")) error();} тогда правила для условного оператора и оператора цикла будут такими: if e <eqbool()> then s else s while e <eqbool()> do s в итоге получаем процедуры для синтаксического анализа методом рекурсивного спуска с синтаксически-управляемым контролем контекстных условий, которые легко написать по правилам грамматики с действиями.",грамматики,gramm,1
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); следовательно, достаточно извлечь его из стека и проверить: void eqbool (void) {if (strcmp (spop(), ""bool"")) error();} тогда правила для условного оператора и оператора цикла будут такими: if e <eqbool()> then s else s while e <eqbool()> do s в итоге получаем процедуры для синтаксического анализа методом рекурсивного спуска с синтаксически-управляемым контролем контекстных условий, которые легко написать по правилам грамматики с действиями.",рекурсивного спуска,gramm,1
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); следовательно, достаточно извлечь его из стека и проверить: void eqbool (void) {if (strcmp (spop(), ""bool"")) error();} тогда правила для условного оператора и оператора цикла будут такими: if e <eqbool()> then s else s while e <eqbool()> do s в итоге получаем процедуры для синтаксического анализа методом рекурсивного спуска с синтаксически-управляемым контролем контекстных условий, которые легко написать по правилам грамматики с действиями.",методом рекурсивного спуска,gramm,1
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); следовательно, достаточно извлечь его из стека и проверить: void eqbool (void) {if (strcmp (spop(), ""bool"")) error();} тогда правила для условного оператора и оператора цикла будут такими: if e <eqbool()> then s else s while e <eqbool()> do s в итоге получаем процедуры для синтаксического анализа методом рекурсивного спуска с синтаксически-управляемым контролем контекстных условий, которые легко написать по правилам грамматики с действиями.",контекстных условий,gramm,1
"в качестве примера приведем функцию для нетерминала d (раздел описаний): #include <string.h> #define maxsize tid 1000 #define maxsize td 50 char td[maxsize td]; struct record {char name; int declare; char type; / ... / }; struct record tid [maxsize tid]; / описание функций error(), getlex(), id(), eq(char ), типа struct lex и переменной curr lex - в алгоритме рекурсивного спуска для м-языка / void error(void); struct lex {int class; int value;}; struct lex curr lex; struct lex getlex (void); int id (void); int eq (char s); void ipush (int i); int ipop (void); void decid (int i, char t) {if (tid [i].declare) error(); else {tid [i].declare = 1; strcpy (tid [i].type, t);} } void dec (char t) {int i; while ((i = ipop()) !",рекурсивного спуска,gramm,1
"в качестве примера приведем функцию для нетерминала d (раздел описаний): #include <string.h> #define maxsize tid 1000 #define maxsize td 50 char td[maxsize td]; struct record {char name; int declare; char type; / ... / }; struct record tid [maxsize tid]; / описание функций error(), getlex(), id(), eq(char ), типа struct lex и переменной curr lex - в алгоритме рекурсивного спуска для м-языка / void error(void); struct lex {int class; int value;}; struct lex curr lex; struct lex getlex (void); int id (void); int eq (char s); void ipush (int i); int ipop (void); void decid (int i, char t) {if (tid [i].declare) error(); else {tid [i].declare = 1; strcpy (tid [i].type, t);} } void dec (char t) {int i; while ((i = ipop()) !",м-языка,gramm,1
"в качестве примера приведем функцию для нетерминала d (раздел описаний): #include <string.h> #define maxsize tid 1000 #define maxsize td 50 char td[maxsize td]; struct record {char name; int declare; char type; / ... / }; struct record tid [maxsize tid]; / описание функций error(), getlex(), id(), eq(char ), типа struct lex и переменной curr lex - в алгоритме рекурсивного спуска для м-языка / void error(void); struct lex {int class; int value;}; struct lex curr lex; struct lex getlex (void); int id (void); int eq (char s); void ipush (int i); int ipop (void); void decid (int i, char t) {if (tid [i].declare) error(); else {tid [i].declare = 1; strcpy (tid [i].type, t);} } void dec (char t) {int i; while ((i = ipop()) !",алгоритме рекурсивного спуска,gramm,1
"eq ("":"")) error(); else {curr lex = getlex (); if (eq (""int"")) {curr lex = getlex (); dec (""int"");} else if (eq (""bool"")) {curr lex = getlex(); dec (""bool"");} else error(); } } } генерация внутреннего представления программ результатом работы синтаксического анализатора должно быть некоторое внутреннее представление исходной цепочки лексем, которое отражает ее синтаксическую структуру.",цепочки,gramm,1
"eq ("":"")) error(); else {curr lex = getlex (); if (eq (""int"")) {curr lex = getlex (); dec (""int"");} else if (eq (""bool"")) {curr lex = getlex(); dec (""bool"");} else error(); } } } генерация внутреннего представления программ результатом работы синтаксического анализатора должно быть некоторое внутреннее представление исходной цепочки лексем, которое отражает ее синтаксическую структуру.",синтаксического анализатора,gramm,1
язык внутреннего представления программы основные свойства языка внутреннего представления программ: a) он позволяет фиксировать синтаксическую структуру исходной программы; b) текст на нем можно автоматически генерировать во время синтаксического анализа; c) его конструкции должны относительно просто транслироваться в объектный код либо достаточно эффективно интерпретироваться.,синтаксического анализа,gramm,1
"многоадресный код с неявно именуемыми результатами e) связные списочные структуры, представляющие синтаксическое дерево.",синтаксическое дерево,gramm,1
в основе каждого из этих способов лежит некоторый метод представления синтаксического дерева.,синтаксического дерева,gramm,1
"замечание: чаще всего синтаксическим деревом называют дерево вывода исходной цепочки, в котором удалены вершины, соответствующие цепным правилам вида a b, где a, b vn.",цепочки,gramm,1
"замечание: чаще всего синтаксическим деревом называют дерево вывода исходной цепочки, в котором удалены вершины, соответствующие цепным правилам вида a b, где a, b vn.",дерево вывода,gramm,1
"замечание: чаще всего синтаксическим деревом называют дерево вывода исходной цепочки, в котором удалены вершины, соответствующие цепным правилам вида a b, где a, b vn.",синтаксическим деревом,gramm,1
выберем в качестве языка для представления промежуточной программы постфиксную запись (ее часто называют полиз - польская инверсная запись).,полиз,gramm,1
выберем в качестве языка для представления промежуточной программы постфиксную запись (ее часто называют полиз - польская инверсная запись).,польская инверсная запись,gramm,1
"более формально постфиксную запись выражений можно определить таким образом: (1)если е является единственным операндом, то полиз выражения е - это этот операнд; (2)полизом выражения е1 е2, где - знак бинарной операции, е1 и е2 операнды для , является запись e1 e2 , где e1 и e2 - полиз выражений е1 и е2 соответственно; (3)полизом выражения e, где - знак унарной операции, а е - операнд , является запись e , где e - полиз выражения е; (4)полизом выражения (е) является полиз выражения е.",полиз,gramm,1
"более формально постфиксную запись выражений можно определить таким образом: (1)если е является единственным операндом, то полиз выражения е - это этот операнд; (2)полизом выражения е1 е2, где - знак бинарной операции, е1 и е2 операнды для , является запись e1 e2 , где e1 и e2 - полиз выражений е1 и е2 соответственно; (3)полизом выражения e, где - знак унарной операции, а е - операнд , является запись e , где e - полиз выражения е; (4)полизом выражения (е) является полиз выражения е.",полиз выражения,gramm,1
"более формально постфиксную запись выражений можно определить таким образом: (1)если е является единственным операндом, то полиз выражения е - это этот операнд; (2)полизом выражения е1 е2, где - знак бинарной операции, е1 и е2 операнды для , является запись e1 e2 , где e1 и e2 - полиз выражений е1 и е2 соответственно; (3)полизом выражения e, где - знак унарной операции, а е - операнд , является запись e , где e - полиз выражения е; (4)полизом выражения (е) является полиз выражения е.",полиз выражений,gramm,1
теперь необходимо разработать полиз для операторов входного языка.,полиз,gramm,1
"пусть полиз оператора, помеченного меткой l, начинается с номера p, тогда оператор перехода goto l в полизе можно записать как p !",полиз,gramm,1
"f где p - номер элемента, с которого начинается полиз оператора, помеченного меткой l. семантика условного оператора if b then s1 else s2 с использованием введенной операции может быть описана так: if (not b) then goto l2; s1; goto l3; l2: s2; l3: ... тогда полиз условного оператора будет таким: b p2 !f s1 p3 ! s2 ... , 59 где pi - номер элемента, с которого начинается полиз оператора, помеченного меткой li, i = 2,3.",полиз,gramm,1
тогда полиз оператора цикла while будет таким: b p1 !f s p0 ! ...,полиз,gramm,1
", где pi - номер элемента, с которого начинается полиз оператора, помеченного меткой li, i = 0,1.",полиз,gramm,1
операторы ввода и вывода м-языка являются одноместными операциями.,м-языка,gramm,1
"синтаксически управляемый перевод на практике синтаксический, семантический анализ и генерация внутреннего представления программы часто осуществляются одновременно.",семантический анализ,gramm,1
в основе синтаксически управляемого перевода лежит уже известная нам грамматика с действиями (см. раздел о контроле контекстных условий).,грамматика,gramm,1
в основе синтаксически управляемого перевода лежит уже известная нам грамматика с действиями (см. раздел о контроле контекстных условий).,контекстных условий,gramm,1
"теперь, параллельно с анализом исходной цепочки лексем, будем выполнять действия по генерации внутреннего представления программы.",цепочки,gramm,1
для этого дополним грамматику вызовами соответствующих процедур генерации.,грамматику,gramm,1
"содержательный пример - генерация внутреннего представления программы для м-языка, приведен ниже, а здесь в качестве иллюстрации рассмотрим более простой пример.",м-языка,gramm,1
"60 пусть есть грамматика, описывающая простейшее арифметическое выражение: e t {+t} t f { f} f a b (e) тогда грамматика с действиями по переводу этого выражения в полиз будет такой: e t {+t <putchar('+')>} t f { f <putchar(' ')>} f a <putchar('a')> b<putchar('b')> (e) этот метод можно использовать для перевода цепочек одного языка в цепочки другого языка (что, собственно, мы и делали, занимаясь переводами в полиз цепочек лексем).",цепочек,gramm,1
"60 пусть есть грамматика, описывающая простейшее арифметическое выражение: e t {+t} t f { f} f a b (e) тогда грамматика с действиями по переводу этого выражения в полиз будет такой: e t {+t <putchar('+')>} t f { f <putchar(' ')>} f a <putchar('a')> b<putchar('b')> (e) этот метод можно использовать для перевода цепочек одного языка в цепочки другого языка (что, собственно, мы и делали, занимаясь переводами в полиз цепочек лексем).",полиз,gramm,1
"60 пусть есть грамматика, описывающая простейшее арифметическое выражение: e t {+t} t f { f} f a b (e) тогда грамматика с действиями по переводу этого выражения в полиз будет такой: e t {+t <putchar('+')>} t f { f <putchar(' ')>} f a <putchar('a')> b<putchar('b')> (e) этот метод можно использовать для перевода цепочек одного языка в цепочки другого языка (что, собственно, мы и делали, занимаясь переводами в полиз цепочек лексем).",грамматика,gramm,1
"60 пусть есть грамматика, описывающая простейшее арифметическое выражение: e t {+t} t f { f} f a b (e) тогда грамматика с действиями по переводу этого выражения в полиз будет такой: e t {+t <putchar('+')>} t f { f <putchar(' ')>} f a <putchar('a')> b<putchar('b')> (e) этот метод можно использовать для перевода цепочек одного языка в цепочки другого языка (что, собственно, мы и делали, занимаясь переводами в полиз цепочек лексем).",цепочки,gramm,1
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",цепочки,gramm,1
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",цепочек языка,gramm,1
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",цепочек,gramm,1
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",грамматики,gramm,1
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",цепочки языка,gramm,1
"генератор внутреннего представления программы на м-языке каждый элемент в полизе - это лексема, т.е. пара вида (номер класса, номер в классе).",лексема,gramm,1
"генератор внутреннего представления программы на м-языке каждый элемент в полизе - это лексема, т.е. пара вида (номер класса, номер в классе).",м-языке,gramm,1
"f, r, w) относятся к классу ограничителей, как и все другие операции модельного языка; 2) для ссылок на номера элементов полиза введем лексемы класса 0, т.е. (0,p) - лексема, обозначающая p-ый элемент в полизе; 3) для того, чтобы различать операнды-значения-переменных и операнды-адреса-переменных (например, в полизе оператора присваивания), операнды-значения будем обозначать лексемами класса 4, а для операндов-адресов введем лексемы класса 5.",лексемы,gramm,1
"f, r, w) относятся к классу ограничителей, как и все другие операции модельного языка; 2) для ссылок на номера элементов полиза введем лексемы класса 0, т.е. (0,p) - лексема, обозначающая p-ый элемент в полизе; 3) для того, чтобы различать операнды-значения-переменных и операнды-адреса-переменных (например, в полизе оператора присваивания), операнды-значения будем обозначать лексемами класса 4, а для операндов-адресов введем лексемы класса 5.",лексема,gramm,1
"f, r, w) относятся к классу ограничителей, как и все другие операции модельного языка; 2) для ссылок на номера элементов полиза введем лексемы класса 0, т.е. (0,p) - лексема, обозначающая p-ый элемент в полизе; 3) для того, чтобы различать операнды-значения-переменных и операнды-адреса-переменных (например, в полизе оператора присваивания), операнды-значения будем обозначать лексемами класса 4, а для операндов-адресов введем лексемы класса 5.",модельного языка,gramm,1
"f, r, w) относятся к классу ограничителей, как и все другие операции модельного языка; 2) для ссылок на номера элементов полиза введем лексемы класса 0, т.е. (0,p) - лексема, обозначающая p-ый элемент в полизе; 3) для того, чтобы различать операнды-значения-переменных и операнды-адреса-переменных (например, в полизе оператора присваивания), операнды-значения будем обозначать лексемами класса 4, а для операндов-адресов введем лексемы класса 5.",лексемами,gramm,1
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",полиз,gramm,1
"генерация внутреннего представления программы будет проходить во время синтаксического анализа параллельно с контролем контекстных условий, поэтому для генерации можно использовать информацию, ""собранную"" синтаксическим и семантическим анализаторами; например, при генерации полиза выражений можно воспользоваться содержимым стека, с которым работает семантический анализатор.",синтаксического анализа,gramm,1
"генерация внутреннего представления программы будет проходить во время синтаксического анализа параллельно с контролем контекстных условий, поэтому для генерации можно использовать информацию, ""собранную"" синтаксическим и семантическим анализаторами; например, при генерации полиза выражений можно воспользоваться содержимым стека, с которым работает семантический анализатор.",контекстных условий,gramm,1
"кроме того, можно дополнить функции семантического анализа действиями по генерации: void checkop p (void) {char op; char t1; char t2; char res; t2 = spop(); op = spop(); t1 = spop(); res = gettype (op,t1,t2); if (strcmp (res, ""no"")) {spush (res); put lex (make op (op));} / дополнение!",семантического анализа,gramm,1
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",контекстных условий,gramm,1
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",полиз,gramm,1
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",грамматика,gramm,1
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",модельного языка,gramm,1
"пусть есть функция struct lex make labl (int k), которая формирует лексему-метку полиза вида (0,k).",лексему,gramm,1
"тогда грамматика, содержащая действия по контролю контекстных условий и переводу условного оператора модельного языка в полиз, будет такой: s if e < eqbool(); pl2 = free++; put lex (make op (""!f"")) > then s < pl3 = free++; put lex (make op (""!"")); p[pl2] = make labl (free) > else s < p[pl3] = make lable (free) > замечание: переменные pl2 и pl3 должны быть локализованы в процедуре s, иначе возникнет ошибка при обработке вложенных условных операторов.",контекстных условий,gramm,1
"тогда грамматика, содержащая действия по контролю контекстных условий и переводу условного оператора модельного языка в полиз, будет такой: s if e < eqbool(); pl2 = free++; put lex (make op (""!f"")) > then s < pl3 = free++; put lex (make op (""!"")); p[pl2] = make labl (free) > else s < p[pl3] = make lable (free) > замечание: переменные pl2 и pl3 должны быть локализованы в процедуре s, иначе возникнет ошибка при обработке вложенных условных операторов.",полиз,gramm,1
"тогда грамматика, содержащая действия по контролю контекстных условий и переводу условного оператора модельного языка в полиз, будет такой: s if e < eqbool(); pl2 = free++; put lex (make op (""!f"")) > then s < pl3 = free++; put lex (make op (""!"")); p[pl2] = make labl (free) > else s < p[pl3] = make lable (free) > замечание: переменные pl2 и pl3 должны быть локализованы в процедуре s, иначе возникнет ошибка при обработке вложенных условных операторов.",грамматика,gramm,1
"тогда грамматика, содержащая действия по контролю контекстных условий и переводу условного оператора модельного языка в полиз, будет такой: s if e < eqbool(); pl2 = free++; put lex (make op (""!f"")) > then s < pl3 = free++; put lex (make op (""!"")); p[pl2] = make labl (free) > else s < p[pl3] = make lable (free) > замечание: переменные pl2 и pl3 должны быть локализованы в процедуре s, иначе возникнет ошибка при обработке вложенных условных операторов.",модельного языка,gramm,1
аналогично можно описать способ генерации полиза других операторов модельного языка.,модельного языка,gramm,1
"интерпретатор полиза для модельного языка польская инверсная запись была выбрана нами в качестве языка внутреннего представления программы, в частности, потому, что записанная таким образом программа может быть легко проинтерпретирована.",польская инверсная запись,gramm,1
"интерпретатор полиза для модельного языка польская инверсная запись была выбрана нами в качестве языка внутреннего представления программы, в частности, потому, что записанная таким образом программа может быть легко проинтерпретирована.",модельного языка,gramm,1
"63 идея алгоритма очень проста: просматриваем полиз слева направо; если встречаем операнд, то записываем его в стек; если встретили знак операции, то извлекаем из стека нужное количество операндов и выполняем операцию, результат (если он есть) заносим в стек и т.д.",полиз,gramm,1
"итак, программа на полизе записана в массиве p; пусть она состоит из n элементов-лексем.",лексем,gramm,1
"каждая лексема - это структура struct lex {int class; int value;}, возможные значения поля class: 0 - лексемы-метки (номера элементов в полизе) 1 - логические константы true либо false ( других лексем - служебных слов в полизе нет) 2 - операции (других лексем-ограничителей в полизе нет)",лексема,gramm,1
3 - целые константы 4 - лексемы-идентификаторы ( во время интерпретации будет использовать-ся значение) 5 - лексемы-идентификаторы ( во время интерпретации будет использовать-ся адрес).,лексемы,gramm,1
"данное пособие представляет собой введение в теорию эвристического поиска один из наиболее разработанных разделов области исследований, известной под названием искусственный интеллект .",эвристического поиска,ai,1
"у этой традиции, сложившейся почти за 30 лет существования теории эвристического поиска, существует важная причина.",эвристического поиска,ai,1
двумя составными элементами процесса решения задач в теории эвристического поиска является представление (формализация) задач и собственно решение поиск.,эвристического поиска,ai,1
"в пособии рассматриваются два подхода к решению задач и, соответственно, два способа представления подход с использованием пространства состояний и подход, основанный на редукции задач.",редукции,ai,1
"в пособии рассматриваются два подхода к решению задач и, соответственно, два способа представления подход с использованием пространства состояний и подход, основанный на редукции задач.",пространства состояний,ai,1
"в пособии рассматриваются два подхода к решению задач и, соответственно, два способа представления подход с использованием пространства состояний и подход, основанный на редукции задач.",редукции задач,ai,1
для обоих подходов описываются используемые алгоритмы поиска решения.,алгоритмы поиска,ai,1
важной особенностью большинства этих алгоритмов является исполь зование эвристической информации.,эвристической информации,ai,1
"в области искусственного интеллекта и теории поиска под эвристической информацией понимается все то, что относится к конкретной решаемой задаче и служит более эффективному ее решению.",эвристической информацией,ai,1
"представление задач в пространстве состояний 1.1.1 основные понятия типичным представителем класса задач, для которых подходит представление в пространстве состояний, является головоломка, известная как игра в пятнадцать см. рис.1(а).",пространстве состояний,ai,1
"введем теперь основные понятия, используемые при формализации задачи в пространстве состояний.",пространстве состояний,ai,1
центральным из них является понятие состояния задачи.,состояния задачи,ai,1
"среди всех состояний задачи выделяются начальное состояние и целевое состояние, в совокупности определяющие задачу, которую надо решить примеры их приведены на рис.1.",состояний задачи,ai,1
"среди всех состояний задачи выделяются начальное состояние и целевое состояние, в совокупности определяющие задачу, которую надо решить примеры их приведены на рис.1.",целевое состояние,ai,1
"решение задачи ищется в пространстве состояний множестве всех состояний, достижимых из начального состояния при помощи заданных операторов.",пространстве состояний,ai,1
"например, в игре в пятнадцать или в восемь пространство состояний состоит из всех конфигураций фишек, которые могут быть образованы в результате возможных перемещений фишек.",пространство состояний,ai,1
"пространство состояний можно представить в виде направленного графа, вершины которого соответствуют состояниям, а дуги (ребра) применяемым операторам.",пространство состояний,ai,1
"на рис.2 показана часть пространства состояний для игры в пятнадцать: в каждой вершине помещена та конфигурация фишек, которую она представляет.",пространства состояний,ai,1
"часть пространства состояний для игры в пятнадцать пространства состояний могут быть большими и даже бесконечными, но в любом случае предполагается счетность множества состояний.",пространства состояний,ai,1
"таким образом, в подходе к решению задачи с использованием пространства состояний задача рассматривается как тройка (s i , o, sg) , где si начальное состояние; o конечное множество операторов, действующих на не более чем счетном множестве состояний; sg целевое состояние.",пространства состояний,ai,1
"таким образом, в подходе к решению задачи с использованием пространства состояний задача рассматривается как тройка (s i , o, sg) , где si начальное состояние; o конечное множество операторов, действующих на не более чем счетном множестве состояний; sg целевое состояние.",целевое состояние,ai,1
"таким образом, в подходе к решению задачи с использованием пространства состояний задача рассматривается как тройка (s i , o, sg) , где si начальное состояние; o конечное множество операторов, действующих на не более чем счетном множестве состояний; sg целевое состояние.",состояний задача,ai,1
дальнейшая формализация решения задачи с использованием пространства состояний предполагает выбор некоторой конкретной формы описания состояний задачи.,состояний задачи,ai,1
дальнейшая формализация решения задачи с использованием пространства состояний предполагает выбор некоторой конкретной формы описания состояний задачи.,пространства состояний,ai,1
дальнейшая формализация решения задачи с использованием пространства состояний предполагает выбор некоторой конкретной формы описания состояний задачи.,описания состояний,ai,1
"для этого могут применяться любые подходящие структуры строки, массивы, списки, деревья и т.п. например, для игры в пятнадцать или восемь наиболее естественной формой описания состояния будет двумерный массив.",описания состояния,ai,1
"заметим, что от выбора формы описания состояния зависит в общем случае сложность задания операторов задачи, которые должны быть также определены при формализации задачи в пространстве состояний.",пространстве состояний,ai,1
"заметим, что от выбора формы описания состояния зависит в общем случае сложность задания операторов задачи, которые должны быть также определены при формализации задачи в пространстве состояний.",описания состояния,ai,1
"в рассмотренных на рис.1 примерах задач искомое целевое состояние задается явно, т.е. известно местоположение каждой фишки в целевой конфигурации.",целевое состояние,ai,1
"в более сложных случаях игры может быть несколько целевых состояний, либо же целевое состояние может быть определено неявно, т.е. охарактеризовано некоторым свойством, например, как состояние, в котором сумма номеров фишек в верхнем ряду не превосходит 10.",целевое состояние,ai,1
"в более сложных случаях игры может быть несколько целевых состояний, либо же целевое состояние может быть определено неявно, т.е. охарактеризовано некоторым свойством, например, как состояние, в котором сумма номеров фишек в верхнем ряду не превосходит 10.",целевых состояний,ai,1
"в подобных случаях свойство, которому должно удовлетворять целевое состояние, должно быть описано исчерпывающим образом, к примеру, путем задания булевской функции, реализующей проверку нужного свойства состояния задачи.",целевое состояние,ai,1
"в подобных случаях свойство, которому должно удовлетворять целевое состояние, должно быть описано исчерпывающим образом, к примеру, путем задания булевской функции, реализующей проверку нужного свойства состояния задачи.",состояния задачи,ai,1
"итак, для представления задачи в пространстве состояний необходимо определить следующее: форму описания состояний задачи и описание начального состояния; множество операторов и их воздействий на описания состояний; множество целевых состояний или же описание их свойств.",состояний задачи,ai,1
"итак, для представления задачи в пространстве состояний необходимо определить следующее: форму описания состояний задачи и описание начального состояния; множество операторов и их воздействий на описания состояний; множество целевых состояний или же описание их свойств.",пространстве состояний,ai,1
"итак, для представления задачи в пространстве состояний необходимо определить следующее: форму описания состояний задачи и описание начального состояния; множество операторов и их воздействий на описания состояний; множество целевых состояний или же описание их свойств.",описания состояний,ai,1
"итак, для представления задачи в пространстве состояний необходимо определить следующее: форму описания состояний задачи и описание начального состояния; множество операторов и их воздействий на описания состояний; множество целевых состояний или же описание их свойств.",целевых состояний,ai,1
"перечисленные составляющие задают неявно граф-пространство состояний, в котором необходимо найти решение задачи.",пространство состояний,ai,1
"решение задачи в пространстве состояний подразумевает просмотр неявно заданного графа, для чего необходимо преобразование в явную форму достаточно большой его части, включающей искомую целевую вершину.",целевую вершину,ai,1
"решение задачи в пространстве состояний подразумевает просмотр неявно заданного графа, для чего необходимо преобразование в явную форму достаточно большой его части, включающей искомую целевую вершину.",пространстве состояний,ai,1
"действительно, просмотр осуществляется как последовательный поиск, или перебор вершин, в пространстве состояний.",пространстве состояний,ai,1
"в исходной точке процесса к начальному состоянию применяется тот или иной оператор и строится новая вершина-состояние, а также дуги, связывающие ее с корневой вершиной.",вершина-состояние,ai,1
на каждом последующем шаге поиска к одной из уже полученных вершин-состояний применяется допустимый оператор и строится еще одна вершина графа и связывающие дуги.,вершин-состояний,ai,1
"если очередная построенная вершина соответствует целевому состоянию, то процесс поиска завершается.",целевому состоянию,ai,1
"1.1.2 примеры пространств состояний разберем два характерных примера представления задач в пространстве состояний, показывающих, что такое представление возможно для различных типов задач.",пространстве состояний,ai,1
"1.1.2 примеры пространств состояний разберем два характерных примера представления задач в пространстве состояний, показывающих, что такое представление возможно для различных типов задач.",пространств состояний,ai,1
"вообще, от выбора представления, т.е. рассмотренных выше составляющих, зависит размер пространства состояний, а значит, и эффективность поиска в нем.",пространства состояний,ai,1
"очевидно, желательны представления с малыми пространствами состояний, но нахождение удачных представлений, сужающих пространство поиска, требует обычно некоторого дополнительного анализа решаемой задачи.",пространство поиска,ai,1
"очевидно, желательны представления с малыми пространствами состояний, но нахождение удачных представлений, сужающих пространство поиска, требует обычно некоторого дополнительного анализа решаемой задачи.",пространствами состояний,ai,1
рассмотрим формализацию в пространстве состояний известной задачи о коммивояжере.,пространстве состояний,ai,1
"на рис.4 показана в виде графа часть получающегося пространства состояний, включающая решающий путь.",пространства состояний,ai,1
"на рис.4 показана в виде графа часть получающегося пространства состояний, включающая решающий путь.",решающий путь,ai,1
"такой оператор применим к некоторому описанию состояния, если он соответствует карте дорог и в список-описание не включен город, в который надо произвести переезд.",описанию состояния,ai,1
"задача о коммивояжере: часть пространства состояний обратимся теперь к известной задаче об обезьяне и банане, простейшую формулировку которой мы и рассмотрим.",пространства состояний,ai,1
"ясно, что описание состояния этой задачи должно включать следующие сведения: местоположение обезьяны в комнате в горизонтальной плоскости пола и по вертикали (т.е. на полу она или на ящике), местоположение ящика на полу и наличие у обезьяны бананов.",описание состояния,ai,1
"тогда начальное состояние задачи описывается списком (то, п, тя, 0), а целевое состояние задается как любой список, последний элемент которого равен 1.",состояние задачи,ai,1
"тогда начальное состояние задачи описывается списком (то, п, тя, 0), а целевое состояние задается как любой список, последний элемент которого равен 1.",целевое состояние,ai,1
"пространство состояний в задаче об обезьяне если считать, что для решения задачи значимы лишь вышеупомянутые точки пола то, тя, тб, тогда получим пространство состояний задачи, изображенное на рис.5.",состояний задачи,ai,1
"пространство состояний в задаче об обезьяне если считать, что для решения задачи значимы лишь вышеупомянутые точки пола то, тя, тб, тогда получим пространство состояний задачи, изображенное на рис.5.",пространство состояний,ai,1
"жирными дугами (стрелками) показан решающий путь, состоящий из четырех операторов: перейти (тя); передвинуть (тб); взобраться; схватить.",решающий путь,ai,1
"такое небольшое по размерам пространство состояний получено, в частности, вследствие того, что игнорировались все точки пола, кроме трех, соответствующих первоначальному расположению обезьяны, ящика и бананов.",пространство состояний,ai,1
"мощным приемом сужения пространств состояний является применение так называемых схем состояний и схем операторов, в которых для описаний состояний и операторов используются переменные.",пространств состояний,ai,1
"мощным приемом сужения пространств состояний является применение так называемых схем состояний и схем операторов, в которых для описаний состояний и операторов используются переменные.",описаний состояний,ai,1
"1.2 редукция задач 1.2.1 основные понятия кроме уже рассмотренного подхода представления задач в пространстве состояний для решения ряда задач возможен и другой, более сложный подход.",редукция задач,ai,1
"1.2 редукция задач 1.2.1 основные понятия кроме уже рассмотренного подхода представления задач в пространстве состояний для решения ряда задач возможен и другой, более сложный подход.",пространстве состояний,ai,1
"1.2 редукция задач 1.2.1 основные понятия кроме уже рассмотренного подхода представления задач в пространстве состояний для решения ряда задач возможен и другой, более сложный подход.",редукция,ai,1
"каждая из выделенных подзадач в общем случае является более простой, чем исходная, и может быть решена каким-либо методом, в том числе с использованием пространства состояний.",пространства состояний,ai,1
"но можно продолжить процесс, последовательно выделяя из возникающих задач свои подзадачи до тех пор, пока не получим элементарные задачи, решение которых уже известно.",элементарные задачи,ai,1
"такой путь называется подходом, основанным на сведении задач к подзадачам, или на редукции задач.",редукции,ai,1
"такой путь называется подходом, основанным на сведении задач к подзадачам, или на редукции задач.",редукции задач,ai,1
на рис.6 показаны начальное и целевое состояния задачи о ханойской башне.,целевое состояния,ai,1
на рис.6 показаны начальное и целевое состояния задачи о ханойской башне.,состояния задачи,ai,1
"задача о ханойской башне эта задача легко может быть формализована в пространстве состояний: состояние задачи задается списком из трех элементов, каждый из которых указывает местоположение соответствующего диска (первый элемент первого диска, второй второго, третий третьего).",состояние задачи,ai,1
"задача о ханойской башне эта задача легко может быть формализована в пространстве состояний: состояние задачи задается списком из трех элементов, каждый из которых указывает местоположение соответствующего диска (первый элемент первого диска, второй второго, третий третьего).",пространстве состояний,ai,1
"полное пространство состояний задачи о пирамидке представлено графом на рис.7, включающем 27 вершин.",состояний задачи,ai,1
"полное пространство состояний задачи о пирамидке представлено графом на рис.7, включающем 27 вершин.",пространство состояний,ai,1
"пространство состояний в задаче о ханойской башне это решение можно обнаружить перебором всех возможных перемещений дисков, но метод редукции задач позволяет решить рассматриваемую задачу быстрее.",редукции,ai,1
"пространство состояний в задаче о ханойской башне это решение можно обнаружить перебором всех возможных перемещений дисков, но метод редукции задач позволяет решить рассматриваемую задачу быстрее.",пространство состояний,ai,1
"пространство состояний в задаче о ханойской башне это решение можно обнаружить перебором всех возможных перемещений дисков, но метод редукции задач позволяет решить рассматриваемую задачу быстрее.",редукции задач,ai,1
"пространство состояний в задаче о ханойской башне это решение можно обнаружить перебором всех возможных перемещений дисков, но метод редукции задач позволяет решить рассматриваемую задачу быстрее.",метод редукции,ai,1
"ключевая идея редукции состоит в том, что для перемещения всей пирамидки необходимо переложить самый нижний диск 3, а это возможно, только если располагающаяся над ним пирамидка из двух меньших дисков 1 и 2 перенесена на колышек в см. рис.",редукции,ai,1
"действительно, в первой и в третьей задачах требуется переместить всего два диска, вторая же задача может рассматриваться как элементарная, так как ее решение состоит ровно из одного хода перемещения диска 3 на колышек с. в первой и третьей задачах можно вновь применить метод редукции задач, и свести их к элементар ным задачам.",редукции,ai,1
"действительно, в первой и в третьей задачах требуется переместить всего два диска, вторая же задача может рассматриваться как элементарная, так как ее решение состоит ровно из одного хода перемещения диска 3 на колышек с. в первой и третьей задачах можно вновь применить метод редукции задач, и свести их к элементар ным задачам.",редукции задач,ai,1
"действительно, в первой и в третьей задачах требуется переместить всего два диска, вторая же задача может рассматриваться как элементарная, так как ее решение состоит ровно из одного хода перемещения диска 3 на колышек с. в первой и третьей задачах можно вновь применить метод редукции задач, и свести их к элементар ным задачам.",метод редукции,ai,1
весь процесс редукции можно схематически представить в виде дерева на рис.,редукции,ai,1
"вершины дерева соответствуют решаемым задачам/подзадачам, причем листья дерева соответствуют элементарным задачам перемещения дисков, а дуги связывают редуцируемую задачу с ее подзадачами.",элементарным задачам,ai,1
"редукция задачи о ханойской башне заметим, что рассмотренная идея сведения задачи к совокупности подзадач может быть применена и в случае, когда начальная конфигурация задачи о пирамидке содержит не три, а большее число дисков.",редукция задачи,ai,1
"редукция задачи о ханойской башне заметим, что рассмотренная идея сведения задачи к совокупности подзадач может быть применена и в случае, когда начальная конфигурация задачи о пирамидке содержит не три, а большее число дисков.",редукция,ai,1
"таким образом, в случае подхода, основанного на редукции задач, мы получаем также пространство, но состоящее не из состояний, а из задач/подзадач (точнее, их описаний).",редукции,ai,1
"таким образом, в случае подхода, основанного на редукции задач, мы получаем также пространство, но состоящее не из состояний, а из задач/подзадач (точнее, их описаний).",редукции задач,ai,1
"при этом роль, аналогичную операторам в пространстве состояний, играют операторы, сводящие задачи в подзадачи.",пространстве состояний,ai,1
"точнее, каждый оператор редукции преобразует описание задачи в описание множества подзадач, причем это множество таково, что решение всех подзадач обеспечивает решение редуцированной задачи.",редукции,ai,1
"точнее, каждый оператор редукции преобразует описание задачи в описание множества подзадач, причем это множество таково, что решение всех подзадач обеспечивает решение редуцированной задачи.",оператор редукции,ai,1
"при решении задач методом редукции, как и при решении в пространстве состояний, может возникнуть необходимость перебора.",редукции,ai,1
"при решении задач методом редукции, как и при решении в пространстве состояний, может возникнуть необходимость перебора.",пространстве состояний,ai,1
"при решении задач методом редукции, как и при решении в пространстве состояний, может возникнуть необходимость перебора.",методом редукции,ai,1
"действительно, на каждом этапе редукции может оказаться несколько применимых операторов (т.е. способов сведения задачи к подзадачам) и, соответственно, несколько альтер нативных множеств подзадач.",редукции,ai,1
в общем случае для полной редукции исходной задачи необходимо перепробовать несколько операторов.,редукции,ai,1
"процесс редукции продолжается, пока исходная задача не будет сведена к набору элементарных задач, решение которых известно.",редукции,ai,1
"процесс редукции продолжается, пока исходная задача не будет сведена к набору элементарных задач, решение которых известно.",элементарных задач,ai,1
"аналогично представлению в пространстве состояний, формализация задачи в рамках подхода, основанного на редукции задач, включает определение следующих составляющих: формы описания задач/подзадач и описание исходной задачи; множества операторов и их воздействий на описания задач; множества элементарных задач.",редукции,ai,1
"аналогично представлению в пространстве состояний, формализация задачи в рамках подхода, основанного на редукции задач, включает определение следующих составляющих: формы описания задач/подзадач и описание исходной задачи; множества операторов и их воздействий на описания задач; множества элементарных задач.",элементарных задач,ai,1
"аналогично представлению в пространстве состояний, формализация задачи в рамках подхода, основанного на редукции задач, включает определение следующих составляющих: формы описания задач/подзадач и описание исходной задачи; множества операторов и их воздействий на описания задач; множества элементарных задач.",редукции задач,ai,1
"аналогично представлению в пространстве состояний, формализация задачи в рамках подхода, основанного на редукции задач, включает определение следующих составляющих: формы описания задач/подзадач и описание исходной задачи; множества операторов и их воздействий на описания задач; множества элементарных задач.",пространстве состояний,ai,1
"эти составляющие задают неявно пространство задач, в котором требуется провести поиск решения задачи.",пространство задач,ai,1
"что касается формы описания задач/подзадач, то часто их удобно описывать в терминах пространства состояний, т.е. задавая начальное состояние и множество операторов, а также целевое состояние или его свойства.",пространства состояний,ai,1
"что касается формы описания задач/подзадач, то часто их удобно описывать в терминах пространства состояний, т.е. задавая начальное состояние и множество операторов, а также целевое состояние или его свойства.",целевое состояние,ai,1
"в этом случае элементарными задачами могут быть, к примеру, задачи, решаемые за один шаг в пространстве состояний.",пространстве состояний,ai,1
"в этом случае элементарными задачами могут быть, к примеру, задачи, решаемые за один шаг в пространстве состояний.",элементарными задачами,ai,1
"если выбрать такую форму описания в задаче о пирамидке, то элементарная задача перекладывания самого большого диска с колышка а на с записывалась бы как (вва) (ввс), а исходная задача как (ааа) (ссс).",элементарная задача,ai,1
при выбранной форме описания задач результирующие подзадачи естественно интерпретируются как задачи нахождения пути между определенными состояниями-вехами в пространстве состояний.,пространстве состояний,ai,1
"они обладают тем свойством, что через них пройдет и искомый решающий путь.",решающий путь,ai,1
"в дополнение отметим, что подход с использованием пространства состояний можно рассматривать как вырожденный случай подхода, основанного на редукции задач, так как применение оператора в пространстве состояний сводит обычно исходную задачу к несколько более простой задаче, т.е. редуцирует ее.",редукции,ai,1
"в дополнение отметим, что подход с использованием пространства состояний можно рассматривать как вырожденный случай подхода, основанного на редукции задач, так как применение оператора в пространстве состояний сводит обычно исходную задачу к несколько более простой задаче, т.е. редуцирует ее.",пространства состояний,ai,1
"в дополнение отметим, что подход с использованием пространства состояний можно рассматривать как вырожденный случай подхода, основанного на редукции задач, так как применение оператора в пространстве состояний сводит обычно исходную задачу к несколько более простой задаче, т.е. редуцирует ее.",редукции задач,ai,1
"в дополнение отметим, что подход с использованием пространства состояний можно рассматривать как вырожденный случай подхода, основанного на редукции задач, так как применение оператора в пространстве состояний сводит обычно исходную задачу к несколько более простой задаче, т.е. редуцирует ее.",пространстве состояний,ai,1
1.2.2 и/или графы.,и/или графы,ai,1
"решающий граф для изображения процесса редукции задач и получающихся при этом альтернативных множеств подзадач используются обычно графоподобные структуры, вершины которых представляют описания задач и подзадач, а каждая дуга связывает пару вершин, соответствующих редуцируемой задаче и одной из результирующих подзадач, причем стрелки на дугах указывают направление редукции.",редукции,ai,1
"решающий граф для изображения процесса редукции задач и получающихся при этом альтернативных множеств подзадач используются обычно графоподобные структуры, вершины которых представляют описания задач и подзадач, а каждая дуга связывает пару вершин, соответствующих редуцируемой задаче и одной из результирующих подзадач, причем стрелки на дугах указывают направление редукции.",решающий граф,ai,1
"решающий граф для изображения процесса редукции задач и получающихся при этом альтернативных множеств подзадач используются обычно графоподобные структуры, вершины которых представляют описания задач и подзадач, а каждая дуга связывает пару вершин, соответствующих редуцируемой задаче и одной из результирующих подзадач, причем стрелки на дугах указывают направление редукции.",редукции задач,ai,1
"схематическое изображение редукции задач если считать, что вершины d и e соответствуют описаниям альтернативных путей решения исходной задачи, то вершину g можно назвать или-вершиной, так как задача g разрешима или способом d, или способом e, или способом f. аналогично вершины d и e можно назвать и-вершинами, поскольку каждый из соответствующих им способов требует решения всех подчиненных задач, что и обозначается специальной дугой.",редукции,ai,1
"схематическое изображение редукции задач если считать, что вершины d и e соответствуют описаниям альтернативных путей решения исходной задачи, то вершину g можно назвать или-вершиной, так как задача g разрешима или способом d, или способом e, или способом f. аналогично вершины d и e можно назвать и-вершинами, поскольку каждый из соответствующих им способов требует решения всех подчиненных задач, что и обозначается специальной дугой.",редукции задач,ai,1
"если некоторая вершина такого графа имеет непосредственно следующие за ней (дочерние) вершины, то либо все они являются и-вершинами, либо все они или-вершины.",или-вершины,ai,1
"на языке и/или-графов применение нескольких операторов редукции задачи будет означать, что сначала будет построена промежуточная и-вершина, а затем непосредственно следующие за ней или-вершины подзадач.",редукции,ai,1
"на языке и/или-графов применение нескольких операторов редукции задачи будет означать, что сначала будет построена промежуточная и-вершина, а затем непосредственно следующие за ней или-вершины подзадач.",и-вершина,ai,1
"на языке и/или-графов применение нескольких операторов редукции задачи будет означать, что сначала будет построена промежуточная и-вершина, а затем непосредственно следующие за ней или-вершины подзадач.",или-вершины,ai,1
"на языке и/или-графов применение нескольких операторов редукции задачи будет означать, что сначала будет построена промежуточная и-вершина, а затем непосредственно следующие за ней или-вершины подзадач.",редукции задачи,ai,1
"на языке и/или-графов применение нескольких операторов редукции задачи будет означать, что сначала будет построена промежуточная и-вершина, а затем непосредственно следующие за ней или-вершины подзадач.",операторов редукции,ai,1
"исключение составляет случай, когда множество задач состоит только из одного элемента, в этом случае будет образована ровно одна вершина, будем для определенности считать ее или-вершиной.",или-вершиной,ai,1
"вершины же, которые соответствуют описаниям элементарных задач, будем называть заключительными вершинами.",элементарных задач,ai,1
"в графе, показанном на рис.11, начальной является вершина p0, а заключительными вершины p1, p4, p5, p7 и p8 (они изображены жирными кружками).",заключительными вершины,ai,1
"поиск решения задачи, осуществляемый путем перебора вершин графа, применим и в подходе, основанном на редукции задач.",редукции,ai,1
"поиск решения задачи, осуществляемый путем перебора вершин графа, применим и в подходе, основанном на редукции задач.",редукции задач,ai,1
"пример и/или-графа сформулируем общее рекурсивное определение разрешимости вершины в и/или-графе: заключительные вершины разрешимы, так как они соответствуют элементарным задачам; или-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима по крайней мере одна из ее дочерних вершин; и-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима каждая из ее дочерних вершин.",элементарным задачам,ai,1
"пример и/или-графа сформулируем общее рекурсивное определение разрешимости вершины в и/или-графе: заключительные вершины разрешимы, так как они соответствуют элементарным задачам; или-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима по крайней мере одна из ее дочерних вершин; и-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима каждая из ее дочерних вершин.",или-вершина,ai,1
"пример и/или-графа сформулируем общее рекурсивное определение разрешимости вершины в и/или-графе: заключительные вершины разрешимы, так как они соответствуют элементарным задачам; или-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима по крайней мере одна из ее дочерних вершин; и-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима каждая из ее дочерних вершин.",и-вершина,ai,1
"пример и/или-графа сформулируем общее рекурсивное определение разрешимости вершины в и/или-графе: заключительные вершины разрешимы, так как они соответствуют элементарным задачам; или-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима по крайней мере одна из ее дочерних вершин; и-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима каждая из ее дочерних вершин.",заключительные вершины,ai,1
"решающий граф это подграф и/или-графа, состоящий только из разрешимых вершин и доказывающий разрешимость начальной вершины.",решающий граф,ai,1
"1.2.3 пример: задача символьного интегрирования в качестве примера применения метода редукции рассмотрим решение задачи символьного интегрирования, т.е. нахождения неопределенного интеграла .",редукции,ai,1
"1.2.3 пример: задача символьного интегрирования в качестве примера применения метода редукции рассмотрим решение задачи символьного интегрирования, т.е. нахождения неопределенного интеграла .",метода редукции,ai,1
"для формализации этой задачи в рамках подхода, основанного на редукции задач, необходимо определить форму описания задач/подзадач, операторы редукции и элементарные задачи.",элементарные задачи,ai,1
"для формализации этой задачи в рамках подхода, основанного на редукции задач, необходимо определить форму описания задач/подзадач, операторы редукции и элементарные задачи.",редукции,ai,1
"для формализации этой задачи в рамках подхода, основанного на редукции задач, необходимо определить форму описания задач/подзадач, операторы редукции и элементарные задачи.",редукции задач,ai,1
"для формализации этой задачи в рамках подхода, основанного на редукции задач, необходимо определить форму описания задач/подзадач, операторы редукции и элементарные задачи.",операторы редукции,ai,1
"операторы редукции будут основаны, очевидно, на упомянутых правилах интегрирования.",редукции,ai,1
"операторы редукции будут основаны, очевидно, на упомянутых правилах интегрирования.",операторы редукции,ai,1
"заметим, что часть получаемых таким образом операторов редукции (как, например, операторы, соответствующие правилу интегрирования по частям или правилу интегрирования суммы функций), действительно редуцируют исходную задачу и порождают и-вершину в и/или-графе, в то время как алгебраические и тригонометрические подстановки и тождества (как, например, деление числителя на знаменатель или дополнение до полного квадрата) лишь заменяют одно подынтегральное выражение на другое, порождая, таким образом, или-вершины.",редукции,ai,1
"заметим, что часть получаемых таким образом операторов редукции (как, например, операторы, соответствующие правилу интегрирования по частям или правилу интегрирования суммы функций), действительно редуцируют исходную задачу и порождают и-вершину в и/или-графе, в то время как алгебраические и тригонометрические подстановки и тождества (как, например, деление числителя на знаменатель или дополнение до полного квадрата) лишь заменяют одно подынтегральное выражение на другое, порождая, таким образом, или-вершины.",и-вершину,ai,1
"заметим, что часть получаемых таким образом операторов редукции (как, например, операторы, соответствующие правилу интегрирования по частям или правилу интегрирования суммы функций), действительно редуцируют исходную задачу и порождают и-вершину в и/или-графе, в то время как алгебраические и тригонометрические подстановки и тождества (как, например, деление числителя на знаменатель или дополнение до полного квадрата) лишь заменяют одно подынтегральное выражение на другое, порождая, таким образом, или-вершины.",или-вершины,ai,1
"заметим, что часть получаемых таким образом операторов редукции (как, например, операторы, соответствующие правилу интегрирования по частям или правилу интегрирования суммы функций), действительно редуцируют исходную задачу и порождают и-вершину в и/или-графе, в то время как алгебраические и тригонометрические подстановки и тождества (как, например, деление числителя на знаменатель или дополнение до полного квадрата) лишь заменяют одно подынтегральное выражение на другое, порождая, таким образом, или-вершины.",операторов редукции,ai,1
"элементарные задачи интегрирования соответствуют табличным интегралам, например: отметим, что поскольку каждая из таких табличных формул содержит переменные, на самом деле она является схемой, задающей бесконечное множество элементарных задач.",элементарные задачи,ai,1
"элементарные задачи интегрирования соответствуют табличным интегралам, например: отметим, что поскольку каждая из таких табличных формул содержит переменные, на самом деле она является схемой, задающей бесконечное множество элементарных задач.",элементарных задач,ai,1
"это означает, что в общем случае для одного правила возможно несколько вариантов редукции задачи, т.е. несколько способов применения одного и того же оператора редукции.",редукции,ai,1
"это означает, что в общем случае для одного правила возможно несколько вариантов редукции задачи, т.е. несколько способов применения одного и того же оператора редукции.",оператора редукции,ai,1
"это означает, что в общем случае для одного правила возможно несколько вариантов редукции задачи, т.е. несколько способов применения одного и того же оператора редукции.",редукции задачи,ai,1
"другая особенность рассматриваемой задачи состоит в том, что на каждом шаге редукции применимо обычно большое количество операторов (включая несколько применений одного и того же оператора), и получающийся и/или-граф задачи слишком велик даже для несложных задач интегрирования.",редукции,ai,1
"к примеру, можно упорядочить операторы редукции по степени их полезности, и приписать больший приоритет операторам, соответствующим правилам интегрирования суммы и интегрирования по частям.",редукции,ai,1
"к примеру, можно упорядочить операторы редукции по степени их полезности, и приписать больший приоритет операторам, соответствующим правилам интегрирования суммы и интегрирования по частям.",операторы редукции,ai,1
на рис.12 показан решающий граф для одной задачи интегрирования.,решающий граф,ai,1
"в вершинах графа указаны соответствующие задачи/подзадачи, заключительные вершины заключены в двойные рамки.",заключительные вершины,ai,1
"решающий граф для одной задачи интегрирования подход, основанный на редукции задач, применим и имеет преимущества по сравнению с подходом, использующим представление в пространстве состояний, когда получающиеся при редукции подзадачи можно решать независимо друг от друга, как в примере с интегрированием.",редукции,ai,1
"решающий граф для одной задачи интегрирования подход, основанный на редукции задач, применим и имеет преимущества по сравнению с подходом, использующим представление в пространстве состояний, когда получающиеся при редукции подзадачи можно решать независимо друг от друга, как в примере с интегрированием.",решающий граф,ai,1
"решающий граф для одной задачи интегрирования подход, основанный на редукции задач, применим и имеет преимущества по сравнению с подходом, использующим представление в пространстве состояний, когда получающиеся при редукции подзадачи можно решать независимо друг от друга, как в примере с интегрированием.",редукции задач,ai,1
"решающий граф для одной задачи интегрирования подход, основанный на редукции задач, применим и имеет преимущества по сравнению с подходом, использующим представление в пространстве состояний, когда получающиеся при редукции подзадачи можно решать независимо друг от друга, как в примере с интегрированием.",пространстве состояний,ai,1
"метод редукции применим также, если решения получающих подзадач зависят друг от друга, но при этом существует такой порядок их редукции, при котором найденные решения одних, более ранних подзадач не разрушаются при решении других, более поздних как в головоломке о ханойской башне, в которой важен лишь порядок решения выделяемых подзадач.",редукции,ai,1
"метод редукции применим также, если решения получающих подзадач зависят друг от друга, но при этом существует такой порядок их редукции, при котором найденные решения одних, более ранних подзадач не разрушаются при решении других, более поздних как в головоломке о ханойской башне, в которой важен лишь порядок решения выделяемых подзадач.",метод редукции,ai,1
алгоритмы поиска решения оба рассмотренных подхода к решению задач представление в пространстве состояний и метод редукции задач предполагают поиск на графе соответствующего вида.,редукции,ai,1
алгоритмы поиска решения оба рассмотренных подхода к решению задач представление в пространстве состояний и метод редукции задач предполагают поиск на графе соответствующего вида.,метод редукции,ai,1
алгоритмы поиска решения оба рассмотренных подхода к решению задач представление в пространстве состояний и метод редукции задач предполагают поиск на графе соответствующего вида.,пространстве состояний,ai,1
алгоритмы поиска решения оба рассмотренных подхода к решению задач представление в пространстве состояний и метод редукции задач предполагают поиск на графе соответствующего вида.,алгоритмы поиска,ai,1
алгоритмы поиска решения оба рассмотренных подхода к решению задач представление в пространстве состояний и метод редукции задач предполагают поиск на графе соответствующего вида.,редукции задач,ai,1
"настоящая глава будет в основном посвящена алгоритмам поиска решения в пространстве состояний, для алгоритмов поиска на и/или-графах рассматриваются только их отличительные особенности.",пространстве состояний,ai,1
"настоящая глава будет в основном посвящена алгоритмам поиска решения в пространстве состояний, для алгоритмов поиска на и/или-графах рассматриваются только их отличительные особенности.",алгоритмам поиска,ai,1
"настоящая глава будет в основном посвящена алгоритмам поиска решения в пространстве состояний, для алгоритмов поиска на и/или-графах рассматриваются только их отличительные особенности.",алгоритмов поиска,ai,1
"2.1 разновидности поиска как уже отмечалось, поиск в пространстве состояний базируется на последовательном построении (переборе) вершин графа состояний до тех пор, пока не будет обнаружено целевое состояние.",пространстве состояний,ai,1
"2.1 разновидности поиска как уже отмечалось, поиск в пространстве состояний базируется на последовательном построении (переборе) вершин графа состояний до тех пор, пока не будет обнаружено целевое состояние.",целевое состояние,ai,1
"2.1 разновидности поиска как уже отмечалось, поиск в пространстве состояний базируется на последовательном построении (переборе) вершин графа состояний до тех пор, пока не будет обнаружено целевое состояние.",графа состояний,ai,1
"введем несколько терминов, которые будем использовать для описания различных алгоритмов поиска.",алгоритмов поиска,ai,1
"вершину графа, соответствующую начальному состоянию, естественно назвать начальной вершиной, а вершину, соответствующую целевому состоянию целевой.",целевому состоянию,ai,1
"основной операцией, выполняемой при поиске на графе, будем считать раскрытие вершины, что означает порождение (построение) всех ее дочерних вершин, путем применения к соответствующему описанию состояния задачи всех допустимых операторов.",описанию состояния,ai,1
"основной операцией, выполняемой при поиске на графе, будем считать раскрытие вершины, что означает порождение (построение) всех ее дочерних вершин, путем применения к соответствующему описанию состояния задачи всех допустимых операторов.",состояния задачи,ai,1
"основной операцией, выполняемой при поиске на графе, будем считать раскрытие вершины, что означает порождение (построение) всех ее дочерних вершин, путем применения к соответствующему описанию состояния задачи всех допустимых операторов.",раскрытие вершины,ai,1
поиск в пространстве состояний можно представить как процесс постепенного раскрытия вершин и проверки свойств порождаемых вершин.,пространстве состояний,ai,1
поиск в пространстве состояний можно представить как процесс постепенного раскрытия вершин и проверки свойств порождаемых вершин.,раскрытия вершин,ai,1
"именно эти указатели позволят восстановить путь назад к начальной вершине после того, как будет построена целевая вершина.",целевая вершина,ai,1
"вершины и указатели, построенные в процессе поиска, образуют поддерево всего неявно определенного при формализации задачи графа-пространства состояний.",пространства состояний,ai,1
это поддерево называется деревом поиска.,деревом поиска,ai,1
"процедуры поиска в пространстве состояний различаются несколькими характеристиками, основными из которых являются: использование эвристической информации; порядок раскрытия (перебора) вершин;",пространстве состояний,ai,1
"процедуры поиска в пространстве состояний различаются несколькими характеристиками, основными из которых являются: использование эвристической информации; порядок раскрытия (перебора) вершин;",эвристической информации,ai,1
полнота просмотра пространства состояний; направление поиска.,пространства состояний,ai,1
в соответствии с первой характеристикой различают слепой и эвристический поиск.,эвристический поиск,ai,1
"в первом случае местонахождение целевой вершины в пространстве состояний никак не влияет на порядок, в котором раскрываются (перебираются) вершины.",пространстве состояний,ai,1
"в первом случае местонахождение целевой вершины в пространстве состояний никак не влияет на порядок, в котором раскрываются (перебираются) вершины.",целевой вершины,ai,1
"в противоположность слепому поиску, эвристический поиск использует априорную, эвристическую информацию об общем виде пространства состояний и/или о том, где в этом пространстве расположена цель, поэтому для раскрытия обычно выбирается наиболее перспективная вершина.",пространства состояний,ai,1
"в противоположность слепому поиску, эвристический поиск использует априорную, эвристическую информацию об общем виде пространства состояний и/или о том, где в этом пространстве расположена цель, поэтому для раскрытия обычно выбирается наиболее перспективная вершина.",эвристический поиск,ai,1
"в противоположность слепому поиску, эвристический поиск использует априорную, эвристическую информацию об общем виде пространства состояний и/или о том, где в этом пространстве расположена цель, поэтому для раскрытия обычно выбирается наиболее перспективная вершина.",эвристическую информацию,ai,1
"в противоположность слепому поиску, эвристический поиск использует априорную, эвристическую информацию об общем виде пространства состояний и/или о том, где в этом пространстве расположена цель, поэтому для раскрытия обычно выбирается наиболее перспективная вершина.",слепому поиску,ai,1
"два основных подвида слепого поиска, различающиеся порядком раскрытия вершин, это поиск вширь и поиск вглубь.",слепого поиска,ai,1
"два основных подвида слепого поиска, различающиеся порядком раскрытия вершин, это поиск вширь и поиск вглубь.",раскрытия вершин,ai,1
"как слепой, так и эвристический поиск могут характеризоваться полнотой просмотра пространства состояний.",пространства состояний,ai,1
"как слепой, так и эвристический поиск могут характеризоваться полнотой просмотра пространства состояний.",эвристический поиск,ai,1
"при полном переборе осуществляется исчерпывающий просмотр графа-пространства состояний, тем самым гарантируется нахождение решения, если таковое существует.",пространства состояний,ai,1
"в случае неполного поиска просматривается лишь некоторая, хотя и существенная часть пространства, и если эта часть не содержит целевых вершин, то искомое решение задачи найдено не будет.",целевых вершин,ai,1
"в соответствии с направлением различают прямой поиск, ведущийся от начальной вершины к целевой, обратный поиск, ведущийся в направлении от целевой вершины к начальной, и двунаправленный поиск, при котором чередуются прямой и обратный поиск.",целевой вершины,ai,1
"2.2 слепой поиск слепые алгоритмы поиска вширь (breadth first search) и поиска вглубь (depth first search) различаются тем, какая вершина выбирается для очередного раскрытия.",алгоритмы поиска,ai,1
"2.2 слепой поиск слепые алгоритмы поиска вширь (breadth first search) и поиска вглубь (depth first search) различаются тем, какая вершина выбирается для очередного раскрытия.",слепой поиск,ai,1
"в алгоритме перебора вширь вершины раскрываются в том порядке, в котором они строятся.",алгоритме перебора,ai,1
"описываемые алгоритмы используют списки open и closed, состоящие соответственно из раскрытых и нераскрытых вершин пространства состояний.",нераскрытых вершин,ai,1
"описываемые алгоритмы используют списки open и closed, состоящие соответственно из раскрытых и нераскрытых вершин пространства состояний.",пространства состояний,ai,1
2.2.1 поиск вширь базовый алгоритм поиска вширь состоит из следующей последова тельности шагов: шаг 1.,алгоритм поиска,ai,1
поместить начальную вершину в список нераскрытых вершин open.,нераскрытых вершин,ai,1
выбрать первую вершину из списка open (назовем ее current) и перенести ее в список раскрытых вершин closed.,раскрытых вершин,ai,1
"раскрыть вершину current, образовав все ее дочерние вершины.",раскрыть вершину,ai,1
"если есть хотя бы одна целевая вершина, то завершить поиск и выдать решение задачи, получающееся просмотром указателей назад от найденной целевой вершины к начальной.",целевая вершина,ai,1
"если есть хотя бы одна целевая вершина, то завершить поиск и выдать решение задачи, получающееся просмотром указателей назад от найденной целевой вершины к начальной.",целевой вершины,ai,1
"основу этого алгоритма составляет цикл последовательного раскрытия (шаги 2-5) концевых вершин (листьев) дерева перебора, хранящихся в списке open.",дерева перебора,ai,1
"основу этого алгоритма составляет цикл последовательного раскрытия (шаги 2-5) концевых вершин (листьев) дерева перебора, хранящихся в списке open.",концевых вершин,ai,1
описанный алгоритм поиска вширь является полным.,алгоритм поиска,ai,1
"можно также показать, что при переборе вширь непременно будет найден самый короткий путь к целевой вершине при условии, что этот путь вообще существует.",целевой вершине,ai,1
"если же решающего пути нет, то в случае конечного пространства состояний алгоритм завершит работу (с сообщением о неудаче поиска), в случае же бесконечного пространства алгоритм не остановится.",пространства состояний,ai,1
"если же решающего пути нет, то в случае конечного пространства состояний алгоритм завершит работу (с сообщением о неудаче поиска), в случае же бесконечного пространства алгоритм не остановится.",решающего пути,ai,1
"поиск вширь для игры в восемь на рис.13 показана часть дерева, построенного в результате применения алгоритма поиска вширь к некоторой начальной конфигурации игры в восемь, причем выполнение алгоритма прервано после построения первых 12 вершин (при этом раскрыто 6 вершин).",алгоритма поиска,ai,1
в вершинах дерева помещены соответствующие описания состояний.,описания состояний,ai,1
"на следующем шаге цикла алгоритма будет раскрываться одна из вершин с номерами 6, 7 или 8, поскольку они расположены в начале списка нераскрытых вершин.",нераскрытых вершин,ai,1
"предполагается также, что используемая алгоритмом операция раскрытия вершин организована таким образом, что она не порождает никакое состояние, идентичное состоянию в уже построенной вершине, являющейся родительской для раскрываемой вершины.",раскрытия вершин,ai,1
"в приведенном примере алгоритм поиска вглубь, сформулированный для пространств, являющихся деревьями, применялся к пространству состояний, являющемуся графом (в котором могут быть циклы).",пространству состояний,ai,1
"в приведенном примере алгоритм поиска вглубь, сформулированный для пространств, являющихся деревьями, применялся к пространству состояний, являющемуся графом (в котором могут быть циклы).",алгоритм поиска,ai,1
"причем и при поиске в пространствах-деревьях, и при поиске в пространствах-графах, построенная алгоритмом структура из вершин и указателей всегда образует дерево (дерево перебора), поскольку указатели от дочерних вершин ссылаются только на одну порождающую вершину.",дерево перебора,ai,1
но в случае поиска на произвольном графе (и в этом отличие от деревьев-пространств) одно и тоже состояние может быть продублировано в разных частях построенного дерева поиска: граф как бы разворачивается в дерево путем дублирования некоторых его частей.,дерева поиска,ai,1
"например, по принятому предположению об операции раскрытия в игре в восемь исключалось только повторное возникновение состояний, уже встречавшихся два шага вверх по дереву перебора, другие же, более далекие друг от друга повторы одного и того же состояния остаются возможными.",дереву перебора,ai,1
"в общем случае, вследствие многократного дублирования вершин (из-за циклов в графе) возможно зацикливание базового алгоритма поиска вширь.",алгоритма поиска,ai,1
2.2.2 поиск вглубь для формулировки алгоритма поиска вглубь необходимо определить понятие глубины вершины в дереве поиска.,алгоритма поиска,ai,1
"в алгоритме перебора вглубь раскрытию в первую очередь подлежит вершина, имеющая наибольшую глубину.",алгоритме перебора,ai,1
"такой принцип может привести к не завершающемуся процессу это происходит, если пространство состояний бесконечно, и поиск вглубь пошел по бесконечной ветви дерева, не содержащей целевой вершины.",пространство состояний,ai,1
"такой принцип может привести к не завершающемуся процессу это происходит, если пространство состояний бесконечно, и поиск вглубь пошел по бесконечной ветви дерева, не содержащей целевой вершины.",целевой вершины,ai,1
соответствующий алгоритм поиска называется ограниченным поиском вглубь.,ограниченным поиском,ai,1
соответствующий алгоритм поиска называется ограниченным поиском вглубь.,алгоритм поиска,ai,1
основные шаги базового алгоритма ограниченного поиска вглубь (с граничной глубиной d) таковы: шаг 1.,ограниченного поиска,ai,1
"раскрыть вершину current, построив все ее дочерние вершины.",раскрыть вершину,ai,1
"если среди дочерних есть хотя бы одна целевая вершина, то завершить поиск и выдать решение задачи, получающееся просмотром назад указателей от найденной целевой вершины к начальной.",целевая вершина,ai,1
"если среди дочерних есть хотя бы одна целевая вершина, то завершить поиск и выдать решение задачи, получающееся просмотром назад указателей от найденной целевой вершины к начальной.",целевой вершины,ai,1
"приведенное описание очень похоже на описание алгоритма поиска вширь, разница заключается только в ограничении глубины (шаг 4) и в участке списка open, куда помещаются построенные дочерние вершины (шаг 5).",алгоритма поиска,ai,1
"поскольку глубина поиска ограничена, то будучи примененным к деревьям-пространствам состояний, описанный базовый алгоритм поиска вглубь всегда заканчивает работу.",пространствам состояний,ai,1
"поскольку глубина поиска ограничена, то будучи примененным к деревьям-пространствам состояний, описанный базовый алгоритм поиска вглубь всегда заканчивает работу.",глубина поиска,ai,1
"поскольку глубина поиска ограничена, то будучи примененным к деревьям-пространствам состояний, описанный базовый алгоритм поиска вглубь всегда заканчивает работу.",алгоритм поиска,ai,1
"в отличие от алгоритма поиска вширь, он осуществляет неполный поиск, поскольку целевая вершина может располагаться ниже граничной глубины (в таком случае она не будет обнаружена).",целевая вершина,ai,1
"в отличие от алгоритма поиска вширь, он осуществляет неполный поиск, поскольку целевая вершина может располагаться ниже граничной глубины (в таком случае она не будет обнаружена).",алгоритма поиска,ai,1
"на рис.14 показана часть дерева перебора, построенного алгоритмом поиска вглубь при граничной глубине равной 4.",дерева перебора,ai,1
"на рис.14 показана часть дерева перебора, построенного алгоритмом поиска вглубь при граничной глубине равной 4.",алгоритмом поиска,ai,1
"как нетрудно убедиться, сравнивая два указанных рисунка, алгоритмами поиска вширь и вглубь построены разные деревья поиска.",алгоритмами поиска,ai,1
"как нетрудно убедиться, сравнивая два указанных рисунка, алгоритмами поиска вширь и вглубь построены разные деревья поиска.",деревья поиска,ai,1
"видно, что в алгоритме поиска в глубину сначала идет поиск вдоль одного пути, пока не будет достигнута установленная граничная глубина, затем рассматриваются альтернативные пути той же или меньшей глубины, которые отличаются от первого пути лишь последней (концевой) вершиной, после чего рассматриваются пути, отличающиеся последними двумя вершинами, и т.д. рис.14.",алгоритме поиска,ai,1
"поиск вглубь для игры в восемь 2.2.3 слепой перебор и бектрекинг если продолжить выполнение алгоритмов перебора вширь и вглубь для рассмотренного на рис.13 и 14 начального состояния игры в восемь, с целью поиска конфигурации, заданной на рис.1(б), то она будет найдена на глубине 5, при этом алгоритмом поиска вширь будет раскрыто 26 и построено 46 вершин, а алгоритмом поиска вглубь соответственно 18 и 35 вершин (см. [нильсон73, раздел 3.2] или [нильсон85, раздел 2.4]).",бектрекинг,ai,1
"поиск вглубь для игры в восемь 2.2.3 слепой перебор и бектрекинг если продолжить выполнение алгоритмов перебора вширь и вглубь для рассмотренного на рис.13 и 14 начального состояния игры в восемь, с целью поиска конфигурации, заданной на рис.1(б), то она будет найдена на глубине 5, при этом алгоритмом поиска вширь будет раскрыто 26 и построено 46 вершин, а алгоритмом поиска вглубь соответственно 18 и 35 вершин (см. [нильсон73, раздел 3.2] или [нильсон85, раздел 2.4]).",слепой перебор,ai,1
"поиск вглубь для игры в восемь 2.2.3 слепой перебор и бектрекинг если продолжить выполнение алгоритмов перебора вширь и вглубь для рассмотренного на рис.13 и 14 начального состояния игры в восемь, с целью поиска конфигурации, заданной на рис.1(б), то она будет найдена на глубине 5, при этом алгоритмом поиска вширь будет раскрыто 26 и построено 46 вершин, а алгоритмом поиска вглубь соответственно 18 и 35 вершин (см. [нильсон73, раздел 3.2] или [нильсон85, раздел 2.4]).",алгоритмов перебора,ai,1
"поиск вглубь для игры в восемь 2.2.3 слепой перебор и бектрекинг если продолжить выполнение алгоритмов перебора вширь и вглубь для рассмотренного на рис.13 и 14 начального состояния игры в восемь, с целью поиска конфигурации, заданной на рис.1(б), то она будет найдена на глубине 5, при этом алгоритмом поиска вширь будет раскрыто 26 и построено 46 вершин, а алгоритмом поиска вглубь соответственно 18 и 35 вершин (см. [нильсон73, раздел 3.2] или [нильсон85, раздел 2.4]).",алгоритмом поиска,ai,1
"в целом, алгоритмы поиска вширь и вглубь сравнимы по эффективности (в частности, по количеству построенных вершин).",алгоритмы поиска,ai,1
"в то же время алгоритм поиска вглубь может оказаться предпочтительнее в тех случаях, когда он начат с ветви дерева, содержащей целевое состояние, решение задачи будет обнаружено раньше, чем при поиске вширь.",целевое состояние,ai,1
"в то же время алгоритм поиска вглубь может оказаться предпочтительнее в тех случаях, когда он начат с ветви дерева, содержащей целевое состояние, решение задачи будет обнаружено раньше, чем при поиске вширь.",алгоритм поиска,ai,1
"подчеркнем, что, также как и при переборе вширь, при переборе вглубь формируется именно дерево, а не граф поиска, даже если пространство состояний представлялось графом с циклами.",граф поиска,ai,1
"подчеркнем, что, также как и при переборе вширь, при переборе вглубь формируется именно дерево, а не граф поиска, даже если пространство состояний представлялось графом с циклами.",пространство состояний,ai,1
"в последнем случае, однако, дерево перебора может содержать дубликаты состояний и возможно зацикливание алгоритма.",дерево перебора,ai,1
"чтобы избежать такого дублирования вершин в случае перебора на графах общего вида, необходимо внести некоторые очевидные изменения в описанные базовые алгоритмы поиска вширь и вглубь.",алгоритмы поиска,ai,1
"в алгоритме перебора вширь следует дополнительно проверять, не находится ли каждая вновь построенная вершина (точнее, соответствующее описание состояния) в списках open и closed по той причине, что она уже строилась раньше в результате раскрытия какой-то другой вершины.",алгоритме перебора,ai,1
"в алгоритме перебора вширь следует дополнительно проверять, не находится ли каждая вновь построенная вершина (точнее, соответствующее описание состояния) в списках open и closed по той причине, что она уже строилась раньше в результате раскрытия какой-то другой вершины.",описание состояния,ai,1
"если это так, то такую вершину не надо снова помещать в список open (таким образом, разрывается цикл графа-пространства и обрывается соответствующая ветвь дерева перебора).",дерева перебора,ai,1
"в алгоритме же ограниченного поиска вглубь, кроме указанной проверки, может оказаться необходимым пересчет глубины порожденной дочерней вершины, уже имеющейся либо в списке open, либо в списке closed.",ограниченного поиска,ai,1
"усовершенствованный таким образом алгоритм поиска вширь всегда завершит работу в случае существования решения, а усовершенствованный алгоритм поиска вглубь закончится в любом случае, независимо от существования решения.",алгоритм поиска,ai,1
"немаловажно, что алгоритмы слепого перебора описаны нами в форме, пригодной для их программирования с использованием любого языка, не только языка программирования задач искусственного интеллекта.",алгоритмы слепого перебора,ai,1
"немаловажно, что алгоритмы слепого перебора описаны нами в форме, пригодной для их программирования с использованием любого языка, не только языка программирования задач искусственного интеллекта.",слепого перебора,ai,1
"алгоритм поиска вглубь демонстрирует также способ решения поисковых задач, называемый бектрекингом (backtracking).",бектрекингом,ai,1
"алгоритм поиска вглубь демонстрирует также способ решения поисковых задач, называемый бектрекингом (backtracking).",алгоритм поиска,ai,1
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",бектрекинга,ai,1
"в общем случае в процессе решения возможно возникновение многих подобных точек выбора, называемых обычно точками бектрекинга или развилками; к каждой из таких точек может потребоваться возврат для выбора других вариантов решения.",точками бектрекинга,ai,1
"в общем случае в процессе решения возможно возникновение многих подобных точек выбора, называемых обычно точками бектрекинга или развилками; к каждой из таких точек может потребоваться возврат для выбора других вариантов решения.",бектрекинга,ai,1
в базовом алгоритме поиска вглубь по существу проводится бектрекинг.,бектрекинг,ai,1
в базовом алгоритме поиска вглубь по существу проводится бектрекинг.,алгоритме поиска,ai,1
"действительно, запоминание всех альтернатив продолжения поиска (нераскрытых вершин) осуществляется в списке open, на шаге 3 производится выбор варианта-альтернативы, а возврат к этому шагу для выбора следующей альтернативы осуществляется на шагах 4 и 5.",нераскрытых вершин,ai,1
"некоторые языки для задач искусственного интеллекта, как, например, пролог [братко] и плэнер [пильщиков] имеют специальный встроенный механизм для реализации бектрекинга.",бектрекинга,ai,1
"это означает, что запоминание точек бектрекинга самих альтернатив и связанной с ними информации, а также реализация возвратов к нужным точкам (с восстановлением всей операционной обстановки в этой точке) возложены на интерпретатор языка, т.е. делается автоматически.",бектрекинга,ai,1
"это означает, что запоминание точек бектрекинга самих альтернатив и связанной с ними информации, а также реализация возвратов к нужным точкам (с восстановлением всей операционной обстановки в этой точке) возложены на интерпретатор языка, т.е. делается автоматически.",точек бектрекинга,ai,1
от программиста требуется лишь определение точек бектрекинга с нужными альтернативами и инициация в необходимый момент процесса возврата.,бектрекинга,ai,1
от программиста требуется лишь определение точек бектрекинга с нужными альтернативами и инициация в необходимый момент процесса возврата.,точек бектрекинга,ai,1
"заметим попутно, что язык плэнер, по сравнению с прологом, предлагает более гибкие средства управления бектрекингом, краткое описание этих средств находится в разделе 4.2 пособия.",бектрекингом,ai,1
"встроенный механизм бектрекинга позволяет упростить разработку поисковой программы, укорачивая ее текст это демонстрирует приведенная в разделе 2.4 плэнерская функция deрth first search, реализующая поиск вглубь (без ограничения глубины).",механизм бектрекинга,ai,1
"встроенный механизм бектрекинга позволяет упростить разработку поисковой программы, укорачивая ее текст это демонстрирует приведенная в разделе 2.4 плэнерская функция deрth first search, реализующая поиск вглубь (без ограничения глубины).",бектрекинга,ai,1
"в целом алгоритмы слепого перебора являются неэффективными методами поиска решения, и в случае нетривиальных задач их невозможно использовать из-за большого числа порождаемых вершин.",алгоритмы слепого перебора,ai,1
"в целом алгоритмы слепого перебора являются неэффективными методами поиска решения, и в случае нетривиальных задач их невозможно использовать из-за большого числа порождаемых вершин.",слепого перебора,ai,1
"действительно, если l длина решающего пути, а b количество ветвей (дочерних вершин) у каждой вершины, то в общем случае для нахождения решения надо исследовать bl путей, ведущих из начальной вершины.",решающего пути,ai,1
"эта величина растет экспоненциально с ростом длины решающего пути, что приводит к ситуации, называемой комбинаторным взрывом.",решающего пути,ai,1
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",пространства состояний,ai,1
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",эвристический поиск,ai,1
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",нераскрытых вершин,ai,1
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",эвристического поиска,ai,1
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",эвристической информации,ai,1
самый распространенный способ использования эвристической информации введение так называемой эвристической оценочной функции.,эвристической оценочной функции,ai,1
самый распространенный способ использования эвристической информации введение так называемой эвристической оценочной функции.,оценочной функции,ai,1
самый распространенный способ использования эвристической информации введение так называемой эвристической оценочной функции.,эвристической информации,ai,1
эта функция определяется на множестве вершин пространства состояний и принимает числовые значения.,пространства состояний,ai,1
значение эвристической оценочной функции est(v) может интерпретироваться как перспективность раскрытия вершины (иногда как вероятность ее расположения на решающем пути).,эвристической оценочной функции,ai,1
значение эвристической оценочной функции est(v) может интерпретироваться как перспективность раскрытия вершины (иногда как вероятность ее расположения на решающем пути).,раскрытия вершины,ai,1
значение эвристической оценочной функции est(v) может интерпретироваться как перспективность раскрытия вершины (иногда как вероятность ее расположения на решающем пути).,оценочной функции,ai,1
"обычно считают, что меньшее значение est(v) соответствует более перспективной вершине, и вершины раскрываются в порядке увеличения (точнее, неубывания) значения оценочной функции.",оценочной функции,ai,1
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",оценочной функции,ai,1
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",алгоритм эвристического поиска,ai,1
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",эвристической оценочной функции,ai,1
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",слепого перебора,ai,1
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",алгоритмов слепого перебора,ai,1
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",эвристического поиска,ai,1
в цикле каждый раз для раскрытия выбирается наиболее перспективная концевая вершина дерева перебора.,дерева перебора,ai,1
в цикле каждый раз для раскрытия выбирается наиболее перспективная концевая вершина дерева перебора.,концевая вершина,ai,1
"как и в случае алгоритмов слепого поиска, множество порождаемых алгоритмом вершин и указателей образует дерево, в листьях которого находятся нераскрытые вершины.",нераскрытые вершины,ai,1
"как и в случае алгоритмов слепого поиска, множество порождаемых алгоритмом вершин и указателей образует дерево, в листьях которого находятся нераскрытые вершины.",слепого поиска,ai,1
"предполагаем, что исследуемое алгоритмом пространство состояний представляет собой дерево.",пространство состояний,ai,1
укажем основные шаги базового алгоритма эвристического поиска (best first search): шаг 1.,алгоритма эвристического поиска,ai,1
укажем основные шаги базового алгоритма эвристического поиска (best first search): шаг 1.,эвристического поиска,ai,1
поместить начальную вершину в список нераскрытых вершин open и вычислить ее оценку.,нераскрытых вершин,ai,1
"если current целевая вершина, то завершить поиск и выдать решение задачи, получающееся просмотром указателей от нее к начальной вершине, в противном случае перейти к шагу 5.",целевая вершина,ai,1
"для каждой дочерней вершины вычислить оценку (значение оценочной функции), поместить все дочерние вершины в список open и построить указатели, ведущие от этих вершин к родительской вершине current.",оценочной функции,ai,1
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",нераскрытых вершин,ai,1
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",оценочной функцией,ai,1
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",эвристического поиска,ai,1
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",пространствах состояний,ai,1
"в принципе, эвристическая оценочная функция может зависеть не только от внутренних свойств оцениваемого состояния (т.е. свойств входящих в описание состояния элементов), но и от характеристик всего пространства состояний, например, от глубины местонахождения оцениваемой вершины в дереве перебора или других свойств пути к этой вершине.",оценочная функция,ai,1
"в принципе, эвристическая оценочная функция может зависеть не только от внутренних свойств оцениваемого состояния (т.е. свойств входящих в описание состояния элементов), но и от характеристик всего пространства состояний, например, от глубины местонахождения оцениваемой вершины в дереве перебора или других свойств пути к этой вершине.",эвристическая оценочная функция,ai,1
"в принципе, эвристическая оценочная функция может зависеть не только от внутренних свойств оцениваемого состояния (т.е. свойств входящих в описание состояния элементов), но и от характеристик всего пространства состояний, например, от глубины местонахождения оцениваемой вершины в дереве перебора или других свойств пути к этой вершине.",пространства состояний,ai,1
"в принципе, эвристическая оценочная функция может зависеть не только от внутренних свойств оцениваемого состояния (т.е. свойств входящих в описание состояния элементов), но и от характеристик всего пространства состояний, например, от глубины местонахождения оцениваемой вершины в дереве перебора или других свойств пути к этой вершине.",описание состояния,ai,1
"поэтому значение оценочной функции для вновь построенной дочерней вершины, входящей в список open или closed, может понизиться, и надо скорректировать старую оценку вершины, заменив ее на новую, меньшую.",оценочной функции,ai,1
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",оценочная функция,ai,1
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",алгоритмах поиска,ai,1
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",вершин-состояний,ai,1
"проиллюстрируем работу алгоритма эвристического поиска опять же на примере игры в восемь (для той же начальной ситуации, что на рис.",алгоритма эвристического поиска,ai,1
"проиллюстрируем работу алгоритма эвристического поиска опять же на примере игры в восемь (для той же начальной ситуации, что на рис.",эвристического поиска,ai,1
"13 и 14, и целевого состояния, указанного на рис.1(б)).",целевого состояния,ai,1
"число фишек позиции-вершины v, стоящих не на своем месте (фишка стоит не на своем месте, если ее позиция отлична от позиции в целевом состоянии).",целевом состоянии,ai,1
"15 показано дерево, построенное алгоритмом эвристического перебора с использованием указанной оценочной функции.",эвристического перебора,ai,1
"15 показано дерево, построенное алгоритмом эвристического перебора с использованием указанной оценочной функции.",оценочной функции,ai,1
"15 показано дерево, построенное алгоритмом эвристического перебора с использованием указанной оценочной функции.",алгоритмом эвристического перебора,ai,1
"двойной рамкой обведена найденная целевая вершина, она построена двенадцатой.",целевая вершина,ai,1
"видно, что поскольку каждый раз выбор вершины с минимальной оценкой производится внутри всего построенного к текущему моменту дерева перебора, то раскрываемые друг за другом вершины могут располагаться в отдаленных друг от друга частях дерева.",дерева перебора,ai,1
"применяемая оценочная функция такова, что при прочих равных преимущество имеет менее глубокая вершина.",оценочная функция,ai,1
"решение задачи длиною в пять ходов найдено в результате раскрытия 6 и построения 13 вершин это существенно меньше, чем при использовании слепого перебора (соответствующие числа были: для поиска вширь 26 и 46 вершин, для поиска вглубь 18 и 35 вершин).",слепого перебора,ai,1
"таким образом, использование эвристической информации приводит к существенному сокращению перебора.",эвристической информации,ai,1
"эффективность алгоритмов поиска может быть оценена при помощи такого показателя, как целенаправленность.",алгоритмов поиска,ai,1
"он вычисляется по формуле p = l / n , где l длина найденного пути до цели (она равна глубине целевой вершины); n общее число вершин, построенных в ходе перебора.",целевой вершины,ai,1
"легко заметить, что p=1, если строятся только вершины решающего пути, а в остальных случаях p<1.",решающего пути,ai,1
"для рассмотренных примеров работы алгоритмов для игры в восемь этот показатель равен соответственно: эвристический поиск 5/13, поиск вширь 5/46, поиск вглубь 5/35, ясно, что алгоритм эвристического поиска с хорошо подобранной оценочной функцией находит решение задачи быстрее алгоритмов слепого перебора.",алгоритм эвристического поиска,ai,1
"для рассмотренных примеров работы алгоритмов для игры в восемь этот показатель равен соответственно: эвристический поиск 5/13, поиск вширь 5/46, поиск вглубь 5/35, ясно, что алгоритм эвристического поиска с хорошо подобранной оценочной функцией находит решение задачи быстрее алгоритмов слепого перебора.",слепого перебора,ai,1
"для рассмотренных примеров работы алгоритмов для игры в восемь этот показатель равен соответственно: эвристический поиск 5/13, поиск вширь 5/46, поиск вглубь 5/35, ясно, что алгоритм эвристического поиска с хорошо подобранной оценочной функцией находит решение задачи быстрее алгоритмов слепого перебора.",эвристический поиск,ai,1
"для рассмотренных примеров работы алгоритмов для игры в восемь этот показатель равен соответственно: эвристический поиск 5/13, поиск вширь 5/46, поиск вглубь 5/35, ясно, что алгоритм эвристического поиска с хорошо подобранной оценочной функцией находит решение задачи быстрее алгоритмов слепого перебора.",алгоритмов слепого перебора,ai,1
"для рассмотренных примеров работы алгоритмов для игры в восемь этот показатель равен соответственно: эвристический поиск 5/13, поиск вширь 5/46, поиск вглубь 5/35, ясно, что алгоритм эвристического поиска с хорошо подобранной оценочной функцией находит решение задачи быстрее алгоритмов слепого перебора.",оценочной функцией,ai,1
"для рассмотренных примеров работы алгоритмов для игры в восемь этот показатель равен соответственно: эвристический поиск 5/13, поиск вширь 5/46, поиск вглубь 5/35, ясно, что алгоритм эвристического поиска с хорошо подобранной оценочной функцией находит решение задачи быстрее алгоритмов слепого перебора.",эвристического поиска,ai,1
"однако подбор удачной эвристической функции, существенно сокращающей поиск, наиболее трудный момент при формализации задачи, часто подходящая оценочная функция выявляется только экспериментально.",оценочная функция,ai,1
"однако подбор удачной эвристической функции, существенно сокращающей поиск, наиболее трудный момент при формализации задачи, часто подходящая оценочная функция выявляется только экспериментально.",эвристической функции,ai,1
"эвристический поиск для игры в восемь в одной и той же задаче можно сравнивать различные оценочные функции по их эвристической силе, т.е. по тому, насколько они убыстряют поиск, делают его эффективным.",оценочные функции,ai,1
"эвристический поиск для игры в восемь в одной и той же задаче можно сравнивать различные оценочные функции по их эвристической силе, т.е. по тому, насколько они убыстряют поиск, делают его эффективным.",эвристический поиск,ai,1
"эвристический поиск для игры в восемь в одной и той же задаче можно сравнивать различные оценочные функции по их эвристической силе, т.е. по тому, насколько они убыстряют поиск, делают его эффективным.",эвристической силе,ai,1
"заметим, что эвристическая сила функции должна учитывать общий объем вычислительных затрат при поиске, поэтому кроме числа раскрытых и построенных вершин важен и такой показатель, как сложность вычисления самой оценочной функции.",эвристическая сила,ai,1
"заметим, что эвристическая сила функции должна учитывать общий объем вычислительных затрат при поиске, поэтому кроме числа раскрытых и построенных вершин важен и такой показатель, как сложность вычисления самой оценочной функции.",оценочной функции,ai,1
для игры в восемь можно предложить еще одну эвристическую функцию: est2(v) = d(v) + s(v) .,эвристическую функцию,ai,1
"второе слагаемое получается подсчетом для каждой из восьми фишек суммы двух расстояний по вертикали и горизонтали между клетками, где находится фишка в оцениваемом и целевом состояниях, а затем вычислением общей суммы s(v)",целевом состояниях,ai,1
"интуитивно ясно, и это можно показать на примерах, что новая эвристическая функция имеет большую эвристическую силу, т.е. более эффективно направляет поиск к цели.",эвристическая функция,ai,1
"интуитивно ясно, и это можно показать на примерах, что новая эвристическая функция имеет большую эвристическую силу, т.е. более эффективно направляет поиск к цели.",эвристическую силу,ai,1
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",алгоритма эвристического поиска,ai,1
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",алгоритм эвристического перебора,ai,1
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",оценочной функций,ai,1
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",алгоритм поиска,ai,1
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",решающего пути,ai,1
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",эвристического поиска,ai,1
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",эвристического перебора,ai,1
"понятно, что такой уверенности нет, прежде всего, для задач с бесконечными пространствами состояний.",пространствами состояний,ai,1
"вообще же, нередка ситуация, когда эвристика, сильно сокращающая перебор для одних задач (начальных и целевых состояний), в то же время для других задач либо не уменьшает перебор (решение задачи может искаться даже дольше, чем с использованием слепого поиска), либо вовсе не обеспечивает обнаружение решающего пути.",слепого поиска,ai,1
"вообще же, нередка ситуация, когда эвристика, сильно сокращающая перебор для одних задач (начальных и целевых состояний), в то же время для других задач либо не уменьшает перебор (решение задачи может искаться даже дольше, чем с использованием слепого поиска), либо вовсе не обеспечивает обнаружение решающего пути.",решающего пути,ai,1
"вообще же, нередка ситуация, когда эвристика, сильно сокращающая перебор для одних задач (начальных и целевых состояний), в то же время для других задач либо не уменьшает перебор (решение задачи может искаться даже дольше, чем с использованием слепого поиска), либо вовсе не обеспечивает обнаружение решающего пути.",целевых состояний,ai,1
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",алгоритма эвристического поиска,ai,1
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",оценочных функций,ai,1
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",эвристических оценочных функций,ai,1
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",целевой вершины,ai,1
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",решающего пути,ai,1
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",эвристического поиска,ai,1
"предположим, что на множестве дуг пространства состояний определена функция стоимости: с(va, vb) стоимость дуги-перехода от вершины va к вершине vb .",пространства состояний,ai,1
"пусть целью поиска будет не просто нахождение решающего пути, а нахождение оптимального решающего пути решающего пути с минимальной стоимостью.",решающего пути,ai,1
"предположим также, что эвристическая оценочная функция est(v) построена таким образом, чтобы оценивать стоимость оптимального решающего пути, идущего из начальной вершины к одной из целевой вершин, при условии, что этот путь проходит через вершину v. тогда значение оценочной функции можно представить в виде суммы двух слагаемых: est(v) = g(v) + h(v) ( ) где g(v) оценка оптимального пути от начальной вершины до вершины v, h(v) оценка оптимального пути от вершины v до целевой вершины.",оценочной функции,ai,1
"предположим также, что эвристическая оценочная функция est(v) построена таким образом, чтобы оценивать стоимость оптимального решающего пути, идущего из начальной вершины к одной из целевой вершин, при условии, что этот путь проходит через вершину v. тогда значение оценочной функции можно представить в виде суммы двух слагаемых: est(v) = g(v) + h(v) ( ) где g(v) оценка оптимального пути от начальной вершины до вершины v, h(v) оценка оптимального пути от вершины v до целевой вершины.",целевой вершины,ai,1
"предположим также, что эвристическая оценочная функция est(v) построена таким образом, чтобы оценивать стоимость оптимального решающего пути, идущего из начальной вершины к одной из целевой вершин, при условии, что этот путь проходит через вершину v. тогда значение оценочной функции можно представить в виде суммы двух слагаемых: est(v) = g(v) + h(v) ( ) где g(v) оценка оптимального пути от начальной вершины до вершины v, h(v) оценка оптимального пути от вершины v до целевой вершины.",оценочная функция,ai,1
"предположим также, что эвристическая оценочная функция est(v) построена таким образом, чтобы оценивать стоимость оптимального решающего пути, идущего из начальной вершины к одной из целевой вершин, при условии, что этот путь проходит через вершину v. тогда значение оценочной функции можно представить в виде суммы двух слагаемых: est(v) = g(v) + h(v) ( ) где g(v) оценка оптимального пути от начальной вершины до вершины v, h(v) оценка оптимального пути от вершины v до целевой вершины.",эвристическая оценочная функция,ai,1
"предположим также, что эвристическая оценочная функция est(v) построена таким образом, чтобы оценивать стоимость оптимального решающего пути, идущего из начальной вершины к одной из целевой вершин, при условии, что этот путь проходит через вершину v. тогда значение оценочной функции можно представить в виде суммы двух слагаемых: est(v) = g(v) + h(v) ( ) где g(v) оценка оптимального пути от начальной вершины до вершины v, h(v) оценка оптимального пути от вершины v до целевой вершины.",решающего пути,ai,1
"предположим также, что эвристическая оценочная функция est(v) построена таким образом, чтобы оценивать стоимость оптимального решающего пути, идущего из начальной вершины к одной из целевой вершин, при условии, что этот путь проходит через вершину v. тогда значение оценочной функции можно представить в виде суммы двух слагаемых: est(v) = g(v) + h(v) ( ) где g(v) оценка оптимального пути от начальной вершины до вершины v, h(v) оценка оптимального пути от вершины v до целевой вершины.",целевой вершин,ai,1
"найденный путь не обязательно оптимален (возможно, существует более дешевый, еще не найденный путь из начальной вершины в v), однако стоимость найденного пути может быть использована в качестве оценки искомого пути минимальной стоимости из начальной вершины до v, т.е. в качестве первого слагаемого g(v) эвристической функции.",эвристической функции,ai,1
"таким образом, собственно эвристическая информация будет воплощена только во втором слагаемом оценочной функции.",эвристическая информация,ai,1
"таким образом, собственно эвристическая информация будет воплощена только во втором слагаемом оценочной функции.",оценочной функции,ai,1
"разновидность алгоритма эвристического поиска, применяемого для поиска оптимального решающего пути и использующего при этом оценочную функцию указанного выше вида ( ), известна в литературе как а-алгоритм [нильсон85, раздел 2.4].",алгоритма эвристического поиска,ai,1
"разновидность алгоритма эвристического поиска, применяемого для поиска оптимального решающего пути и использующего при этом оценочную функцию указанного выше вида ( ), известна в литературе как а-алгоритм [нильсон85, раздел 2.4].",а-алгоритм,ai,1
"разновидность алгоритма эвристического поиска, применяемого для поиска оптимального решающего пути и использующего при этом оценочную функцию указанного выше вида ( ), известна в литературе как а-алгоритм [нильсон85, раздел 2.4].",решающего пути,ai,1
"разновидность алгоритма эвристического поиска, применяемого для поиска оптимального решающего пути и использующего при этом оценочную функцию указанного выше вида ( ), известна в литературе как а-алгоритм [нильсон85, раздел 2.4].",оценочную функцию,ai,1
"разновидность алгоритма эвристического поиска, применяемого для поиска оптимального решающего пути и использующего при этом оценочную функцию указанного выше вида ( ), известна в литературе как а-алгоритм [нильсон85, раздел 2.4].",эвристического поиска,ai,1
"алгоритм перебора называют допустимым (или состоятельным), если для произвольного графа он всегда заканчивает свою работу построением оптимального пути к цели, при условии, что такой путь существует.",алгоритм перебора,ai,1
пусть h (v) стоимость оптимального пути из произвольной вершины v в целевую вершину.,целевую вершину,ai,1
пусть h (v) стоимость оптимального пути из произвольной вершины v в целевую вершину.,стоимость оптимального пути,ai,1
"верна следующая теорема о допустимости а-алгоритма: а-алгоритм, использующий некоторую эвристическую функцию вида ( ), где g(v)",эвристическую функцию,ai,1
"верна следующая теорема о допустимости а-алгоритма: а-алгоритм, использующий некоторую эвристическую функцию вида ( ), где g(v)",допустимости а-алгоритма,ai,1
"верна следующая теорема о допустимости а-алгоритма: а-алгоритм, использующий некоторую эвристическую функцию вида ( ), где g(v)",а-алгоритма,ai,1
"верна следующая теорема о допустимости а-алгоритма: а-алгоритм, использующий некоторую эвристическую функцию вида ( ), где g(v)",а-алгоритм,ai,1
"стоимость пути от начальной вершины до вершины v в дереве перебора, а h(v) эвристическая оценка оптимального пути из вершины v в целевую вершину, является допустимым, если h(v) h (v) для всех вершин v пространства состояний.",целевую вершину,ai,1
"стоимость пути от начальной вершины до вершины v в дереве перебора, а h(v) эвристическая оценка оптимального пути из вершины v в целевую вершину, является допустимым, если h(v) h (v) для всех вершин v пространства состояний.",пространства состояний,ai,1
"стоимость пути от начальной вершины до вершины v в дереве перебора, а h(v) эвристическая оценка оптимального пути из вершины v в целевую вершину, является допустимым, если h(v) h (v) для всех вершин v пространства состояний.",эвристическая оценка,ai,1
"а-алгоритм эвристического поиска с функцией h(v), удовлетворяющей этому условию, получил название а -алгоритма [нильсон73, разделы 3.7-3.9; лорьер, раздел 5.6].",а-алгоритм,ai,1
"а-алгоритм эвристического поиска с функцией h(v), удовлетворяющей этому условию, получил название а -алгоритма [нильсон73, разделы 3.7-3.9; лорьер, раздел 5.6].",эвристического поиска,ai,1
"а-алгоритм эвристического поиска с функцией h(v), удовлетворяющей этому условию, получил название а -алгоритма [нильсон73, разделы 3.7-3.9; лорьер, раздел 5.6].",алгоритм эвристического поиска,ai,1
"если взять тривиальную нижнюю грань, т.е. установить h(v)=0 для всех вершин пространства состояний, то допустимость будет обеспечена.",пространства состояний,ai,1
"однако этот случай соответствует полному отсутствию какой-нибудь эвристической информации о задаче, и оценочная функция est не имеет никакой эвристической силы, т.е. не сокращает возникающий перебор.",оценочная функция,ai,1
"однако этот случай соответствует полному отсутствию какой-нибудь эвристической информации о задаче, и оценочная функция est не имеет никакой эвристической силы, т.е. не сокращает возникающий перебор.",эвристической силы,ai,1
"однако этот случай соответствует полному отсутствию какой-нибудь эвристической информации о задаче, и оценочная функция est не имеет никакой эвристической силы, т.е. не сокращает возникающий перебор.",эвристической информации,ai,1
", где g(v) стоимость пути от начальной вершины до вершины v, мы получаем алгоритм, известный как алгоритм равных цен.",алгоритм равных цен,ai,1
"алгоритм равных цен представляет собой более общий вариант метода перебора вширь, при котором вершины раскрываются в порядке возрастания стоимости g(v), т.е. в первую очередь раскрывается вершина из списка нераскрытых вершин, для которой величина g имеет наименьшее значение.",нераскрытых вершин,ai,1
"алгоритм равных цен представляет собой более общий вариант метода перебора вширь, при котором вершины раскрываются в порядке возрастания стоимости g(v), т.е. в первую очередь раскрывается вершина из списка нераскрытых вершин, для которой величина g имеет наименьшее значение.",алгоритм равных цен,ai,1
"если же, кроме того, положить стоимость с(va,vb)=0 для всех дуг пространства состояний, то а -алгоритм просто превращается в неэффективный слепой поиск вширь.",пространства состояний,ai,1
"если же, кроме того, положить стоимость с(va,vb)=0 для всех дуг пространства состояний, то а -алгоритм просто превращается в неэффективный слепой поиск вширь.",слепой поиск,ai,1
обе предложенные для игры в восемь эвристические функции est1(v) и est2(v) удовлетворяют условию допустимости а -алгоритма.,эвристические функции,ai,1
"заметим, что функция s(v) не учитывает должным образом трудность обмена местами двух соседних фишек, а поэтому ее эвристическая сила в принципе может быть повышена.",эвристическая сила,ai,1
"в ряде случаев эвристическая сила некоторой оценочной функции может быть повышена просто путем умножения на положительную константу, большую единицы, однако иногда такое повышение приводит к потере допустимости алгоритма.",эвристическая сила,ai,1
"в ряде случаев эвристическая сила некоторой оценочной функции может быть повышена просто путем умножения на положительную константу, большую единицы, однако иногда такое повышение приводит к потере допустимости алгоритма.",оценочной функции,ai,1
"например, если для игры в восемь в качестве второй составляющей эвристической функции взять h(v)=2 s(v), то в ряде случаев такая функция будет убыстрять поиск и позволит решать более трудные задачи, но условие допустимости перестанет выполняться (так как для начального состояния на рис.15: h (v) 2 s(v) ).",эвристической функции,ai,1
"если неравенство h1(v) h2(v) верно для всех вершин пространства состояний, не являющихся целевыми, а -алгоритм, использующий эвристическую составляющую h2(v), называется более информированным, чем а -алгоритм с функцией h1(v).",пространства состояний,ai,1
"это значит, что более информированный алгоритм осуществляет более целенаправленный, а значит, более эффективный поиск целевой вершины.",целевой вершины,ai,1
"таким образом, понятие информированности отражает один из аспектов понятия эвристической силы оценочной функции при поиске в пространстве состояний.",эвристической силы,ai,1
"таким образом, понятие информированности отражает один из аспектов понятия эвристической силы оценочной функции при поиске в пространстве состояний.",пространстве состояний,ai,1
"таким образом, понятие информированности отражает один из аспектов понятия эвристической силы оценочной функции при поиске в пространстве состояний.",оценочной функции,ai,1
"итак, желательно подбирать такую эвристическую функцию h(v), которая была бы нижней границей h (v) (чтобы гарантировать допустимость алгоритма) и которая была бы как можно ближе к h (v) (чтобы обеспечить эффективность поиска).",эвристическую функцию,ai,1
"заметим, что существуют задачи, для которых нельзя найти оценочную функцию, обеспечивающую во всех случаях как эффективность, так и допустимость эвристического поиска.",эвристического поиска,ai,1
"заметим, что существуют задачи, для которых нельзя найти оценочную функцию, обеспечивающую во всех случаях как эффективность, так и допустимость эвристического поиска.",оценочную функцию,ai,1
"поэтому часто приходится использовать эвристические функции, сокращающие поиск во многих случаях, но не гарантирующие нахождение оптимального решающего пути.",эвристические функции,ai,1
"поэтому часто приходится использовать эвристические функции, сокращающие поиск во многих случаях, но не гарантирующие нахождение оптимального решающего пути.",решающего пути,ai,1
"в идеальном случае, когда известна сама оценка h (v), и она используется в качестве h(v), а -алгоритм находит оптимальный решающий путь сразу, без раскрытия ненужных вершин.",решающий путь,ai,1
"2.3.3 алгоритм подъема на холм сильным упрощением базового алгоритма эвристического поиска с произвольной оценочной функцией является алгоритм подъема на холм [нильсон85, раздел 1.1.4].",оценочной функцией,ai,1
"2.3.3 алгоритм подъема на холм сильным упрощением базового алгоритма эвристического поиска с произвольной оценочной функцией является алгоритм подъема на холм [нильсон85, раздел 1.1.4].",эвристического поиска,ai,1
"2.3.3 алгоритм подъема на холм сильным упрощением базового алгоритма эвристического поиска с произвольной оценочной функцией является алгоритм подъема на холм [нильсон85, раздел 1.1.4].",алгоритма эвристического поиска,ai,1
"этот алгоритм при раскрытии каждой вершины производит упорядочение (по значению оценочной функции) порожденных дочерних вершин, и выбирает для последующего раскрытия дочернюю вершину с наименьшей оценкой, а не вершину с наименьшей оценкой среди всех нераскрытых вершин дерева поиска, как в базовом алгоритме эвристического поиска.",алгоритме эвристического поиска,ai,1
"этот алгоритм при раскрытии каждой вершины производит упорядочение (по значению оценочной функции) порожденных дочерних вершин, и выбирает для последующего раскрытия дочернюю вершину с наименьшей оценкой, а не вершину с наименьшей оценкой среди всех нераскрытых вершин дерева поиска, как в базовом алгоритме эвристического поиска.",дерева поиска,ai,1
"этот алгоритм при раскрытии каждой вершины производит упорядочение (по значению оценочной функции) порожденных дочерних вершин, и выбирает для последующего раскрытия дочернюю вершину с наименьшей оценкой, а не вершину с наименьшей оценкой среди всех нераскрытых вершин дерева поиска, как в базовом алгоритме эвристического поиска.",эвристического поиска,ai,1
"этот алгоритм при раскрытии каждой вершины производит упорядочение (по значению оценочной функции) порожденных дочерних вершин, и выбирает для последующего раскрытия дочернюю вершину с наименьшей оценкой, а не вершину с наименьшей оценкой среди всех нераскрытых вершин дерева поиска, как в базовом алгоритме эвристического поиска.",оценочной функции,ai,1
"в алгоритме подъема на холм , применяемом для поиска в пространстве состояний, роль функции метода подъема на гору играет эвристическая оценочная функция, взятая с обратным знаком.",оценочная функция,ai,1
"в алгоритме подъема на холм , применяемом для поиска в пространстве состояний, роль функции метода подъема на гору играет эвристическая оценочная функция, взятая с обратным знаком.",эвристическая оценочная функция,ai,1
"в алгоритме подъема на холм , применяемом для поиска в пространстве состояний, роль функции метода подъема на гору играет эвристическая оценочная функция, взятая с обратным знаком.",пространстве состояний,ai,1
"поиск продолжается всегда от той дочерней вершины, которая имеет меньшее значение эвристической функции (при этом случай, когда вершин с одинаковой минимальной оценкой несколько, является нежелательным).",эвристической функции,ai,1
"важно, что алгоритм подъема на холм дает тот же результат, что и базовый алгоритм эвристического поиска в тех случаях, когда оценочная функция обладает определенными свойствами, в частности, имеет один (глобальный) экстремум.",оценочная функция,ai,1
"важно, что алгоритм подъема на холм дает тот же результат, что и базовый алгоритм эвристического поиска в тех случаях, когда оценочная функция обладает определенными свойствами, в частности, имеет один (глобальный) экстремум.",эвристического поиска,ai,1
"важно, что алгоритм подъема на холм дает тот же результат, что и базовый алгоритм эвристического поиска в тех случаях, когда оценочная функция обладает определенными свойствами, в частности, имеет один (глобальный) экстремум.",алгоритм эвристического поиска,ai,1
"алгоритм становится несостоятельным, если у эвристической функции имеется несколько локальных экстремумов.",эвристической функции,ai,1
"таким образом, рассматриваемый алгоритм имеет ограниченную применимость, но иногда возникающие проблемы можно разрешить, построив более подходящую эвристическую функцию.",эвристическую функцию,ai,1
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,слепой поиск,ai,1
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,слепого перебора,ai,1
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,пространстве состояний,ai,1
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,алгоритмов слепого перебора,ai,1
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,алгоритмы поиска,ai,1
функция opening порождает для своего единственного аргумента описания состояния задачи список дочерних вершин-состояний (он может оказаться и пустым).,вершин-состояний,ai,1
функция opening порождает для своего единственного аргумента описания состояния задачи список дочерних вершин-состояний (он может оказаться и пустым).,состояния задачи,ai,1
функция opening порождает для своего единственного аргумента описания состояния задачи список дочерних вершин-состояний (он может оказаться и пустым).,описания состояния,ai,1
"описание каждого состояния задается списком, первый элемент которого это уникальный идентификатор состояния (число или атом), а второй элемент собственно описание состояния задачи.",описание состояния,ai,1
"описание каждого состояния задается списком, первый элемент которого это уникальный идентификатор состояния (число или атом), а второй элемент собственно описание состояния задачи.",состояния задачи,ai,1
функция solution с двумя аргументами найденным целевым состоянием и списком всех указателей дерева перебора вырабатывает список-решение задачи (решающий путь).,решающий путь,ai,1
функция solution с двумя аргументами найденным целевым состоянием и списком всех указателей дерева перебора вырабатывает список-решение задачи (решающий путь).,дерева перебора,ai,1
функция solution с двумя аргументами найденным целевым состоянием и списком всех указателей дерева перебора вырабатывает список-решение задачи (решающий путь).,целевым состоянием,ai,1
"предикат is goal проверяет, является ли ее аргумент целевым состоянием.",целевым состоянием,ai,1
"в обоих алгоритмах поиска применяется также вспомогательная рекурсивная функция retain new, которая оставляет в списке дочерних состояний dlist только те, которые не порождались ранее тем самым исключается зацикливание при поиске в произвольном графе: (defun retain new (dlist) (prog (d) (cond ((null dlist) (return ()) )) (setq d (car dlist)) (cond ((or (member d open) (member d closed)) (return (retain new (cdr dlist))) )) (return (cons d (retain-new (cdr dlist)))) )) другая вспомогательная рекурсивная функция check goals проверяет, есть ли среди дочерних состояний целевые.",алгоритмах поиска,ai,1
"в обоих алгоритмах поиска применяется также вспомогательная рекурсивная функция retain new, которая оставляет в списке дочерних состояний dlist только те, которые не порождались ранее тем самым исключается зацикливание при поиске в произвольном графе: (defun retain new (dlist) (prog (d) (cond ((null dlist) (return ()) )) (setq d (car dlist)) (cond ((or (member d open) (member d closed)) (return (retain new (cdr dlist))) )) (return (cons d (retain-new (cdr dlist)))) )) другая вспомогательная рекурсивная функция check goals проверяет, есть ли среди дочерних состояний целевые.",рекурсивная функция,ai,1
"значением этой функции является целевое состояние, если таковое найдено, и пустой список в ином случае: (defun check goals (dlist) (cond ((null dlist) ()) ((is goal (car dlist)) (car dlist)) (t (check goals (cdr dlist))) )) приведем теперь текст лисп-функции поиска вширь.",целевое состояние,ai,1
"значением этой функции является целевое состояние, если таковое найдено, и пустой список в ином случае: (defun check goals (dlist) (cond ((null dlist) ()) ((is goal (car dlist)) (car dlist)) (t (check goals (cdr dlist))) )) приведем теперь текст лисп-функции поиска вширь.",лисп-функции,ai,1
"отметим, что в отличие от базового алгоритма поиска вширь описываемая функция исключает повторно порожденные состояния (функция retain new), шаги 4 и 5 алгоритма объединены для упрощения программы.",алгоритма поиска,ai,1
"(defun breadth first search (startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; goal ;целевая вершина;) ;шаг 1:; (setq open (list (list 's0 startstate))) ;шаг 2:; вs (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;шаги 4,5:; (setq deslist (opening current)) (cond((setq goal(check goals deslist)) (return (solution goal reflist)) )) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go bs))) (setq open (append open deslist)) ; построение указателей и занесение их в общий список:; (setq reflist (append (connect deslist current) reflist)) (go вs) )) нижеследующая лисп-функция limited depth search поиска вглубь имеет два аргумента: кроме начального состояния startstate в число ее аргументов включена граничная глубина limdepth.",вершин-состояний,ai,1
"(defun breadth first search (startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; goal ;целевая вершина;) ;шаг 1:; (setq open (list (list 's0 startstate))) ;шаг 2:; вs (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;шаги 4,5:; (setq deslist (opening current)) (cond((setq goal(check goals deslist)) (return (solution goal reflist)) )) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go bs))) (setq open (append open deslist)) ; построение указателей и занесение их в общий список:; (setq reflist (append (connect deslist current) reflist)) (go вs) )) нижеследующая лисп-функция limited depth search поиска вглубь имеет два аргумента: кроме начального состояния startstate в число ее аргументов включена граничная глубина limdepth.",целевая вершина,ai,1
"(defun breadth first search (startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; goal ;целевая вершина;) ;шаг 1:; (setq open (list (list 's0 startstate))) ;шаг 2:; вs (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;шаги 4,5:; (setq deslist (opening current)) (cond((setq goal(check goals deslist)) (return (solution goal reflist)) )) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go bs))) (setq open (append open deslist)) ; построение указателей и занесение их в общий список:; (setq reflist (append (connect deslist current) reflist)) (go вs) )) нижеследующая лисп-функция limited depth search поиска вглубь имеет два аргумента: кроме начального состояния startstate в число ее аргументов включена граничная глубина limdepth.",лисп-функция,ai,1
"предполагается, что в каждом списке-описании состояния, кроме идентификатора состояния и собственно описания состояния задачи, содержится также третий элемент глубина этого состояния-вершины в дереве поиска.",описании состояния,ai,1
"предполагается, что в каждом списке-описании состояния, кроме идентификатора состояния и собственно описания состояния задачи, содержится также третий элемент глубина этого состояния-вершины в дереве поиска.",состояния задачи,ai,1
"предполагается, что в каждом списке-описании состояния, кроме идентификатора состояния и собственно описания состояния задачи, содержится также третий элемент глубина этого состояния-вершины в дереве поиска.",описания состояния,ai,1
"(defun limited depth search (startstate limdepth) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины; ) ;шаг 1: занесение начальной вершины (ее глубина равна 0):; ; в список нераскрытых вершин:; (setq open (list (list 's0 startstate 0))) ;шаг 2:; ls (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;определение глубины текущей вершины:; (setq depth (caddr current)) (cond ((is goal current) ;/шаг 6/; (return (solution current reflist)))) ;шаг 4:; (cond ((eql depth limdepth) (go ls))) ;шаг 5:раскрытие вершины, исключение повторных вершин и; ; модификация списков указателей и нераскрытых вершин:; (setq deslist (opening current)) (setq deslist (retain new deslist)) (cond ((null deslist) (go ls))) (setq open (append (add depth (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go ls) )) функция limited depth search применяет все описанные выше вспомогательные функции, а также описанную ниже функцию add depth, заносящую число dn (величину глубины) в описания всех дочерних состояний из списка dlist: (defun add depth (dn dlist) (cond ((null dlist) ()) (t (cons (list (caar dlist) (cadar dlist) dn) (add depth dn (cdr dlist))) ))) 2.4.2 поиск вглубь на плэнере для сравнения трудоемкости программирования поиска вглубь на языках лисп и плэнер приведем текст плэнерской функции deрth first search, выполняющей поиск вглубь от заданного состояния st, но без ограничения глубины (чтобы ограничить глубину, необходимо добавить в эту функцию дополнительный аргумент граничную глубину, и несколько простых действий).",нераскрытых вершин,ai,1
"(defun limited depth search (startstate limdepth) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины; ) ;шаг 1: занесение начальной вершины (ее глубина равна 0):; ; в список нераскрытых вершин:; (setq open (list (list 's0 startstate 0))) ;шаг 2:; ls (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;определение глубины текущей вершины:; (setq depth (caddr current)) (cond ((is goal current) ;/шаг 6/; (return (solution current reflist)))) ;шаг 4:; (cond ((eql depth limdepth) (go ls))) ;шаг 5:раскрытие вершины, исключение повторных вершин и; ; модификация списков указателей и нераскрытых вершин:; (setq deslist (opening current)) (setq deslist (retain new deslist)) (cond ((null deslist) (go ls))) (setq open (append (add depth (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go ls) )) функция limited depth search применяет все описанные выше вспомогательные функции, а также описанную ниже функцию add depth, заносящую число dn (величину глубины) в описания всех дочерних состояний из списка dlist: (defun add depth (dn dlist) (cond ((null dlist) ()) (t (cons (list (caar dlist) (cadar dlist) dn) (add depth dn (cdr dlist))) ))) 2.4.2 поиск вглубь на плэнере для сравнения трудоемкости программирования поиска вглубь на языках лисп и плэнер приведем текст плэнерской функции deрth first search, выполняющей поиск вглубь от заданного состояния st, но без ограничения глубины (чтобы ограничить глубину, необходимо добавить в эту функцию дополнительный аргумент граничную глубину, и несколько простых действий).",раскрытие вершины,ai,1
функция использует встроенный бектрекинг языка плэнер.,бектрекинг,ai,1
"значением этой функции является список всех состояний-вершин, лежащих на решающем пути от st до целевой вершины.",целевой вершины,ai,1
"[define deрth first search (lambda (st) [prog (dst %очередная раскрываемая вершина; reslist %список, в котором строится решающий путь; ) [set dst .st] [set reslist (.st)] ds [set dst [among [opening .dst]]] [cond ([memb .dst .reslist] [fail])] [set reslist (!",решающий путь,ai,1
".reslist .dst)] [cond ([is goal .dst] [return .reslist]) (t [go ds])] ])] из программных средств управления бектрекингом (в языке плэнер он называется режимом возвратов подробнее об этом см. раздел 4.2) в приведенном тексте используется только функция among, организующая точку выбора альтернатив (развилку).",бектрекингом,ai,1
".reslist .dst)] [cond ([is goal .dst] [return .reslist]) (t [go ds])] ])] из программных средств управления бектрекингом (в языке плэнер он называется режимом возвратов подробнее об этом см. раздел 4.2) в приведенном тексте используется только функция among, организующая точку выбора альтернатив (развилку).",развилку,ai,1
".reslist .dst)] [cond ([is goal .dst] [return .reslist]) (t [go ds])] ])] из программных средств управления бектрекингом (в языке плэнер он называется режимом возвратов подробнее об этом см. раздел 4.2) в приведенном тексте используется только функция among, организующая точку выбора альтернатив (развилку).",режимом возвратов,ai,1
"в соответствующей строке программы с меткой ds, являющейся началом внутреннего цикла, раскрывается очередная вершина, из получившихся дочерних вершин образуется развилка (точка бектрекинга) и выбирается одна из вершин развилки.",развилка,ai,1
"в соответствующей строке программы с меткой ds, являющейся началом внутреннего цикла, раскрывается очередная вершина, из получившихся дочерних вершин образуется развилка (точка бектрекинга) и выбирается одна из вершин развилки.",точка бектрекинга,ai,1
"в соответствующей строке программы с меткой ds, являющейся началом внутреннего цикла, раскрывается очередная вершина, из получившихся дочерних вершин образуется развилка (точка бектрекинга) и выбирается одна из вершин развилки.",бектрекинга,ai,1
"в соответствующей строке программы с меткой ds, являющейся началом внутреннего цикла, раскрывается очередная вершина, из получившихся дочерних вершин образуется развилка (точка бектрекинга) и выбирается одна из вершин развилки.",развилки,ai,1
"затем проверяется, не содержится ли выбранная вершина-состояние в списке reslist, и если это так, то она добавляется в этот список, где последовательно формируется решающий путь.",решающий путь,ai,1
"затем проверяется, не содержится ли выбранная вершина-состояние в списке reslist, и если это так, то она добавляется в этот список, где последовательно формируется решающий путь.",вершина-состояние,ai,1
"далее проверяется, не является ли выбранная вершина целевой, и в зависимости от результата этой проверки либо поиск успешно заканчивается, либо производится переход на начало цикла для того, чтобы, раскрывая текущую вершину, идти вглубь дерева поиска (каждый шаг цикла соответствует шагу вниз в дереве поиска).",дерева поиска,ai,1
"в принципе алгоритм поиска вглубь мог быть запрограммирован без цикла, с использованием рекурсии.",алгоритм поиска,ai,1
"в этом случае развилка бы ставилась при каждом обращении к рекурсивной функции поиска, и в типичном случае каждое рекурсивное обращение соответствовало бы шагу вниз по дереву перебора.",развилка,ai,1
"в этом случае развилка бы ставилась при каждом обращении к рекурсивной функции поиска, и в типичном случае каждое рекурсивное обращение соответствовало бы шагу вниз по дереву перебора.",рекурсивной функции,ai,1
"в этом случае развилка бы ставилась при каждом обращении к рекурсивной функции поиска, и в типичном случае каждое рекурсивное обращение соответствовало бы шагу вниз по дереву перебора.",дереву перебора,ai,1
в этом случае происходит возврат к текущей развилке для выбора следующей дочерней вершины.,развилке,ai,1
"возврат же к предыдущей по времени возникновения развилке (т.е. точке бектрекинга, организованной на предыдущем шаге цикла и лежащей на один шаг вверх в дереве перебора) будет инициирован самой функцией among в двух следующих случаях.",точке бектрекинга,ai,1
"возврат же к предыдущей по времени возникновения развилке (т.е. точке бектрекинга, организованной на предыдущем шаге цикла и лежащей на один шаг вверх в дереве перебора) будет инициирован самой функцией among в двух следующих случаях.",бектрекинга,ai,1
"возврат же к предыдущей по времени возникновения развилке (т.е. точке бектрекинга, организованной на предыдущем шаге цикла и лежащей на один шаг вверх в дереве перебора) будет инициирован самой функцией among в двух следующих случаях.",развилке,ai,1
"поскольку глубина перебора в функции deрth first search никак не ограничена, то окончание работы алгоритма гарантировано только в случае поиска в ограниченных пространствах состояний.",глубина перебора,ai,1
"поскольку глубина перебора в функции deрth first search никак не ограничена, то окончание работы алгоритма гарантировано только в случае поиска в ограниченных пространствах состояний.",пространствах состояний,ai,1
"если просматриваемое пространство не содержит целевого состояния, результатом этой функции будет неуспех, и процесс возврата вернет управление к последней по времени развилке, возникшей перед входом в функцию deрth first search.",целевого состояния,ai,1
"если просматриваемое пространство не содержит целевого состояния, результатом этой функции будет неуспех, и процесс возврата вернет управление к последней по времени развилке, возникшей перед входом в функцию deрth first search.",развилке,ai,1
"если сравнивать эту плэнер-функцию с вышеприведенными лисп-функциями для поиска вширь и вглубь, то нетрудно заметить, что встроенный механизм бектрекинга позволил обойтись без многих вспомогательных структур списков открытых и закрытых вершин, списка указателей между вершинами и др., а также без операций по их модификации.",механизм бектрекинга,ai,1
"если сравнивать эту плэнер-функцию с вышеприведенными лисп-функциями для поиска вширь и вглубь, то нетрудно заметить, что встроенный механизм бектрекинга позволил обойтись без многих вспомогательных структур списков открытых и закрытых вершин, списка указателей между вершинами и др., а также без операций по их модификации.",лисп-функциями,ai,1
"если сравнивать эту плэнер-функцию с вышеприведенными лисп-функциями для поиска вширь и вглубь, то нетрудно заметить, что встроенный механизм бектрекинга позволил обойтись без многих вспомогательных структур списков открытых и закрытых вершин, списка указателей между вершинами и др., а также без операций по их модификации.",бектрекинга,ai,1
"кроме достоинств, заключающихся в упрощении программирования слепого перебора вглубь, встроенный бектрекинг имеет и недостатки, главные из которых жесткость и неэффективность.",бектрекинг,ai,1
"кроме достоинств, заключающихся в упрощении программирования слепого перебора вглубь, встроенный бектрекинг имеет и недостатки, главные из которых жесткость и неэффективность.",слепого перебора,ai,1
"встроенный механизм возвратов языка плэнер совсем не облегчает программирование других разновидностей поиска перебора вширь и эвристического поиска, и оно выполняется обычно без использования этого механизма, т.е. почти так же, как и в языках программирования без встроенного бектрекинга.",механизм возвратов,ai,1
"встроенный механизм возвратов языка плэнер совсем не облегчает программирование других разновидностей поиска перебора вширь и эвристического поиска, и оно выполняется обычно без использования этого механизма, т.е. почти так же, как и в языках программирования без встроенного бектрекинга.",бектрекинга,ai,1
"встроенный механизм возвратов языка плэнер совсем не облегчает программирование других разновидностей поиска перебора вширь и эвристического поиска, и оно выполняется обычно без использования этого механизма, т.е. почти так же, как и в языках программирования без встроенного бектрекинга.",эвристического поиска,ai,1
"что же касается языка пролог, в котором по существу нельзя отказаться от встроенного бектрекинга, то по этой причине запрограммировать на нем алгоритм поиска вширь, как и алгоритм эвристического поиска, даже сложнее, чем в обычных языках без встроенного бектрекинга.",алгоритм поиска,ai,1
"что же касается языка пролог, в котором по существу нельзя отказаться от встроенного бектрекинга, то по этой причине запрограммировать на нем алгоритм поиска вширь, как и алгоритм эвристического поиска, даже сложнее, чем в обычных языках без встроенного бектрекинга.",бектрекинга,ai,1
"что же касается языка пролог, в котором по существу нельзя отказаться от встроенного бектрекинга, то по этой причине запрограммировать на нем алгоритм поиска вширь, как и алгоритм эвристического поиска, даже сложнее, чем в обычных языках без встроенного бектрекинга.",эвристического поиска,ai,1
"что же касается языка пролог, в котором по существу нельзя отказаться от встроенного бектрекинга, то по этой причине запрограммировать на нем алгоритм поиска вширь, как и алгоритм эвристического поиска, даже сложнее, чем в обычных языках без встроенного бектрекинга.",алгоритм эвристического поиска,ai,1
"2.4.3 эвристический поиск на лиспе возвращаясь вновь к языку лисп, приведем текст лисповской функции heuristic search, реализующей эвристический поиск в пространстве состояний с использованием эвристической оценочной функции est, зависящей от конкретной поисковой задачи.",эвристической оценочной функции,ai,1
"2.4.3 эвристический поиск на лиспе возвращаясь вновь к языку лисп, приведем текст лисповской функции heuristic search, реализующей эвристический поиск в пространстве состояний с использованием эвристической оценочной функции est, зависящей от конкретной поисковой задачи.",пространстве состояний,ai,1
"2.4.3 эвристический поиск на лиспе возвращаясь вновь к языку лисп, приведем текст лисповской функции heuristic search, реализующей эвристический поиск в пространстве состояний с использованием эвристической оценочной функции est, зависящей от конкретной поисковой задачи.",эвристический поиск,ai,1
"2.4.3 эвристический поиск на лиспе возвращаясь вновь к языку лисп, приведем текст лисповской функции heuristic search, реализующей эвристический поиск в пространстве состояний с использованием эвристической оценочной функции est, зависящей от конкретной поисковой задачи.",оценочной функции,ai,1
вычисляемая для каждого состояния эвристическая оценка хранится как четвертый элемент списка-описания состояния.,описания состояния,ai,1
вычисляемая для каждого состояния эвристическая оценка хранится как четвертый элемент списка-описания состояния.,эвристическая оценка,ai,1
"напомним, что, как и прежде, первый элемент этого списка уникальный идентификатор состояния, второй собственно описание состояния, а третий элемент глубина соответствующей этому состоянию вершины в дереве поиска.",описание состояния,ai,1
"глубина часто используется при подсчете эвристической оценки, поэтому будем считать, что аргументом функции est является список из двух элементов: собственно описания состояния и глубины соответствующей вершины.",эвристической оценки,ai,1
"глубина часто используется при подсчете эвристической оценки, поэтому будем считать, что аргументом функции est является список из двух элементов: собственно описания состояния и глубины соответствующей вершины.",описания состояния,ai,1
"отметим, что на шаге 3, выбирая из списка open первый элемент-вершину, мы тем самым выбираем вершину с минимальной оценкой, поскольку список open всегда упорядочен по неубыванию хранящихся в нем оценок вершин-состояний (это обеспечивается вспомогательной функцией merge).",вершин-состояний,ai,1
"(defun heuristic search(startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины;) ;шаг 1:; (setq open (list(list 's0 startstate 0 (est (list startstate 0)) ))) ;шаг 2:; hs (cond ((null open) (return()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) (setq depth (caddr current)) ;шаг 4:; (cond ((is goal current) (return (solution current reflist)))) ;шаг 5:; (setq deslist (opening current)) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go нs))) ;шаг 6:; (setq open (merge (add depth est (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go hs) )) данная лисповская функция использует (как и ранее рассмотренные функции breadth first search и limited depth search) вспомогательные функции opening, solution, is goal, connect, est (которые зависят от конкретной поисковой задачи) и ранее определенную функцию retain new, а также еще две вспомогательные функции add depth est и merge.",вершин-состояний,ai,1
первая функция устанавливает глубину дочерних вершин и вычисляет их эвристическую оценку.,эвристическую оценку,ai,1
"вторая функция выполняет слияние двух упорядоченных (по невозрастанию эвристической оценки) списков состояний в результирующий упорядоченный список: (defun add depth est (dn slist) (cond ((null slist) ()) (t (cons (list (caar slist) (cadar slist) dn (est (list (cadar slist) dn)) ) (add depth est dn (cdr slist))) ) )) (defun merge (l1 l2) (cond ((null l1) l2) ((null l2) l1) ((> (car (cdddar l1)) (car(cdddar l2))) (cons (car l2) (merge l1 (cdr l2)))) (t (cons (car l1) (merge (cdr l1) l2))) )) 2.4.4 алгоритм подъема на холм на плэнере метод подъема на холм можно рассматривать как обобщение поиска в глубину, при котором на каждом шаге вглубь от некоторой вершины среди ее дочерних вершин для раскрытия выбирается наиболее перспективная вершина, т.е. с наименьшей оценкой (в классическом переборе в глубину этот выбор делается произвольно).",эвристической оценки,ai,1
поэтому алгоритм подъема на холм легко программируется на основе встроенного механизма бектрекинга языка плэнер: [define climb on hill (lambda(st) [prog (dst %очередная раскрываемая вершина; reslist %список вершин решающего пути; ) [set dst .st] [set reslist (.st)] cs [set dst [among [q sort [opening .dst]]]] [cond ([memb .dst .reslist] [fail])] [set reslist (!.reslist,механизма бектрекинга,ai,1
поэтому алгоритм подъема на холм легко программируется на основе встроенного механизма бектрекинга языка плэнер: [define climb on hill (lambda(st) [prog (dst %очередная раскрываемая вершина; reslist %список вершин решающего пути; ) [set dst .st] [set reslist (.st)] cs [set dst [among [q sort [opening .dst]]]] [cond ([memb .dst .reslist] [fail])] [set reslist (!.reslist,бектрекинга,ai,1
поэтому алгоритм подъема на холм легко программируется на основе встроенного механизма бектрекинга языка плэнер: [define climb on hill (lambda(st) [prog (dst %очередная раскрываемая вершина; reslist %список вершин решающего пути; ) [set dst .st] [set reslist (.st)] cs [set dst [among [q sort [opening .dst]]]] [cond ([memb .dst .reslist] [fail])] [set reslist (!.reslist,решающего пути,ai,1
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",эвристическую оценочную функцию,ai,1
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",эвристическую информацию,ai,1
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",оценочную функцию,ai,1
"2.5.1 задача о коммивояжере (лисп и плэнер) в задаче о коммивояжере состояние задачи описывается как список городов, которые коммивояжер уже посетил к настоящему моменту, и пространство состояний представляет собой дерево, причем ограниченной глубины.",состояние задачи,ai,1
"2.5.1 задача о коммивояжере (лисп и плэнер) в задаче о коммивояжере состояние задачи описывается как список городов, которые коммивояжер уже посетил к настоящему моменту, и пространство состояний представляет собой дерево, причем ограниченной глубины.",пространство состояний,ai,1
поэтому равно подходящими являются все алгоритмы слепого поиска перебор вширь и вглубь (даже без ограничения глубины).,слепого поиска,ai,1
"кроме того, само найденное целевое состояние может считаться решением, поскольку представляет список городов, входящих в искомый маршрут.",целевое состояние,ai,1
"поэтому в случае программирования этой задачи на языке лисп можно упростить соответствующие лисп-функции слепого поиска, например, breadth first search, обойдясь без указателей и идентификаторов вершин, а также без функций solution, connect и retain new.",слепого поиска,ai,1
"поэтому в случае программирования этой задачи на языке лисп можно упростить соответствующие лисп-функции слепого поиска, например, breadth first search, обойдясь без указателей и идентификаторов вершин, а также без функций solution, connect и retain new.",лисп-функции,ai,1
"при этом потребуется убрать из текста функции строку с обращением к функции connect и строку с обращением к функции retain new, а также заменить обращение к функции solution (аргумент встроенной функции return) на переменную state.",встроенной функции,ai,1
использование встроенной функции is аппарата сопоставления языка плэнер (см. раздел 4.2 пособия) позволяет обойтись без вспомогательной функции поиска города-соседа: [define is goal (state) [prog (x) [is (!,встроенной функции,ai,1
".dlist)] )] [set .roads .y] [go opc] ]] [define add ways (rlist) [prog (r x y) [cond ([fin r rlist] ()) ([is ( x y) .r] (.r (.y .x) <add ways .rlist>) )] ]] 2.5.2 задача об обезьяне (плэнер) в задаче об обезьяне и банане пространство состояний невелико, и хотя оно содержит много циклов, может быть использован поиск вглубь без ограничения глубины, осуществляемый функцией depth first search.",пространство состояний,ai,1
"предполагается, что вершина-состояние описывается списком из двух элементов, первый из которых собственно описание состояния, а второй указание на оператор, в результате применения которого получено описываемое состояние, например: ((тб п тя 0) (перейти тб)).",описание состояния,ai,1
"предполагается, что вершина-состояние описывается списком из двух элементов, первый из которых собственно описание состояния, а второй указание на оператор, в результате применения которого получено описываемое состояние, например: ((тб п тя 0) (перейти тб)).",вершина-состояние,ai,1
"таким образом, решаю щий путь будет содержать не только лежащие на нем вершины-состояния, но и операторы, связанные с дугами этого пути.",вершины-состояния,ai,1
из-за такого усложнения описания состояния несколько сложнее становится предотвращающая зацикливание проверка в функции depth first search.,описания состояния,ai,1
"2.5.3 игра в восемь (лисп) граф-пространство состояний для головоломки-игры в восемь достаточно велик (в игре в пятнадцать фишек он на порядок больше), поэтому хотя в принципе применимы алгоритмы слепого поиска, предпочтителен все же эвристический поиск.",эвристический поиск,ai,1
"2.5.3 игра в восемь (лисп) граф-пространство состояний для головоломки-игры в восемь достаточно велик (в игре в пятнадцать фишек он на порядок больше), поэтому хотя в принципе применимы алгоритмы слепого поиска, предпочтителен все же эвристический поиск.",слепого поиска,ai,1
"2.5.3 игра в восемь (лисп) граф-пространство состояний для головоломки-игры в восемь достаточно велик (в игре в пятнадцать фишек он на порядок больше), поэтому хотя в принципе применимы алгоритмы слепого поиска, предпочтителен все же эвристический поиск.",пространство состояний,ai,1
"опишем нужные для heuristic search вспомогательные лисп-функции is goal, est, opening, solution, connect для игры в восемь.",лисп-функции,ai,1
"в соответствии с предположениями, сделанными в предыдущем разделе, состояние задачи (конфигурация игры) представляется списком из следующих элементов: идентификатор состояния (используются атомы s1,s2,s3, ... генерируемые встроенной лисповской функцией gensym); собственно описание состояния список из номеров фишек, записанных последовательно по рядам квадрата; число-глубина состояния-вершины в дереве перебора; числовая эвристическая оценка состояния.",описание состояния,ai,1
"в соответствии с предположениями, сделанными в предыдущем разделе, состояние задачи (конфигурация игры) представляется списком из следующих элементов: идентификатор состояния (используются атомы s1,s2,s3, ... генерируемые встроенной лисповской функцией gensym); собственно описание состояния список из номеров фишек, записанных последовательно по рядам квадрата; число-глубина состояния-вершины в дереве перебора; числовая эвристическая оценка состояния.",состояние задачи,ai,1
"в соответствии с предположениями, сделанными в предыдущем разделе, состояние задачи (конфигурация игры) представляется списком из следующих элементов: идентификатор состояния (используются атомы s1,s2,s3, ... генерируемые встроенной лисповской функцией gensym); собственно описание состояния список из номеров фишек, записанных последовательно по рядам квадрата; число-глубина состояния-вершины в дереве перебора; числовая эвристическая оценка состояния.",эвристическая оценка,ai,1
"в описание состояния включается также в качестве первого элемента списка обозначение того оператора движения пустой клетки, который привел к данному состоянию.",описание состояния,ai,1
"этот элемент нужен, чтобы исключить тривиальные (см. раздел 2.2.1) повторы состояний при раскрытии вершин.",раскрытии вершин,ai,1
"например, список (s3 ('left 2 8 3 1 6 4 # 7 5) 1 6) описывает состояние s3, полученное сдвигом пустышки влево и имеющее эвристическую оценку 6, соответствующая вершина находится в дереве перебора на глубине 1.",эвристическую оценку,ai,1
"отметим, что эвристическая оценка используется только в алгоритме эвристического перебора, а глубина вершины в алгоритмах эвристического перебора и ограниченного перебора вглубь.",алгоритмах эвристического перебора,ai,1
"отметим, что эвристическая оценка используется только в алгоритме эвристического перебора, а глубина вершины в алгоритмах эвристического перебора и ограниченного перебора вглубь.",эвристическая оценка,ai,1
"отметим, что эвристическая оценка используется только в алгоритме эвристического перебора, а глубина вершины в алгоритмах эвристического перебора и ограниченного перебора вглубь.",алгоритме эвристического перебора,ai,1
"отметим, что эвристическая оценка используется только в алгоритме эвристического перебора, а глубина вершины в алгоритмах эвристического перебора и ограниченного перебора вглубь.",ограниченного перебора,ai,1
"отметим, что эвристическая оценка используется только в алгоритме эвристического перебора, а глубина вершины в алгоритмах эвристического перебора и ограниченного перебора вглубь.",эвристического перебора,ai,1
"описанные ниже лисп-функции для игры в восемь могут быть пригодны и для игры в пятнадцать, так как размер стороны игрового квадрата, равный 3, используется в них как глобальная переменная size.",лисп-функции,ai,1
"другая глобальная переменная goalstate хранит описание целевого состояния (без идентификатора, глубины и эвристической оценки).",эвристической оценки,ai,1
"другая глобальная переменная goalstate хранит описание целевого состояния (без идентификатора, глубины и эвристической оценки).",целевого состояния,ai,1
"значение оценочной функции est определяется как сумма числа фишек, стоящих не на своих местах, и длины пути (глубины) оцениваемого состояния-вершины в дереве поиска.",оценочной функции,ai,1
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",целевого состояний,ai,1
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",описания состояния,ai,1
"(defun add state (op k1 k2) (push(list (gensym) (cons op (cond((< k1 k2) (exchange state '# (nth (sub1 k2) state))) (t (exchange state (nth (sub1 k2) state)'#))) )) dlist)) рекурсивная функция exchange, использованная в add state, формирует новое состояние игры путем перестановки заданных элементов исходного состояния-списка list.",рекурсивная функция,ai,1
(defun exchange (list elem1 elem2) (cond((eql elem1 (car list)) (cons elem2 (exchange (cdr list) elem1 elem2))) ((eql elem2 (car list)) (cons elem1 (cdr list))) (t (cons(car list)(exchange (cdr list) elem1 elem2))))) функция connect формирует список указателей от текущей вершины-состояния curr к заданным (в списке dlist) дочерним вершинам-состояниям.,вершинам-состояниям,ai,1
"(defun connect (dlist curr) (prog (d di ci rlist) c (setq d (car dlist)) (setq dlist (cdr dlist)) (setq di (car d)) (setq ci (car curr)) (setq rlist (cons (list ci di (caadr d)) rlist)) (cond ((null dlist) (return rlist))) (go c) )) функция solution, выделяя решающий путь, строит последовательность (названий) операторов, преобразующих начальное состояние в целевое (ее аргумент reflist список всех указателей-связей между состояниями).",решающий путь,ai,1
для поиска указателя к очередной вершине решающего пути функция использует вспомогательную функцию look for .,решающего пути,ai,1
"(defun solution (goal reflist) (prog (sollist ;список, в котором строится решение; gi edge) (setq gi (car goal)) s (cond((eq gi 's0) (return sollist))) (setq edge (look for gi reflist)) (setq sollist (cons (caddr edge) sollist)) (setq gi (car edge)) (go s) )) (defun look for (id list) (cond ((null list) (quote error)) ((eq id (cadar list)) (car list)) (t (look for id (cdr list))) )) в заключение приведем функцию, инициализирующую эвристический поиск решения игры в восемь: в самом его начале устанавливаются переменные-параметры встроенной функции gensym.",эвристический поиск,ai,1
"(defun solution (goal reflist) (prog (sollist ;список, в котором строится решение; gi edge) (setq gi (car goal)) s (cond((eq gi 's0) (return sollist))) (setq edge (look for gi reflist)) (setq sollist (cons (caddr edge) sollist)) (setq gi (car edge)) (go s) )) (defun look for (id list) (cond ((null list) (quote error)) ((eq id (cadar list)) (car list)) (t (look for id (cdr list))) )) в заключение приведем функцию, инициализирующую эвристический поиск решения игры в восемь: в самом его начале устанавливаются переменные-параметры встроенной функции gensym.",встроенной функции,ai,1
"(heuristic search initstate) )) 2.6 поиск на и/или-графах 2.6.1 особенности поиска и/или-граф, называемый также графом целей (задач), неявно задается при формализации задачи с использованием метода редукции, путем описания исходной задачи, операторов сведения задачи к подзадачам и множества элементарных задач.",редукции,ai,1
"(heuristic search initstate) )) 2.6 поиск на и/или-графах 2.6.1 особенности поиска и/или-граф, называемый также графом целей (задач), неявно задается при формализации задачи с использованием метода редукции, путем описания исходной задачи, операторов сведения задачи к подзадачам и множества элементарных задач.",элементарных задач,ai,1
"(heuristic search initstate) )) 2.6 поиск на и/или-графах 2.6.1 особенности поиска и/или-граф, называемый также графом целей (задач), неявно задается при формализации задачи с использованием метода редукции, путем описания исходной задачи, операторов сведения задачи к подзадачам и множества элементарных задач.",метода редукции,ai,1
"очевидно, что если и-вершин в этом графе нет, то получаем обычный граф-пространство состояний, для поиска в котором можно использовать рассмотренные в настоящей главе алгоритмы, но из-за наличия в общем случае в графе таких вершин нужна модификация алгоритмов, существенно их усложняющая.",пространство состояний,ai,1
"причины усложнения алгоритмов поиска на и/или-графах связаны с тем, что более сложной становится проверка условий окончания перебора, т.е. разрешимости исходной задачи.",алгоритмов поиска,ai,1
"если она уже разрешима, должен быть выявлен решающий граф задачи.",решающий граф,ai,1
"неразрешимость вершины (и соответствующей задачи) дерева поиска может быть определена рекурсивным образом аналогично определению разрешимой вершины, данному в первой главе пособия: вершина, не являющаяся заключительной и не имеющая дочерних вершин, неразрешима; или-вершина неразрешима тогда и только тогда, когда неразрешимы все ее дочерние вершины; и-вершина неразрешима тогда и только тогда, неразрешима хотя бы одна из ее дочерних вершин.",или-вершина,ai,1
"неразрешимость вершины (и соответствующей задачи) дерева поиска может быть определена рекурсивным образом аналогично определению разрешимой вершины, данному в первой главе пособия: вершина, не являющаяся заключительной и не имеющая дочерних вершин, неразрешима; или-вершина неразрешима тогда и только тогда, когда неразрешимы все ее дочерние вершины; и-вершина неразрешима тогда и только тогда, неразрешима хотя бы одна из ее дочерних вершин.",дерева поиска,ai,1
"неразрешимость вершины (и соответствующей задачи) дерева поиска может быть определена рекурсивным образом аналогично определению разрешимой вершины, данному в первой главе пособия: вершина, не являющаяся заключительной и не имеющая дочерних вершин, неразрешима; или-вершина неразрешима тогда и только тогда, когда неразрешимы все ее дочерние вершины; и-вершина неразрешима тогда и только тогда, неразрешима хотя бы одна из ее дочерних вершин.",и-вершина,ai,1
"неразрешимость вершины (и соответствующей задачи) дерева поиска может быть определена рекурсивным образом аналогично определению разрешимой вершины, данному в первой главе пособия: вершина, не являющаяся заключительной и не имеющая дочерних вершин, неразрешима; или-вершина неразрешима тогда и только тогда, когда неразрешимы все ее дочерние вершины; и-вершина неразрешима тогда и только тогда, неразрешима хотя бы одна из ее дочерних вершин.",разрешимой вершины,ai,1
"как и в случае поиска в пространстве состояний, все алгоритмы перебора на и/или-графе можно описать, опираясь на операцию раскрытия очередной вершины графа, означающую применение к ней (точнее, к соответствующему состоянию) всех возможных операторов редукции, порождающих дочерние вершины.",редукции,ai,1
"как и в случае поиска в пространстве состояний, все алгоритмы перебора на и/или-графе можно описать, опираясь на операцию раскрытия очередной вершины графа, означающую применение к ней (точнее, к соответствующему состоянию) всех возможных операторов редукции, порождающих дочерние вершины.",операторов редукции,ai,1
"как и в случае поиска в пространстве состояний, все алгоритмы перебора на и/или-графе можно описать, опираясь на операцию раскрытия очередной вершины графа, означающую применение к ней (точнее, к соответствующему состоянию) всех возможных операторов редукции, порождающих дочерние вершины.",пространстве состояний,ai,1
"как и в случае поиска в пространстве состояний, все алгоритмы перебора на и/или-графе можно описать, опираясь на операцию раскрытия очередной вершины графа, означающую применение к ней (точнее, к соответствующему состоянию) всех возможных операторов редукции, порождающих дочерние вершины.",алгоритмы перебора,ai,1
"процесс поиска, представленный как процесс постепенного раскрытия вершин и/или-графа, соответствует преобразованию в явную форму некоторой части всего и/или-графа, неявно заданного при формализации задачи.",раскрытия вершин,ai,1
"это преобразование включает в себя, вообще говоря, проведение указателей от дочерних вершин к их родительским эти указатели необходимы для определения разрешимых и неразрешимых вершин и решающего графа (последний состоит только из разрешимых вершин).",решающего графа,ai,1
"формируемая при поиске структура из вершин и указателей называется графом поиска, по окончании поиска в нем содержится решающий граф.",графом поиска,ai,1
"формируемая при поиске структура из вершин и указателей называется графом поиска, по окончании поиска в нем содержится решающий граф.",решающий граф,ai,1
"в общем случае граф поиска содержит разрешимые и неразрешимые вершины, а также вершины, относительно которых неизвестно разрешимы они или нет.",граф поиска,ai,1
"кроме того, в ходе поиска целесообразно тем или иным способом сохранять подграфы, являющиеся кандидатами на решающий граф задачи по окончании поиска один из них станет решением задачи.",решающий граф,ai,1
основные виды перебора на и/или-графах различаются порядком раскрытия вершин.,раскрытия вершин,ai,1
"так же как в пространстве состояний, применяются: поиск вширь (вершины раскрываются в том порядке, в котором строились); поиск вглубь (в первую очередь раскрываются те вершины, которые были построены последними, глубина поиска обычно ограничивается); подъем на холм и эвристический поиск (выбор вершины для раскрытия производится на основе эвристических оценок вершин).",пространстве состояний,ai,1
"так же как в пространстве состояний, применяются: поиск вширь (вершины раскрываются в том порядке, в котором строились); поиск вглубь (в первую очередь раскрываются те вершины, которые были построены последними, глубина поиска обычно ограничивается); подъем на холм и эвристический поиск (выбор вершины для раскрытия производится на основе эвристических оценок вершин).",эвристический поиск,ai,1
"так же как в пространстве состояний, применяются: поиск вширь (вершины раскрываются в том порядке, в котором строились); поиск вглубь (в первую очередь раскрываются те вершины, которые были построены последними, глубина поиска обычно ограничивается); подъем на холм и эвристический поиск (выбор вершины для раскрытия производится на основе эвристических оценок вершин).",глубина поиска,ai,1
"так же как в пространстве состояний, применяются: поиск вширь (вершины раскрываются в том порядке, в котором строились); поиск вглубь (в первую очередь раскрываются те вершины, которые были построены последними, глубина поиска обычно ограничивается); подъем на холм и эвристический поиск (выбор вершины для раскрытия производится на основе эвристических оценок вершин).",эвристических оценок,ai,1
"алгоритмы поиска формулируются проще для и/или-графов, являющихся деревьями: при этом организация перебора значительно упрощается, поскольку любая задача (цель) может встретиться в таком графе-дереве ровно один раз.",алгоритмы поиска,ai,1
"глубина вершин в формируемом алгоритмами и/или-дереве перебора может быть определена точно так же, как в случае деревьев перебора в пространстве состояний.",пространстве состояний,ai,1
"глубина вершин в формируемом алгоритмами и/или-дереве перебора может быть определена точно так же, как в случае деревьев перебора в пространстве состояний.",деревьев перебора,ai,1
"алгоритм перебора вширь на и/или-дереве непременно обнаруживает то решающее дерево, самая глубокая заключительная вершина которого имеет минимальную глубину (если, конечно, решение задачи вообще существует).",заключительная вершина,ai,1
"алгоритм перебора вширь на и/или-дереве непременно обнаруживает то решающее дерево, самая глубокая заключительная вершина которого имеет минимальную глубину (если, конечно, решение задачи вообще существует).",алгоритм перебора,ai,1
"алгоритм перебора вширь на и/или-дереве непременно обнаруживает то решающее дерево, самая глубокая заключительная вершина которого имеет минимальную глубину (если, конечно, решение задачи вообще существует).",решающее дерево,ai,1
"как и при переборе в пространстве состояний, ограничение глубины может воспрепятствовать нахождению решения, но существующее в пределах ограничения решающее дерево будет найдено обязательно.",пространстве состояний,ai,1
"как и при переборе в пространстве состояний, ограничение глубины может воспрепятствовать нахождению решения, но существующее в пределах ограничения решающее дерево будет найдено обязательно.",решающее дерево,ai,1
"слепой поиск на и/или-дереве, как и в пространстве состояний, неэффективен, поэтому предпочтителен алгоритм эвристического поиска, при котором для очередного раскрытия выбирается наиболее перспективная вершина в дереве перебора, точнее, перспективная вершина в поддереве, являющемся кандидатом на решающее дерево.",слепой поиск,ai,1
"слепой поиск на и/или-дереве, как и в пространстве состояний, неэффективен, поэтому предпочтителен алгоритм эвристического поиска, при котором для очередного раскрытия выбирается наиболее перспективная вершина в дереве перебора, точнее, перспективная вершина в поддереве, являющемся кандидатом на решающее дерево.",алгоритм эвристического поиска,ai,1
"слепой поиск на и/или-дереве, как и в пространстве состояний, неэффективен, поэтому предпочтителен алгоритм эвристического поиска, при котором для очередного раскрытия выбирается наиболее перспективная вершина в дереве перебора, точнее, перспективная вершина в поддереве, являющемся кандидатом на решающее дерево.",пространстве состояний,ai,1
"слепой поиск на и/или-дереве, как и в пространстве состояний, неэффективен, поэтому предпочтителен алгоритм эвристического поиска, при котором для очередного раскрытия выбирается наиболее перспективная вершина в дереве перебора, точнее, перспективная вершина в поддереве, являющемся кандидатом на решающее дерево.",решающее дерево,ai,1
"слепой поиск на и/или-дереве, как и в пространстве состояний, неэффективен, поэтому предпочтителен алгоритм эвристического поиска, при котором для очередного раскрытия выбирается наиболее перспективная вершина в дереве перебора, точнее, перспективная вершина в поддереве, являющемся кандидатом на решающее дерево.",эвристического поиска,ai,1
"для эвристического поиска в и/или-графе был предложен и исследован алгоритм, являющийся аналогом а -алгоритма в пространстве состояний, и получивший название ао -алгоритма [нильсон73, разделы 5.6, 5.7; нильсон85, раздел 3.2].",пространстве состояний,ai,1
"для эвристического поиска в и/или-графе был предложен и исследован алгоритм, являющийся аналогом а -алгоритма в пространстве состояний, и получивший название ао -алгоритма [нильсон73, разделы 5.6, 5.7; нильсон85, раздел 3.2].",эвристического поиска,ai,1
"если задать стоимости дуг в и/или-дереве и применять для эвристического поиска оценочную функцию специального вида, то этот алгоритм найдет за конечное число шагов решающее дерево с минимальной стоимостью.",эвристического поиска,ai,1
"если задать стоимости дуг в и/или-дереве и применять для эвристического поиска оценочную функцию специального вида, то этот алгоритм найдет за конечное число шагов решающее дерево с минимальной стоимостью.",оценочную функцию,ai,1
"если задать стоимости дуг в и/или-дереве и применять для эвристического поиска оценочную функцию специального вида, то этот алгоритм найдет за конечное число шагов решающее дерево с минимальной стоимостью.",решающее дерево,ai,1
"иными словами, для ао -алгоритма верна аналогичная теорема о допустимости, гарантирующая нахождение решения с минимальной стоимостью (так называемого оптимального дерева) при условии, что дерево решения существует.",оптимального дерева,ai,1
"2.6.2 схема просмотра и/или-дерева отвлекаясь от многочисленных деталей организации поиска на и/или-графах общего вида, рассмотрим только на схему раскрытия вершин и формирования решающего дерева при поиске в графах-деревьях.",раскрытия вершин,ai,1
"2.6.2 схема просмотра и/или-дерева отвлекаясь от многочисленных деталей организации поиска на и/или-графах общего вида, рассмотрим только на схему раскрытия вершин и формирования решающего дерева при поиске в графах-деревьях.",решающего дерева,ai,1
"and/or-процедура, получая на вход некоторую вершину-задачу goal, вырабатывает либо неуспех, если эта вершина неразрешима, либо возвращает решающее дерево, показывающее ее разрешимость и являющееся решением этой задачи.",решающее дерево,ai,1
"каждая из них получает на вход вершину goal соответствующего типа и список ее дочерних вершин glist, результат процедуры либо решающее дерево с корнем в вершине goal, либо сообщение о неуспехе (неразрешимости этой вершины).",решающее дерево,ai,1
установить в качестве решающего графа для задачи goal саму эту вершину и перейти на следующий шаг.,решающего графа,ai,1
"если список glist не пуст, то перейти на шаг 3, в ином случае закончить текущую процедуру, выдав в качестве результата сформированный решающий граф для задачи-цели goal .",решающий граф,ai,1
подсоединить полученный and/or-процедурой решающий граф для вершины current к решающему графу вершины goal и перейти на шаг 2.,решающий граф,ai,1
"включить полученный and/or-процедурой решающий граф для вершины current в решающий граф вершины goal и закончить текущую процедуру, выдав полученный решающий граф в качестве ее результата.",решающий граф,ai,1
рассмотренные рекурсивные процедуры могут быть легко детализированы для получения либо простого поиска вглубь (при произвольном выборе вершины на шаге 3 or-процедуры) или получения алгоритма подъема на холм (если список glist упорядочен по неубыванию эвристической оценочной функции и на шаге 3 or-процедуры выбирается вершина с наименьшей оценкой).,эвристической оценочной функции,ai,1
рассмотренные рекурсивные процедуры могут быть легко детализированы для получения либо простого поиска вглубь (при произвольном выборе вершины на шаге 3 or-процедуры) или получения алгоритма подъема на холм (если список glist упорядочен по неубыванию эвристической оценочной функции и на шаге 3 or-процедуры выбирается вершина с наименьшей оценкой).,оценочной функции,ai,1
"для реализации же эвристического поиска потребуется другая схема просмотра и/или-дерева по причине необходимости доступа к концевым вершинам поддерева, являющегося кандидатом на решающее дерево.",концевым вершинам,ai,1
"для реализации же эвристического поиска потребуется другая схема просмотра и/или-дерева по причине необходимости доступа к концевым вершинам поддерева, являющегося кандидатом на решающее дерево.",эвристического поиска,ai,1
"для реализации же эвристического поиска потребуется другая схема просмотра и/или-дерева по причине необходимости доступа к концевым вершинам поддерева, являющегося кандидатом на решающее дерево.",решающее дерево,ai,1
"2.6.3 различия и ключевые операторы в заключение целесообразно обсудить ряд общих идей, на которых может быть основана редукция задач.",редукция задач,ai,1
"2.6.3 различия и ключевые операторы в заключение целесообразно обсудить ряд общих идей, на которых может быть основана редукция задач.",ключевые операторы,ai,1
"2.6.3 различия и ключевые операторы в заключение целесообразно обсудить ряд общих идей, на которых может быть основана редукция задач.",редукция,ai,1
"к их числу, прежде всего, относится идея выделения так называемых ключевых операторов и различий состояний.",ключевых операторов,ai,1
"будем далее предполагать, что задачи и подзадачи решаются в пространстве состояний и записываются как (s i, o, sg), где s i и sg соответственно начальное и целевое состояния, причем множество o операторов преобразований состояний может быть опущено в случае его постоянности (неизменности).",пространстве состояний,ai,1
"будем далее предполагать, что задачи и подзадачи решаются в пространстве состояний и записываются как (s i, o, sg), где s i и sg соответственно начальное и целевое состояния, причем множество o операторов преобразований состояний может быть опущено в случае его постоянности (неизменности).",целевое состояния,ai,1
"часто при поиске в пространстве состояний нетрудно обнаружить один оператор, который обязательно должен входить в решение задачи (по сути, применение этого оператора есть необходимый шаг решения этой задачи).",пространстве состояний,ai,1
"в графе-пространстве состояний этому оператору обычно соответствует дуга, связывающая две практически отдельные части графа.",пространстве состояний,ai,1
такой оператор и называется ключевым оператором в пространстве состояний.,ключевым оператором,ai,1
такой оператор и называется ключевым оператором в пространстве состояний.,пространстве состояний,ai,1
"к примеру, в задаче о пирамидке ключевым оператором был оператор переноса на нужный колышек нижнего диска 3 (см. рис.8).",ключевым оператором,ai,1
ключевой оператор может быть использован для следующего способа сведения исходной задачи к подзадачам.,ключевой оператор,ai,1
"пусть op найденный в пространстве состояний задачи ключевой оператор (op o); sop множество состояний, к которым применим ключевой оператор op; op(s)",состояний задачи,ai,1
"пусть op найденный в пространстве состояний задачи ключевой оператор (op o); sop множество состояний, к которым применим ключевой оператор op; op(s)",пространстве состояний,ai,1
"пусть op найденный в пространстве состояний задачи ключевой оператор (op o); sop множество состояний, к которым применим ключевой оператор op; op(s)",ключевой оператор,ai,1
"состояние, полученное в результате применения ключевого оператора op к состоянию s (s sop).",ключевого оператора,ai,1
"тогда исходную задачу можно свести к трем подзадачам: первая задача (s i, sop) состоит в поиске пути от начального состояния исходной задачи к одному из состояний, к которому применим ключевой оператор op; вторая задача является элементарной, она заключается в применении этого ключевого оператора; третья задача (op(s), sg) состоит в поиске пути от состояния, полученного применением ключевого оператора, к целевому состоянию исходной задачи.",целевому состоянию,ai,1
"тогда исходную задачу можно свести к трем подзадачам: первая задача (s i, sop) состоит в поиске пути от начального состояния исходной задачи к одному из состояний, к которому применим ключевой оператор op; вторая задача является элементарной, она заключается в применении этого ключевого оператора; третья задача (op(s), sg) состоит в поиске пути от состояния, полученного применением ключевого оператора, к целевому состоянию исходной задачи.",ключевой оператор,ai,1
"тогда исходную задачу можно свести к трем подзадачам: первая задача (s i, sop) состоит в поиске пути от начального состояния исходной задачи к одному из состояний, к которому применим ключевой оператор op; вторая задача является элементарной, она заключается в применении этого ключевого оператора; третья задача (op(s), sg) состоит в поиске пути от состояния, полученного применением ключевого оператора, к целевому состоянию исходной задачи.",ключевого оператора,ai,1
"для решения первой и третьей задач опять может быть применен метод редукции, или же их решение может быть найдено непосредственным поиском в пространстве состояний.",редукции,ai,1
"для решения первой и третьей задач опять может быть применен метод редукции, или же их решение может быть найдено непосредственным поиском в пространстве состояний.",пространстве состояний,ai,1
"для решения первой и третьей задач опять может быть применен метод редукции, или же их решение может быть найдено непосредственным поиском в пространстве состояний.",метод редукции,ai,1
"для большинства задач не удается всегда однозначно выделить ключевой оператор, гораздо чаще удается найти множество операторов-кандидатов в ключевые, т.е. операторов, с большой вероятностью могущих стать ключевыми.",ключевой оператор,ai,1
"при таком способе редукции задач самый важный вопрос состоит в том, как найти кандидаты в ключевые операторы.",редукции,ai,1
"при таком способе редукции задач самый важный вопрос состоит в том, как найти кандидаты в ключевые операторы.",редукции задач,ai,1
"при таком способе редукции задач самый важный вопрос состоит в том, как найти кандидаты в ключевые операторы.",ключевые операторы,ai,1
"один из способов, предложенных и опробованных впервые в одной из наиболее известных систем искусственного интеллекта gps [слейгл, глава 8], заключается в выявлении различий для начального и целевого состояний задачи.",состояний задачи,ai,1
"один из способов, предложенных и опробованных впервые в одной из наиболее известных систем искусственного интеллекта gps [слейгл, глава 8], заключается в выявлении различий для начального и целевого состояний задачи.",целевого состояний,ai,1
различие легче всего формализовать как несоответствие различных элементов описаний начального и целевого состояний.,целевого состояний,ai,1
"на каждом этапе работы система определяла различие между текущим состоянием (объектом) задачи и целевым состоянием (объектом), а затем выбирала и пыталась применить оператор для уменьшения найденного различия.",целевым состоянием,ai,1
в задаче об обезьяне естественно связать различия и операторы-кандидаты в ключевые следующим образом: различие в первом элементе списка-описания состояния (положение обезьяны в плоскости пола) операторы перейти и передвинуть.,описания состояния,ai,1
"ясно, что для реализации рассмотренных идей в виде алгоритма или программы нужна, во-первых, специальная процедура сравнения описаний состояний и вычисления различий.",описаний состояний,ai,1
"во-вторых, нужна таблица или процедура, связывающая ключевые операторы с возможными различиями (в gps использовалась таблица связей различие-оператор).",ключевые операторы,ai,1
"последняя процедура (или таблица) должна также устанавливать приоритет различий и операторов, т.е. порядок их выбора в случаях, когда выявлено несколько различий и возможно применение нескольких ключевых операторов.",ключевых операторов,ai,1
"в задаче об обезьяне и банане приоритет (значимость) различий можно установить, например, следующим образом: различие в четвертом, затем во втором, затем в третьем и первом элементах описания состояния задачи.",состояния задачи,ai,1
"в задаче об обезьяне и банане приоритет (значимость) различий можно установить, например, следующим образом: различие в четвертом, затем во втором, затем в третьем и первом элементах описания состояния задачи.",описания состояния,ai,1
"работая в соответствии с этой эвристикой, gps применяла несколько схем редукции задач, и на основе выявления различий между объектами задачи и применения уменьшающих эти различия операторов рекурсивно формировала систему (дерево) целей (задач и подзадач).",редукции,ai,1
"работая в соответствии с этой эвристикой, gps применяла несколько схем редукции задач, и на основе выявления различий между объектами задачи и применения уменьшающих эти различия операторов рекурсивно формировала систему (дерево) целей (задач и подзадач).",редукции задач,ai,1
поиск на игровых деревьях 3.1 деревья игры.,игровых деревьях,ai,1
"для формализации и изучения игровых стратегий в классе игр с полной информацией может быть использован подход, основанный на редукции задач.",редукции,ai,1
"для формализации и изучения игровых стратегий в классе игр с полной информацией может быть использован подход, основанный на редукции задач.",редукции задач,ai,1
"напомним, что при этом должны быть определены следующие составляющие: форма описания задач и подзадач; операторы, сводящие задачи к подзадачам; элементарные задачи; а также задано описание исходной задачи.",элементарные задачи,ai,1
"при использовании подхода, основанного на редукции задач, выигрышная стратегия ищется в процессе доказательства того, что игра может быть выиграна.",редукции,ai,1
"при использовании подхода, основанного на редукции задач, выигрышная стратегия ищется в процессе доказательства того, что игра может быть выиграна.",редукции задач,ai,1
"операторы сведения (редукции) этой задачи к подзадачам определяются исходя из ходов, допустимых в проводимой игре: если в некоторой конфигурации x+ очередной ход делает игрок плюс, и имеется n допустимых ходов, приводящих соответственно к конфигурациям x1 , x2 , ..., xn , то для решения задачи w(x+) необходимо решить по крайней мере одну из подзадач w(xi ).",редукции,ai,1
"редукция игровых задач последовательное применение к исходной конфигурации игры данной схемы редукции порождает и/или-дерево (и/или-граф), которое называют деревом (графом) игры.",редукции,ai,1
"редукция игровых задач последовательное применение к исходной конфигурации игры данной схемы редукции порождает и/или-дерево (и/или-граф), которое называют деревом (графом) игры.",редукция,ai,1
"дуги игрового дерева соответствуют ходам игроков, вершины конфигурациям игры, причем листья дерева это позиции, в которых игра завершается выигрышем, проигрышем или ничьей.",игрового дерева,ai,1
"некоторые листья являются заключительными вершинами, соответствующими элементарным задачам позициям, выигрышным для игрока плюс.",элементарным задачам,ai,1
"заметим, что для кон фигураций, где ход принадлежит плюсу, в игровом дереве получается или-вершина, а для позиций, в которых ходит минус, получается и-вершина.",или-вершина,ai,1
"заметим, что для кон фигураций, где ход принадлежит плюсу, в игровом дереве получается или-вершина, а для позиций, в которых ходит минус, получается и-вершина.",и-вершина,ai,1
"цель построения игрового дерева или графа получение решающего поддерева для задачи w(xs), показывающего, как игрок плюс может выиграть игру из позиции xs независимо от ответов противника.",игрового дерева,ai,1
для этого могут быть применены разные алгоритмы поиска на и/или-графах.,алгоритмы поиска,ai,1
"решающее дерево заканчивается на позициях, выигрышных для плюса, и содержит полную стратегию достижения им выигрыша: для каждого возможного продолжения игры, выбранного противником, в дереве есть ответный ход, приводящий к победе.",решающее дерево,ai,1
"для задачи v(xs) схема сведения игровых задач к подзадачам аналогична: ходам игрока плюс будут соответствовать и-вершины, а ходам минуса или-вершины, заключительные же вершины будут соответство вать позициям, выигрышным для игрока минус.",или-вершины,ai,1
"для задачи v(xs) схема сведения игровых задач к подзадачам аналогична: ходам игрока плюс будут соответствовать и-вершины, а ходам минуса или-вершины, заключительные же вершины будут соответство вать позициям, выигрышным для игрока минус.",и-вершины,ai,1
"конечно, подобная редукция задач применима и в случае, когда нужно доказать существование ничейной стратегии в игре.",редукция задач,ai,1
"конечно, подобная редукция задач применима и в случае, когда нужно доказать существование ничейной стратегии в игре.",редукция,ai,1
при этом определение элементарной задачи должно быть соответствующим образом изменено.,элементарной задачи,ai,1
"заключительные вершины, соответствующие элементарной задаче v(1+), т.е. выигрышу игрока минус, в графе подчеркнуты.",элементарной задаче,ai,1
"заключительные вершины, соответствующие элементарной задаче v(1+), т.е. выигрышу игрока минус, в графе подчеркнуты.",заключительные вершины,ai,1
"отметим, что для аналогичной задачи w(7+) решающий граф построить не удастся (начальная вершина неразрешима); таким образом, у игрока плюс нет выигрышной стратегии в этой игре.",решающий граф,ai,1
"граф игры ""последний проигрывает"" в большинстве игр, представляющих интерес, таких как шашки и шахматы, построить полные решающие деревья и найти полные игровые стратегии не представляется возможным.",решающие деревья,ai,1
"алгоритмы же упорядоченного перебора с применением эвристик не настолько уменьшают просматриваемую часть дерева игры, чтобы дать существенное, на несколько порядков, сокращение времени поиска.",дерева игры,ai,1
"тем не менее для неполных игр в шашки и шахматы (например, для эндшпилей), как и для всех несложных игр, таких как крестики-нолики на квадрате небольшого размера, можно успешно применять алгоритмы поиска на и/или-графах, позволяющие обнаруживать выигрышные и ничейные игровые стратегии.",алгоритмы поиска,ai,1
"оценим размер полного дерева игры: начальная вершина имеет 9 дочерних вершин, каждая из которых в свою очередь имеет 8 дочерних; каждая вершина глубины 2 имеет 7 дочерних и т.д.",дерева игры,ai,1
"таким образом, число концевых вершин в дереве игры равно 9!=362880, но многие пути в этом дереве обрываются раньше на заключительных вершинах.",концевых вершин,ai,1
"3.2 минимаксная процедура с целью поиска достаточно хорошего первого хода просматривается обычно часть игрового дерева, построенного от заданной конфигурации.",минимаксная процедура,ai,1
"3.2 минимаксная процедура с целью поиска достаточно хорошего первого хода просматривается обычно часть игрового дерева, построенного от заданной конфигурации.",игрового дерева,ai,1
"для этого применяется один из переборных алгоритмов (вглубь, вширь или эвристический) и некоторое искусственное окончание перебора вершин в игровом дереве: например, ограничивается время перебора или же глубина поиска.",глубина поиска,ai,1
"в построенном таким образом частичном дереве игры оцениваются его концевые вершины (листья), и по полученным оценкам определяется наилучший ход от заданной игровой конфигурации.",концевые вершины,ai,1
"при этом для оценивания концевых вершин полученного дерева используется так называемая статическая оценочная функция, а для получения оценки остальных вершин корневой (начальной) и промежуточных между корневой и концевыми используется так называемый минимаксный принцип.",оценочная функция,ai,1
"при этом для оценивания концевых вершин полученного дерева используется так называемая статическая оценочная функция, а для получения оценки остальных вершин корневой (начальной) и промежуточных между корневой и концевыми используется так называемый минимаксный принцип.",концевых вершин,ai,1
"при этом для оценивания концевых вершин полученного дерева используется так называемая статическая оценочная функция, а для получения оценки остальных вершин корневой (начальной) и промежуточных между корневой и концевыми используется так называемый минимаксный принцип.",минимаксный принцип,ai,1
"при этом для оценивания концевых вершин полученного дерева используется так называемая статическая оценочная функция, а для получения оценки остальных вершин корневой (начальной) и промежуточных между корневой и концевыми используется так называемый минимаксный принцип.",статическая оценочная функция,ai,1
"статическая оценочная функция, будучи применена к некоторой вершине-конфигурации игры, дает числовое значение, оценивающее различные достоинства этой игровой позиции.",оценочная функция,ai,1
"статическая оценочная функция, будучи применена к некоторой вершине-конфигурации игры, дает числовое значение, оценивающее различные достоинства этой игровой позиции.",статическая оценочная функция,ai,1
"по сути, статическая функция вычисляет эвристическую оценку шансов на выигрыш одного из игроков.",эвристическую оценку,ai,1
"будем придерживаться общепринятого соглашения, по которому значение статической оценочной функции тем больше, чем больше преимуществ имеет игрок плюс (над игроком минус) в оцениваемой позиции.",статической оценочной функции,ai,1
"будем придерживаться общепринятого соглашения, по которому значение статической оценочной функции тем больше, чем больше преимуществ имеет игрок плюс (над игроком минус) в оцениваемой позиции.",оценочной функции,ai,1
"очень часто оценочная функция выбирается следующим образом: статическая оценочная функция положительна в игровых конфигурациях, где игрок плюс имеет преимущества; статическая оценочная функция отрицательна в конфигурациях, где минус имеет преимущества; статическая оценочная функция близка к нулю в позициях, не дающих преимущества ни одному из игроков.",оценочная функция,ai,1
"очень часто оценочная функция выбирается следующим образом: статическая оценочная функция положительна в игровых конфигурациях, где игрок плюс имеет преимущества; статическая оценочная функция отрицательна в конфигурациях, где минус имеет преимущества; статическая оценочная функция близка к нулю в позициях, не дающих преимущества ни одному из игроков.",статическая оценочная функция,ai,1
"для игры крестики-нолики на фиксированном квадрате возможна такая статиче ская оценочная функция: + , если p есть позиция выигрыша игрока плюс e(p) = , если p есть позиция выигрыша игрока минус (nl+ +nc+ +nd+ ) (nl +nc +nd ) в остальных случаях где: + очень большое положительное число; очень маленькое отрицательное число; nl+, nc+, nd+ соответственно число строк, столбцов и диагоналей, открытых для игрока плюс (т.е. где он еще может поставить три выигрышных крестика подряд); nl , nc , nd аналогичные числа для игрока минус.",оценочная функция,ai,1
на рис.18 приведены две игровые позиции (на квадрате 4 4) и соот ветствующие значения статической оценочной функции.,статической оценочной функции,ai,1
на рис.18 приведены две игровые позиции (на квадрате 4 4) и соот ветствующие значения статической оценочной функции.,оценочной функции,ai,1
"примеры статических оценок позиций игры ""крестики-нолики"" подчеркнем, что с помощью статической оценочной функции оцениваются только концевые вершины дерева игры, для оценок же промежуточных вершин, как и начальной вершины, используется минимакс ный принцип, основанный на следующей простой идее.",концевые вершины,ai,1
"примеры статических оценок позиций игры ""крестики-нолики"" подчеркнем, что с помощью статической оценочной функции оцениваются только концевые вершины дерева игры, для оценок же промежуточных вершин, как и начальной вершины, используется минимакс ный принцип, основанный на следующей простой идее.",статической оценочной функции,ai,1
"примеры статических оценок позиций игры ""крестики-нолики"" подчеркнем, что с помощью статической оценочной функции оцениваются только концевые вершины дерева игры, для оценок же промежуточных вершин, как и начальной вершины, используется минимакс ный принцип, основанный на следующей простой идее.",дерева игры,ai,1
"примеры статических оценок позиций игры ""крестики-нолики"" подчеркнем, что с помощью статической оценочной функции оцениваются только концевые вершины дерева игры, для оценок же промежуточных вершин, как и начальной вершины, используется минимакс ный принцип, основанный на следующей простой идее.",оценочной функции,ai,1
"сформулируем теперь сам минимаксный принцип: или-вершине дерева игры приписывается оценка, равная максимуму оценок ее дочерних вершин; и-вершине игрового дерева приписывается оценка, равная минимуму оценок ее дочерних вершин.",и-вершине,ai,1
"сформулируем теперь сам минимаксный принцип: или-вершине дерева игры приписывается оценка, равная максимуму оценок ее дочерних вершин; и-вершине игрового дерева приписывается оценка, равная минимуму оценок ее дочерних вершин.",или-вершине,ai,1
"сформулируем теперь сам минимаксный принцип: или-вершине дерева игры приписывается оценка, равная максимуму оценок ее дочерних вершин; и-вершине игрового дерева приписывается оценка, равная минимуму оценок ее дочерних вершин.",минимаксный принцип,ai,1
"сформулируем теперь сам минимаксный принцип: или-вершине дерева игры приписывается оценка, равная максимуму оценок ее дочерних вершин; и-вершине игрового дерева приписывается оценка, равная минимуму оценок ее дочерних вершин.",игрового дерева,ai,1
"сформулируем теперь сам минимаксный принцип: или-вершине дерева игры приписывается оценка, равная максимуму оценок ее дочерних вершин; и-вершине игрового дерева приписывается оценка, равная минимуму оценок ее дочерних вершин.",дерева игры,ai,1
"минимаксный принцип положен в основу минимаксной процедуры, предназначенной для определения наилучшего (более точно, достаточно хоро шего) хода игрока исходя из заданной конфигурации игры s при фиксиро ванной глубине поиска n в игровом дереве.",минимаксный принцип,ai,1
"минимаксный принцип положен в основу минимаксной процедуры, предназначенной для определения наилучшего (более точно, достаточно хоро шего) хода игрока исходя из заданной конфигурации игры s при фиксиро ванной глубине поиска n в игровом дереве.",минимаксной процедуры,ai,1
"минимаксный принцип положен в основу минимаксной процедуры, предназначенной для определения наилучшего (более точно, достаточно хоро шего) хода игрока исходя из заданной конфигурации игры s при фиксиро ванной глубине поиска n в игровом дереве.",глубине поиска,ai,1
"предполагается, что игрок плюс ходит первым (т.е. начальная вершина есть или-вершина).",или-вершина,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",статической оценочной функции,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",дерево игры,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",оценочной функции,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",минимаксной процедуры,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",алгоритмов перебора,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",дереву поиска,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",минимаксным принципом,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",алгоритмом поиска,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",концевые вершины,ai,1
"основные этапы этой процедуры таковы: дерево игры строится (просматривается) одним из известных алгоритмов перебора (как правило, алгоритмом поиска вглубь) от исходной позиции s до глубины n ; все концевые вершины полученного дерева, т.е. вершины, находя щиеся на глубине n, оцениваются с помощью статической оценочной функции; в соответствии с минимаксным принципом вычисляются оценки всех остальных вершин: сначала вычисляются оценки вершин, родительских для концевых, затем - родительских для этих родительских вершин и т.д.; такое оценивание вершин продолжается при движении снизу вверх по дереву поиска до тех пор, пока не будут оценены вершины, дочерние для начальной вершины, т.е. для исходной конфигурации s; среди вершин, дочерних к начальной, выбирается вершина с наибольшей оценкой: ход, который к ней ведет, и есть искомый наилучший ход в игровой конфигурации s. на рис.19 показано применение минимаксной процедуры для дерева игры, построенного до глубины n=3.",дерева игры,ai,1
"концевые вершины не имеют имен, они обозначены своими оценками значениями статической оценочной функции.",концевые вершины,ai,1
"концевые вершины не имеют имен, они обозначены своими оценками значениями статической оценочной функции.",статической оценочной функции,ai,1
"концевые вершины не имеют имен, они обозначены своими оценками значениями статической оценочной функции.",оценочной функции,ai,1
"числовые индексы имен остальных вершин показывают порядок, в котором эти вершины строились алгоритмом перебора вглубь.",алгоритмом перебора,ai,1
"рядом с этими вершинами находятся их минимаксные оценки, полученные при движении в обратном (по отношению к построению дерева) направлении.",минимаксные оценки,ai,1
"на данном игровом дереве выделена ветвь (последо вательность ходов игроков), представляющая так называемую минимаксно-оптимальную игру, при которой каждый из игроков всегда выбирает наилучший для себя ход.",минимаксно-оптимальную игру,ai,1
"заметим, что оценки всех вершин этой ветви дерева совпадают, и оценка начальной вершины равна оценке концевой вершины этой ветви.",концевой вершины,ai,1
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",статической оценочной функции,ai,1
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",статическую оценочную функцию,ai,1
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",оценочной функции,ai,1
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",минимаксной процедурой,ai,1
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",игровое дерево,ai,1
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",оценочную функцию,ai,1
"однако считается, что оценки, полученные с помощью минимаксной процедуры, более надежные меры относительного достоин ства промежуточных вершин, чем оценки, полученные прямым применением статической оценочной функции.",статической оценочной функции,ai,1
"однако считается, что оценки, полученные с помощью минимаксной процедуры, более надежные меры относительного достоин ства промежуточных вершин, чем оценки, полученные прямым применением статической оценочной функции.",минимаксной процедуры,ai,1
"однако считается, что оценки, полученные с помощью минимаксной процедуры, более надежные меры относительного достоин ства промежуточных вершин, чем оценки, полученные прямым применением статической оценочной функции.",оценочной функции,ai,1
"действительно, минимаксные оценки основаны на просмотре игры вперед и учитывают разные особенности, которые могут возникнуть в последующем, в то время как простое применение оценочной функции учитывает лишь свойства позиции как таковой.",оценочной функции,ai,1
"действительно, минимаксные оценки основаны на просмотре игры вперед и учитывают разные особенности, которые могут возникнуть в последующем, в то время как простое применение оценочной функции учитывает лишь свойства позиции как таковой.",минимаксные оценки,ai,1
"это отличие статических и минимаксных оценок существенно для активных , динамичных позиций игры (например, в шашках и шахматах к ним относятся конфигурации, в которых возникает угроза взятия одной или нескольких фигур).",минимаксных оценок,ai,1
в случае же так называемых пассивных (спокойных) позиций статическая оценка может мало отличаться от оценки по минимаксному принципу.,минимаксному принципу,ai,1
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",минимаксной процедуре,ai,1
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",минимаксная процедура,ai,1
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",дерева игры,ai,1
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",альфа-бета процедура,ai,1
"для повышения эффективности поиска необходимо вычислять оценки (статические и минимаксные) вершин одновременно с построением игрового дерева и не рассматривать вершины, которые хуже уже построенных вершин.",игрового дерева,ai,1
"это приводит к так называемой альфа-бета процедуре поиска наилучшего первого хода от заданной позиции, в основе которой лежит достаточно очевидное сообра жение для сокращения поиска: если есть два варианта хода одного игрока, то худший в ряде случаев можно сразу отбросить, не выясняя, насколько в точности он хуже.",альфа-бета процедуре,ai,1
"рассмотрим сначала идею работы альфа-бета процедуры на примере игрового дерева, приведенного на рис.19.",альфа-бета процедуры,ai,1
"рассмотрим сначала идею работы альфа-бета процедуры на примере игрового дерева, приведенного на рис.19.",игрового дерева,ai,1
дерево игры строится до глубины n=3 алгоритмом перебора вглубь.,дерево игры,ai,1
дерево игры строится до глубины n=3 алгоритмом перебора вглубь.,алгоритмом перебора,ai,1
"причем сразу, как это становится возможным, вычисляются не только статические оценки концевых вершин, но и предварительные минимаксные оценки промежуточных вершин.",концевых вершин,ai,1
"причем сразу, как это становится возможным, вычисляются не только статические оценки концевых вершин, но и предварительные минимаксные оценки промежуточных вершин.",минимаксные оценки,ai,1
предварительная оценка определяется соответственно как минимум или максимум уже известных к настоящему моменту оценок дочерних вершин.,предварительная оценка,ai,1
"в ходе дальнейшего построения дерева игры и получения новых оценок вершин предварительные оценки постепенно уточняются, опять же по минимаксному принципу.",предварительные оценки,ai,1
"в ходе дальнейшего построения дерева игры и получения новых оценок вершин предварительные оценки постепенно уточняются, опять же по минимаксному принципу.",дерева игры,ai,1
"в ходе дальнейшего построения дерева игры и получения новых оценок вершин предварительные оценки постепенно уточняются, опять же по минимаксному принципу.",минимаксному принципу,ai,1
"эти листья оценены статической функцией, и вершина w2+ получила точную минимаксную оценку 3, а вершина w1 предварительную оценку 3.",минимаксную оценку,ai,1
"эти листья оценены статической функцией, и вершина w2+ получила точную минимаксную оценку 3, а вершина w1 предварительную оценку 3.",предварительную оценку,ai,1
"далее при построении и раскрытии вершины w3+ статическая оценка первой ее дочерней вершины дает величину 4, которая становится предварительной оценкой самой вершины w3+.",раскрытии вершины,ai,1
"далее при построении и раскрытии вершины w3+ статическая оценка первой ее дочерней вершины дает величину 4, которая становится предварительной оценкой самой вершины w3+.",предварительной оценкой,ai,1
"эта предварительная оценка будет потом, после построения второй ее дочерней вершины, пересчитана.",предварительная оценка,ai,1
"причем согласно минимаксному принципу оценка может только увеличиться (поскольку подсчитывается как максимум оценок дочерних вершин), но даже если она увеличится, это не повлияет на оценку вершины w1 , поскольку последняя при уточнении по минимаксному принци пу может только уменьшаться (так как равна минимуму оценок дочерних вершин).",минимаксному принципу,ai,1
такое сокращение поиска в игровом дереве называется отсечением ветвей.,отсечением ветвей,ai,1
такое сокращение поиска в игровом дереве называется отсечением ветвей.,отсечением,ai,1
"игровое дерево, построенное альфа-бета процедурой продолжим для нашего примера процесс поиска в глубину с одновременным вычислением предварительных (и точных, где это возможно) оценок вершин вплоть до момента, когда построены уже вершины w4 , w5+ и две дочерних последней, которые оцениваются статической функцией.",игровое дерево,ai,1
"вершина w5+ получила точную минимаксную оценку 3, а ее родительская w4 получила пока только предварительную оценку 3.",минимаксную оценку,ai,1
"вершина w5+ получила точную минимаксную оценку 3, а ее родительская w4 получила пока только предварительную оценку 3.",предварительную оценку,ai,1
"эта пред варительная оценка вершины w4 может быть уточнена в дальнейшем, но в соответствии с минимаксным принципом возможно только ее уменьшение, и это уменьшение не повлияет на оценку вершины w0+, поскольку последняя, опять же согласно минимаксному принципу, может только увеличиваться.",минимаксным принципом,ai,1
"эта пред варительная оценка вершины w4 может быть уточнена в дальнейшем, но в соответствии с минимаксным принципом возможно только ее уменьшение, и это уменьшение не повлияет на оценку вершины w0+, поскольку последняя, опять же согласно минимаксному принципу, может только увеличиваться.",минимаксному принципу,ai,1
"на этом построение игрового дерева заканчивается, полученный резуль тат лучший первый ход тот же самый, что и при минимаксной процедуре.",минимаксной процедуре,ai,1
"на этом построение игрового дерева заканчивается, полученный резуль тат лучший первый ход тот же самый, что и при минимаксной процедуре.",игрового дерева,ai,1
"у некоторых вершин дерева осталась неуточненная, предварительная оценка, однако этих приближенных оценок оказалось достаточно для того, чтобы определить точную минимаксную оценку начальной вершины и наилучший первый ход.",минимаксную оценку,ai,1
"у некоторых вершин дерева осталась неуточненная, предварительная оценка, однако этих приближенных оценок оказалось достаточно для того, чтобы определить точную минимаксную оценку начальной вершины и наилучший первый ход.",предварительная оценка,ai,1
в то же время произошло существенное сокращение поиска: вместо 17 вершин построено только 11 и вместо 10 обращений к статической оценочной функции понадобилось всего 6.,статической оценочной функции,ai,1
в то же время произошло существенное сокращение поиска: вместо 17 вершин построено только 11 и вместо 10 обращений к статической оценочной функции понадобилось всего 6.,оценочной функции,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",предварительных оценок,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",или-вершины,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",статической оценочной функцией,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",оценочной функцией,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",бета-величина,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",предварительная оценка,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",игрового дерева,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",дерева игры,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",концевая вершина,ai,1
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",и-вершины,ai,1
"укажем очевидное следствие этих правил вычисления: альфа-величины не могут уменьшаться, а бета-величины не могут увеличиваться.",бета-величины,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",или-вершин,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",альфа-величина,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",или-вершины,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",отсечения,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",отсечения ветвей,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",бета-величина,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",игрового дерева,ai,1
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",и-вершины,ai,1
"в случае а говорят, что имеет место альфа-отсечение, поскольку отсекаются ветви дерева, начиная с или-вершин, которым припи сана альфа-величина, а в случае в бета-отсечение, поскольку отсекаются ветви, начи нающиеся с бета-величин.",или-вершин,ai,1
"в случае а говорят, что имеет место альфа-отсечение, поскольку отсекаются ветви дерева, начиная с или-вершин, которым припи сана альфа-величина, а в случае в бета-отсечение, поскольку отсекаются ветви, начи нающиеся с бета-величин.",альфа-величина,ai,1
"в случае а говорят, что имеет место альфа-отсечение, поскольку отсекаются ветви дерева, начиная с или-вершин, которым припи сана альфа-величина, а в случае в бета-отсечение, поскольку отсекаются ветви, начи нающиеся с бета-величин.",бета-отсечение,ai,1
"в случае а говорят, что имеет место альфа-отсечение, поскольку отсекаются ветви дерева, начиная с или-вершин, которым припи сана альфа-величина, а в случае в бета-отсечение, поскольку отсекаются ветви, начи нающиеся с бета-величин.",отсечение,ai,1
"в случае а говорят, что имеет место альфа-отсечение, поскольку отсекаются ветви дерева, начиная с или-вершин, которым припи сана альфа-величина, а в случае в бета-отсечение, поскольку отсекаются ветви, начи нающиеся с бета-величин.",бета-величин,ai,1
"важно, что рассмотренные правила работают в ходе построения игрового дерева вглубь; это означает, что предварительные оценки промежу точных вершин появляются лишь по мере продвижения от концевых вершин дерева вверх к корню и реально отсечения могут начаться только после того, как получена хотя бы одна точная минимаксная оценка промежуточной вершины.",концевых вершин,ai,1
"важно, что рассмотренные правила работают в ходе построения игрового дерева вглубь; это означает, что предварительные оценки промежу точных вершин появляются лишь по мере продвижения от концевых вершин дерева вверх к корню и реально отсечения могут начаться только после того, как получена хотя бы одна точная минимаксная оценка промежуточной вершины.",минимаксная оценка,ai,1
"важно, что рассмотренные правила работают в ходе построения игрового дерева вглубь; это означает, что предварительные оценки промежу точных вершин появляются лишь по мере продвижения от концевых вершин дерева вверх к корню и реально отсечения могут начаться только после того, как получена хотя бы одна точная минимаксная оценка промежуточной вершины.",отсечения,ai,1
"важно, что рассмотренные правила работают в ходе построения игрового дерева вглубь; это означает, что предварительные оценки промежу точных вершин появляются лишь по мере продвижения от концевых вершин дерева вверх к корню и реально отсечения могут начаться только после того, как получена хотя бы одна точная минимаксная оценка промежуточной вершины.",предварительные оценки,ai,1
"важно, что рассмотренные правила работают в ходе построения игрового дерева вглубь; это означает, что предварительные оценки промежу точных вершин появляются лишь по мере продвижения от концевых вершин дерева вверх к корню и реально отсечения могут начаться только после того, как получена хотя бы одна точная минимаксная оценка промежуточной вершины.",игрового дерева,ai,1
"в рассмотренном на рис.20 примере первое прерывание перебора было бета-отсечением, а второе альфа-отсечением.",бета-отсечением,ai,1
"в рассмотренном на рис.20 примере первое прерывание перебора было бета-отсечением, а второе альфа-отсечением.",отсечением,ai,1
"причем в обоих случаях отсечение было неглубоким, поскольку необходимая для соблюдения соот ветствующего правила отсечения альфа- или бета-величина находилась в непосредственно предшествующей к точке отсечения вершине.",бета-величина,ai,1
"причем в обоих случаях отсечение было неглубоким, поскольку необходимая для соблюдения соот ветствующего правила отсечения альфа- или бета-величина находилась в непосредственно предшествующей к точке отсечения вершине.",отсечение,ai,1
"причем в обоих случаях отсечение было неглубоким, поскольку необходимая для соблюдения соот ветствующего правила отсечения альфа- или бета-величина находилась в непосредственно предшествующей к точке отсечения вершине.",отсечения,ai,1
"в общем же случае она может находиться существенно выше отсекаемой ветви где-то на пути от вершины, ниже которой производится отсечение, к начальной вершине дерева, включая последнюю.",отсечение,ai,1
"после прерывания перебора предварительные оценки вершин в точках отсечения остаются неуточненными, но, как уже отмечалось, это не препятствует правильному нахождению предварительных оценок всех предшествующих вершин, как и точной оценки корневой вершины и ее дочерних вершин, а значит, и искомого наилучшего первого хода.",предварительные оценки,ai,1
"после прерывания перебора предварительные оценки вершин в точках отсечения остаются неуточненными, но, как уже отмечалось, это не препятствует правильному нахождению предварительных оценок всех предшествующих вершин, как и точной оценки корневой вершины и ее дочерних вершин, а значит, и искомого наилучшего первого хода.",предварительных оценок,ai,1
"после прерывания перебора предварительные оценки вершин в точках отсечения остаются неуточненными, но, как уже отмечалось, это не препятствует правильному нахождению предварительных оценок всех предшествующих вершин, как и точной оценки корневой вершины и ее дочерних вершин, а значит, и искомого наилучшего первого хода.",отсечения,ai,1
"на приведенных выше правилах вычисления оценок вершин и выполнения отсечений (всюду, где это возможно) основана альфа-бета процедура, являющаяся более эффективной реализацией минимаксного принципа.",отсечений,ai,1
"на приведенных выше правилах вычисления оценок вершин и выполнения отсечений (всюду, где это возможно) основана альфа-бета процедура, являющаяся более эффективной реализацией минимаксного принципа.",минимаксного принципа,ai,1
"в принципе, используя математическую индукцию и рассуждая, как показано на примере, несложно доказать следующее утверждение: альфа-бета процедура всегда приводит к тому же результату (наилучшему первому ходу), что и простая минимаксная процедура той же глубины.",минимаксная процедура,ai,1
"важным является вопрос о том, насколько в среднем альфа-бета процедура эффективнее обычной минимаксной процедуры.",минимаксной процедуры,ai,1
"нетрудно заметить, что количество отсечений в альфа-бета процедуре зависит от степени, в которой предварительные оценки (альфа- и бета-величины), полученные первыми, аппроксимируют окончательные минимаксные оценки: чем ближе эти оценки, тем больше отсечений и меньше перебор.",бета-величины,ai,1
"нетрудно заметить, что количество отсечений в альфа-бета процедуре зависит от степени, в которой предварительные оценки (альфа- и бета-величины), полученные первыми, аппроксимируют окончательные минимаксные оценки: чем ближе эти оценки, тем больше отсечений и меньше перебор.",предварительные оценки,ai,1
"нетрудно заметить, что количество отсечений в альфа-бета процедуре зависит от степени, в которой предварительные оценки (альфа- и бета-величины), полученные первыми, аппроксимируют окончательные минимаксные оценки: чем ближе эти оценки, тем больше отсечений и меньше перебор.",отсечений,ai,1
"нетрудно заметить, что количество отсечений в альфа-бета процедуре зависит от степени, в которой предварительные оценки (альфа- и бета-величины), полученные первыми, аппроксимируют окончательные минимаксные оценки: чем ближе эти оценки, тем больше отсечений и меньше перебор.",минимаксные оценки,ai,1
"20, в котором ветвь дерева с минимаксно-оптимальной игрой строится практически в самом начале поиска.",минимаксно-оптимальной игрой,ai,1
"таким образом, эффективность альфа-бета процедуры зависит от порядка построения и раскрытия вершин в дереве игры.",альфа-бета процедуры,ai,1
"таким образом, эффективность альфа-бета процедуры зависит от порядка построения и раскрытия вершин в дереве игры.",раскрытия вершин,ai,1
"возможен и неудачный порядок просмотра, при котором придется пройти без отсечений через все вершины дерева, и в этом, худшем, случае альфа-бета процедура не будет иметь никаких преимуществ по сравнению с минимаксной процедурой.",отсечений,ai,1
"возможен и неудачный порядок просмотра, при котором придется пройти без отсечений через все вершины дерева, и в этом, худшем, случае альфа-бета процедура не будет иметь никаких преимуществ по сравнению с минимаксной процедурой.",альфа-бета процедура,ai,1
"возможен и неудачный порядок просмотра, при котором придется пройти без отсечений через все вершины дерева, и в этом, худшем, случае альфа-бета процедура не будет иметь никаких преимуществ по сравнению с минимаксной процедурой.",минимаксной процедурой,ai,1
"наибольшее число отсечений достигается, когда при переборе в глубину первой обнаруживается конечная вершина, статическая оценка которой станет в последствии минимаксной оценкой начальной вершины.",минимаксной оценкой,ai,1
"наибольшее число отсечений достигается, когда при переборе в глубину первой обнаруживается конечная вершина, статическая оценка которой станет в последствии минимаксной оценкой начальной вершины.",отсечений,ai,1
при максимальном числе отсечений строится и оценивается мини мальное число концевых вершин.,концевых вершин,ai,1
при максимальном числе отсечений строится и оценивается мини мальное число концевых вершин.,отсечений,ai,1
"показано [нильсон73, раздел 5.14], что в случае, когда самые сильные ходы рассматриваются первыми, количество концевых вершин глубины n, которые будут построены и оценены альфа-бета процедурой, примерно равно числу концевых вершин, которые были бы построены и оценены на глубине n/2 обычной минимаксной процедурой.",концевых вершин,ai,1
"показано [нильсон73, раздел 5.14], что в случае, когда самые сильные ходы рассматриваются первыми, количество концевых вершин глубины n, которые будут построены и оценены альфа-бета процедурой, примерно равно числу концевых вершин, которые были бы построены и оценены на глубине n/2 обычной минимаксной процедурой.",альфа-бета процедурой,ai,1
"показано [нильсон73, раздел 5.14], что в случае, когда самые сильные ходы рассматриваются первыми, количество концевых вершин глубины n, которые будут построены и оценены альфа-бета процедурой, примерно равно числу концевых вершин, которые были бы построены и оценены на глубине n/2 обычной минимаксной процедурой.",минимаксной процедурой,ai,1
"таким образом, при фиксированном времени и памяти альфа-бета процедура сможет пройти при поиске вдвое глубже по сравнению с обычной минимаксной процедурой.",альфа-бета процедура,ai,1
"таким образом, при фиксированном времени и памяти альфа-бета процедура сможет пройти при поиске вдвое глубже по сравнению с обычной минимаксной процедурой.",минимаксной процедурой,ai,1
"в заключение отметим, что статическая оценочная функция и альфа-бета процедура две непременные составляющие почти всех компьютерных игро вых программ (в том числе коммерческих).",оценочная функция,ai,1
"в заключение отметим, что статическая оценочная функция и альфа-бета процедура две непременные составляющие почти всех компьютерных игро вых программ (в том числе коммерческих).",статическая оценочная функция,ai,1
"в заключение отметим, что статическая оценочная функция и альфа-бета процедура две непременные составляющие почти всех компьютерных игро вых программ (в том числе коммерческих).",альфа-бета процедура,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",эвристической функции,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",статической оценочной функции,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",статическая оценочная функция,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",оценочной функции,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",минимаксных оценок,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",отсечение,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",отсечения,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",оценочная функция,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",отсечения ветвей,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",дерева игры,ai,1
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",отсечений,ai,1
"3.4 плэнер-алгоритмы поиска на игровых деревьях рассмотрим сначала описание на языке плэнер функции min max, реализующей минимаксную процедуру.",игровых деревьях,ai,1
"3.4 плэнер-алгоритмы поиска на игровых деревьях рассмотрим сначала описание на языке плэнер функции min max, реализующей минимаксную процедуру.",алгоритмы поиска,ai,1
"3.4 плэнер-алгоритмы поиска на игровых деревьях рассмотрим сначала описание на языке плэнер функции min max, реализующей минимаксную процедуру.",минимаксную процедуру,ai,1
"аргументы этой функции: instate исходная позиция игры, для которой ищется наилучший ход; n глубина поиска, т.е. количество ходов вперед.",глубина поиска,ai,1
"первая функция, select max выбирает из своего единственного аргумента-списка, состоящего из позиций и их оценок, позицию с наибольшей оценкой: [define select max (lambda (list) [prog (elem max elem) [fin max elem list] sm [cond ([fin elem list] [return [2 .max elem]]) ([gt [1 .elem] [1 .max elem]] [set max elem .elem])] [go sm]] )] функция mm evalp с тремя аргументами является главной рекурсивной функцией, оценивающей вершины дерева игры по минимаксному принципу.",дерева игры,ai,1
"первая функция, select max выбирает из своего единственного аргумента-списка, состоящего из позиций и их оценок, позицию с наибольшей оценкой: [define select max (lambda (list) [prog (elem max elem) [fin max elem list] sm [cond ([fin elem list] [return [2 .max elem]]) ([gt [1 .elem] [1 .max elem]] [set max elem .elem])] [go sm]] )] функция mm evalp с тремя аргументами является главной рекурсивной функцией, оценивающей вершины дерева игры по минимаксному принципу.",рекурсивной функцией,ai,1
"первая функция, select max выбирает из своего единственного аргумента-списка, состоящего из позиций и их оценок, позицию с наибольшей оценкой: [define select max (lambda (list) [prog (elem max elem) [fin max elem list] sm [cond ([fin elem list] [return [2 .max elem]]) ([gt [1 .elem] [1 .max elem]] [set max elem .elem])] [go sm]] )] функция mm evalp с тремя аргументами является главной рекурсивной функцией, оценивающей вершины дерева игры по минимаксному принципу.",минимаксному принципу,ai,1
"при работе mm evalp используются вспомогательные функции, определение которых зависит от конкретной игры: opening, вычисляющая для заданной позиции игры список дочерних вершин-позиций, и stat est статическая оценочная функция.",оценочная функция,ai,1
"при работе mm evalp используются вспомогательные функции, определение которых зависит от конкретной игры: opening, вычисляющая для заданной позиции игры список дочерних вершин-позиций, и stat est статическая оценочная функция.",статическая оценочная функция,ai,1
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",развилка,ai,1
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",развилку,ai,1
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",развилки,ai,1
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",минимаксному принципу,ai,1
(.dvalue .d))] )] % 6: возврат к другой альтернативе развилки; [fail] ])],развилки,ai,1
"она имеет сходную с min max структуру: [define alpha beta (lambda (instate n) [select max [ab evalp .instate 0 t () () ]] )] аргументы этой функции: instate заданная позиция игры, для которой ищется лучший ход, n - глубина поиска.",глубина поиска,ai,1
"вторая функция, ab evalp - главная рекурсивная функция, которая эффективно оценивает вершины дерева игры по минимаксному принципу с выполнением отсечений.",рекурсивная функция,ai,1
"вторая функция, ab evalp - главная рекурсивная функция, которая эффективно оценивает вершины дерева игры по минимаксному принципу с выполнением отсечений.",дерева игры,ai,1
"вторая функция, ab evalp - главная рекурсивная функция, которая эффективно оценивает вершины дерева игры по минимаксному принципу с выполнением отсечений.",отсечений,ai,1
"вторая функция, ab evalp - главная рекурсивная функция, которая эффективно оценивает вершины дерева игры по минимаксному принципу с выполнением отсечений.",минимаксному принципу,ai,1
"для проведения отсечений функция использует вспомогательные величины amax и bmin, являющиеся соответственно максимальной из альфа-величин и минимальной из бета-величин вершин, предшествующих оцениваемой вершине pos.",альфа-величин,ai,1
"для проведения отсечений функция использует вспомогательные величины amax и bmin, являющиеся соответственно максимальной из альфа-величин и минимальной из бета-величин вершин, предшествующих оцениваемой вершине pos.",отсечений,ai,1
"для проведения отсечений функция использует вспомогательные величины amax и bmin, являющиеся соответственно максимальной из альфа-величин и минимальной из бета-величин вершин, предшествующих оцениваемой вершине pos.",бета-величин,ai,1
"эти величины необходимы для проверки условий правил отсечений, поэтому отсечения не могут быть выполнены, пока величины не определены (альфа-отсечение пока неизвестна величина bmin, а бета-отсечение пока неизвестна amaх ).",бета-отсечение,ai,1
"эти величины необходимы для проверки условий правил отсечений, поэтому отсечения не могут быть выполнены, пока величины не определены (альфа-отсечение пока неизвестна величина bmin, а бета-отсечение пока неизвестна amaх ).",отсечение,ai,1
"эти величины необходимы для проверки условий правил отсечений, поэтому отсечения не могут быть выполнены, пока величины не определены (альфа-отсечение пока неизвестна величина bmin, а бета-отсечение пока неизвестна amaх ).",отсечений,ai,1
"эти величины необходимы для проверки условий правил отсечений, поэтому отсечения не могут быть выполнены, пока величины не определены (альфа-отсечение пока неизвестна величина bmin, а бета-отсечение пока неизвестна amaх ).",отсечения,ai,1
эти значения станут известны только лишь когда часть дерева игры будет просмотрена до заданной глубины.,дерева игры,ai,1
"функция ab evalp (как и mm evalp) использует вспомогательные функции, определение которых зависит от конкретной игры: opening, вычисляющую для заданной позиции игры список дочерних вершин-позиций, и stat est статическую оценочную функцию.",статическую оценочную функцию,ai,1
"функция ab evalp (как и mm evalp) использует вспомогательные функции, определение которых зависит от конкретной игры: opening, вычисляющую для заданной позиции игры список дочерних вершин-позиций, и stat est статическую оценочную функцию.",оценочную функцию,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",развилку,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",статической оценочной функции,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",развилка,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",оценочной функции,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",предварительной оценки,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",минимаксному принципу,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",отсечение,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",отсечения,ai,1
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",развилки,ai,1
(.dvalue .d))] )] % 7: возврат к другой альтернативе развилки ; [fail] ])],развилки,ai,1
"обе рассмотренные процедуры, min max и alpha beta, должны быть соответствующим образом модифицированы, если при просмотре позиций на заданную глубину n возможно появление выигрышной или проигрышной позиции, обрывающих некоторые ветви игрового дерева.",игрового дерева,ai,1
в этом случае к таким позициям необходимо сразу применить статическую оценочную функцию.,статическую оценочную функцию,ai,1
в этом случае к таким позициям необходимо сразу применить статическую оценочную функцию.,оценочную функцию,ai,1
"заметим в заключении, что в случае выбора языка лисп для реализации процедур поиска на игровых деревьях минимаксная процедура может быть запрограммировано весьма кратко и понятно, особенно при использовании функционалов.",игровых деревьях,ai,1
"заметим в заключении, что в случае выбора языка лисп для реализации процедур поиска на игровых деревьях минимаксная процедура может быть запрограммировано весьма кратко и понятно, особенно при использовании функционалов.",минимаксная процедура,ai,1
"что же касается альфа-бета процедуры, то программа на лиспе [уинстон, глава 13] существенно более громоздка и трудна для понимания, чем приведенная выше плэнер-функция, поскольку в последней применяется встроенный механизм возвратов.",альфа-бета процедуры,ai,1
"что же касается альфа-бета процедуры, то программа на лиспе [уинстон, глава 13] существенно более громоздка и трудна для понимания, чем приведенная выше плэнер-функция, поскольку в последней применяется встроенный механизм возвратов.",механизм возвратов,ai,1
"ниже кратко описаны некоторые из встроенных функций те, что были использованы в предыдущих разделах пособия.",встроенных функций,ai,1
"отметим, что таким образом определяется обычная лисп-функция, т.е. функция с фиксированным количеством аргументов, которые всегда вычисляются при обращении к ней.",лисп-функция,ai,1
"все рассмотренные выше лисп-функции называются селекторами, так как они выбирают определенные элементы списков.",лисп-функции,ai,1
"определение новых функций для определения новой функции следует обратиться к встроенной функции define: [define f dexp] вычисление функции define в качестве побочного эффекта приводит к появлению в программе новой функции с именем f и с так называемым определяющим выражением dexp, которое должно иметь следующий вид: (lambda (v1 v2 ... vn) e) (n 0) где vi - формальные параметры новой функции, а e - форма, зависящая от vi .",встроенной функции,ai,1
режим возвратов в язык плэнер встроен т.н.,режим возвратов,ai,1
"режим возвратов, который упрощает реализацию различных поисковых алгоритмов, использующих перебор вариантов.",режим возвратов,ai,1
"если затем окажется, что этот вариант неуспешен, тогда вырабатывается т.н. неуспех, по которому программа автоматически откатывается к последней (по времени) развилке, отменяя при этом все изменения (в значениях переменных и т.п.), произведенные на неуспешном пути, и в этой развилке выбирается следующий вариант, после чего программа снова идет вперед .",развилке,ai,1
"если в развилке уже не оказалось нерассмотренных альтернатив, то неуспех возвращает программу к предыдущей развилке.",развилке,ai,1
"успешно или нет завершилось вычисление очередного выражения программы, далее будет вычисляться следующее выражение.) в каких местах программы ставить развилки и с какими альтернативами, считать ли выбранный путь вычисления неуспешным и когда вырабатывать неуспех за все это отвечает автор программы.",развилки,ai,1
"встроенный же режим возвратов обеспечивает запоминание мест развилок и то, какие альтернативы в них еще не рассматривались, обеспечивает возврат программы по неуспеху к последней развилке и отмену ранее произведенных изменений в значениях переменных.",развилок,ai,1
"встроенный же режим возвратов обеспечивает запоминание мест развилок и то, какие альтернативы в них еще не рассматривались, обеспечивает возврат программы по неуспеху к последней развилке и отмену ранее произведенных изменений в значениях переменных.",режим возвратов,ai,1
"встроенный же режим возвратов обеспечивает запоминание мест развилок и то, какие альтернативы в них еще не рассматривались, обеспечивает возврат программы по неуспеху к последней развилке и отмену ранее произведенных изменений в значениях переменных.",развилке,ai,1
"ниже перечислены некоторые из встроенных функций языка плэнер, позволяющих реализовать режим возвратов.",встроенных функций,ai,1
"ниже перечислены некоторые из встроенных функций языка плэнер, позволяющих реализовать режим возвратов.",режим возвратов,ai,1
"если этот список пуст, функция вырабатывает неуспех, который автоматически возвращает программу к предыдущей ее развилке.",развилке,ai,1
"иначе функция запоминает развилку, альтернативами которой является то, что функция в качестве своего значения может выдать любой элемент из этого списка.",развилку,ai,1
"но если позже в программе возникнет неуспех, который вернет ее вычисление к данной развилке, то функция возобновит свою работу и теперь как свое значение выдаст второй элемент списка, после чего программа снова возобновит свои вычисления от этого места.",развилке,ai,1
"после выдачи в качестве своего значения последнего элемента списка, функция уничтожает свою развилку.",развилку,ai,1
"[fail] эта функция вырабатывает неуспех, по которому программа автоматически возвращается к последней (по времени) развилке.",развилке,ai,1
"[permex e f] функция осуществляет выход из ближайшей объемлющей функции с именем f и объявляет ее результатом значение аргумента e. при этом уничтожаются все развилки, появившиеся в программе с начала вычисления этой функции f, и замораживаются все изменения (в значениях переменных и т.п.), произведенные внутри этой функции.",развилки,ai,1
"определение: дерево называется деревом вывода (или деревом разбора) в кс-грамматике g = {vt, vn, p, s), если выполнены следующие условия: (1) каждая вершина дерева помечена символом из множества (vn vt ) , при этом корень дерева помечен символом s; листья - символами из (vt ); (2) если вершина дерева помечена символом a vn, а ее непосредственные потомки - символами a1, a2, ... , an, где каждое ai (vt vn), то a a1a2...an - правило вывода в этой грамматике; (3) если вершина дерева помечена символом a vn, а ее единственный непосредственный потомок помечен символом , то a - правило вывода в этой грамматике.",потомки,gramm,0
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",случаях,gramm,0
"представление лексем: все лексемы м-языка разделим на несколько классов; классы перенумеруем: служебные слова - 1, ограничители - 2, константы (целые числа) - 3, идентификаторы - 4.",ограничители,gramm,0
"лексический анализатор для модельного языка будем писать в два этапа: сначала построим диаграмму состояний с действиями для распознавания и формирования внутреннего представления лексем, а затем по ней напишем программу анализатора.",формирования внутреннего,gramm,0
"тип 3: грамматика g = (vt, vn, p, s) называется праволинейной, если каждое правило из р имеет вид a tb либо a t, где a vn, b vn, t vt.",правило,gramm,0
"в программе-интерпретаторе будем использовать некоторые переменные и функции, введенные нами ранее.",программе-,gramm,0
"определение: декартовым произведением a b множеств a и b называется множество { (a,b) a a, b b}.",множество,gramm,0
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",процедуру,gramm,0
"преобразования грамматик в некоторых случаях кс-грамматика может содержать недостижимые и бесплодные символы, которые не участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики.",порождении,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",программе идентификатор,gramm,0
"обработка описаний для контроля согласованности типов в выражениях и типов выражений в операторах, необходимо знать типы переменных, входящих в эти выражения.",описаний,gramm,0
"пусть есть функции: void clear (void); - очистка буфера buf; void add (void); - добавление символа с в конец буфера buf; int look (ptabl т); - поиск в таблице т лексемы из буфера buf; результат: номер строки таблицы с информацией о лексеме либо 0, если такой лексемы в таблице т нет; int putl (ptabl т);",строки таблицы,gramm,0
"его можно выполнять сразу после синтаксического анализа, некоторые требования можно контролировать во время генерации кода (например, ограничения на типы операндов в выражении), а можно совместить с синтаксическим анализом.",выражении,gramm,0
лексический анализатор заполнил поле name; значения полей declare и type будем заполнять на этапе семантического анализа.,значения,gramm,0
"общий вид этих правил: l a a,l ( либо в сокращенной форме l a {,a} ) 41 формально здесь не выполняются условия применимости метода рекурсивного спуска, т.к. две альтернативы начинаются одинаковыми терминальными символами.",символами,gramm,0
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",лексемами,gramm,0
"устранить неоднозначность можно, по крайней мере, двумя способами: a) заменить унарную операцию бинарной, т.е. считать, что ""- а"" означает ""0-а""; 58 b) либо ввести специальный знак для обозначения унарной операции; например, ""-а"" заменить на "" a"".",крайней мере,gramm,0
"\n""); else printf(""o.k.!!!\n""); } синтаксический и семантический анализ на этапе синтаксического анализа нужно установить, имеет ли цепочка лексем структуру, заданную синтаксисом языка, и зафиксировать эту структуру.",анализ,gramm,0
"eq ("":"")) error(); else {curr lex = getlex (); if (eq (""int"")) {curr lex = getlex (); dec (""int"");} else if (eq (""bool"")) {curr lex = getlex(); dec (""bool"");} else error(); } } } генерация внутреннего представления программ результатом работы синтаксического анализатора должно быть некоторое внутреннее представление исходной цепочки лексем, которое отражает ее синтаксическую структуру.",внутреннего представления программ результатом,gramm,0
"таким образом, язык, порождаемый грамматикой, можно определить как множество терминальных сентенциальных форм.",образом,gramm,0
"если договориться, что else должно соответствовать ближайшему к нему then, и подправить грамматику g, то неоднозначность будет устранена: s if b then s if b then s else s a s if b then s else s a проблема, порождает ли данная кс-грамматика однозначный язык (т.е. существует ли эквивалентная ей однозначная грамматика), является алгоритмически неразрешимой.",грамматика однозначный,gramm,0
"особое внимание уделяется контекстно-свободным грамматикам и, в частности, их важному подклассу - регулярным грамматикам.",свободным грамматикам,gramm,0
"попытаемся ослабить требования на вид правил грамматики: (1) при описании синтаксиса языков программирования часто встречаются правила, описывающие последовательность однотипных конструкций, отделенных друг от друга каким-либо знаком-разделителем (например, список идентификаторов при описании переменных, список параметров при вызове процедур и функций и т.п.).",синтаксиса,gramm,0
для описания синтаксиса языков программирования стараются использовать однозначные приведенные кс- грамматики.,синтаксиса языков,gramm,0
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); если при анализе идентификатора i проверить, описан ли он, и занести его тип в тот же стек ( для этого можно использовать функцию checkid() ), то достаточно будет в нужный момент считать из стека два элемента и сравнить их: void eqtype (void) { if (strcmp (spop (), spop ())) error();} следовательно, правило для оператора присваивания: i <checkid()> := e <eqtype()> 51 2) условный оператор и оператор цикла if e then s else s while e do s контекстные условия: в условном операторе и в операторе цикла в качестве условия возможны только логические выражения.",оператора,gramm,0
"имея такое правило грамматики, легко написать процедуру для метода рекурсивного спуска, которая будет выполнять синтаксический анализ и некоторые дополнительные действия: void a() { if (c=='a') {c = fgetc(fp); d1(); b(); d1(); d2();} else if (c == 'b') {c = fgetc(fp); c(); d3();} else error(); } пример: написать грамматику, которая позволит распознавать цепочки языка l = { (0,1)+ содержит равное количество 0 и 1}.",равное количество,gramm,0
"предполагается, что термин ""символ"" имеет достаточно ясный интуитивный смысл и не нуждается в дальнейшем уточнении.",термин,gramm,0
"обработка описаний для контроля согласованности типов в выражениях и типов выражений в операторах, необходимо знать типы переменных, входящих в эти выражения.",операторах,gramm,0
определение: в противном случае грамматика называется однозначной.,случае грамматика,gramm,0
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",наборы,gramm,0
"10 замечание: укс-грамматика, содержащая правила вида a , не является кз-грамматикой и не является неукорачивающей грамматикой.",правила вида,gramm,0
"однако перед лексическим анализатором стоит более сложная задача: он должен сам выделить в исходном тексте цепочку символов, представляющую лексему, а также преобразовать ее в пару (тип лексемы, указатель на информацию о ней).",тексте,gramm,0
"можно преобразовать правила вывода данного нетерминала, объединив правила с общими началами в одно правило: a aa 1 ... m a 1 2 ... n будет получена грамматика, эквивалентная данной.",общими началами,gramm,0
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",нетерминалом b,gramm,0
(учебное пособие для студентов ii курса),пособие,gramm,0
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",третий символ,gramm,0
"тогда функция void dec (char t) {int i; while ((i = ipop()) != -1) decid(i,t); } считывает из стека номера строк tid и заносит в них информацию о наличии описания и о типе t. с учетом этих функций правило вывода с действиями для обработки описаний будет таким: d < ipush (-1) > i < ipush (curr lex.value) > {, i < ipush (curr lex.value) >}: [ int < dec (""int"") > bool < dec (""bool"") > ] контроль контекстных условий в выражении пусть есть функция char gettype (char op, char t1, char t2), которая проверяет допустимость сочетания операндов типа t1 (первый операнд) и типа t2 (второй операнд) в операции op; если типы совместимы, то выдает тип результата этой операции; иначе - строку ""no"".",результата,gramm,0
первый этап: разработка дс.,разработка,gramm,0
"в этом разделе изложены некоторые аспекты теории формальных языков, существенные с точки зрения трансляции.",трансляции,gramm,0
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",алфавит,gramm,0
"тело каждой такой процедуры пишется непосредственно по правилам вывода соответствующего нетерминала: для правой части каждого правила осуществляется поиск подцепочки, выводимой из этой правой части.",подцепочки,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",интерпретации выражений,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",свойствами,gramm,0
излагаемые алгоритмы и методы иллюстрируются на примере модельного паскалеподобного языка ( м-языка ).,м-языка,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",полизе,gramm,0
"но время работы такого алгоритма (синтаксического анализа с возвратами) экспоненциально зависит от длины цепочки, что с практической точки зрения совершенно неприемлемо.",возвратами,gramm,0
"соглашение: предположим, что анализируемая цепочка заканчивается специальным символом - признаком конца цепочки.",специальным символом - признаком,gramm,0
основные понятия и определения определение: алфавит - это конечное множество символов.,конечное множество символов,gramm,0
"генерация внутреннего представления программы будет проходить во время синтаксического анализа параллельно с контролем контекстных условий, поэтому для генерации можно использовать информацию, ""собранную"" синтаксическим и семантическим анализаторами; например, при генерации полиза выражений можно воспользоваться содержимым стека, с которым работает семантический анализатор.",полиза,gramm,0
"определение: недетерминированный конечный автомат (нка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt в множество подмножеств k; h k - конечное множество начальных состояний; s k - конечное множество заключительных состояний.",состояний,gramm,0
язык внутреннего представления программы основные свойства языка внутреннего представления программ: a) он позволяет фиксировать синтаксическую структуру исходной программы; b) текст на нем можно автоматически генерировать во время синтаксического анализа; c) его конструкции должны относительно просто транслироваться в объектный код либо достаточно эффективно интерпретироваться.,синтаксическую структуру,gramm,0
h - начальное состояние.,состояние,gramm,0
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",характере взаимодействия лексического,gramm,0
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",описания,gramm,0
"пусть r - обозначение операции ввода, w - обозначение операции вывода.",обозначение операции,gramm,0
"64 scanf(""%d"", ip); break;}; / ""r"" - обозначение операции ввода / if (eq (""w"")) {arg = ipop(); printf (""%d"", arg); break;}; / ""w"" - обозначение операции вывода / case 3: ip = tnum [curr lex.value].address; ipush( ip); break; / значение константы - в стек / case 4: ip = tid [curr lex.value].address; ipush( ip); break; / значение переменной - в стек / case 5: ip = tid [curr lex.value].address; ipush((int)ip); break; / адрес переменной - в стек / } / конец switch / } / конец for / }",операции ввода,gramm,0
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",ограничителей,gramm,0
"теперь, параллельно с анализом исходной цепочки лексем, будем выполнять действия по генерации внутреннего представления программы.",анализом исходной,gramm,0
"внутреннее представление лексем - это пара (номер класса, номер в классе).",лексем,gramm,0
анализ этой ситуации будет приведен ниже.,анализ,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",идентификатор,gramm,0
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",состояния,gramm,0
"в этом разделе будут рассмотрены некоторые алгоритмы и технические приемы, применяемые при построении трансляторов.",построении трансляторов,gramm,0
"более формально цепочка символов в алфавите v определяется следующим образом: (1) - цепочка в алфавите v; (2) если - цепочка в алфавите v и a - символ этого алфавита, то a - цепочка в алфавите v; (3) - цепочка в алфавите v тогда и только тогда, когда она является таковой в силу (1) и (2).",алфавита,gramm,0
"представление лексем: все лексемы м-языка разделим на несколько классов; классы перенумеруем: служебные слова - 1, ограничители - 2, константы (целые числа) - 3, идентификаторы - 4.",классов,gramm,0
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",символьному изображению,gramm,0
"если такую подцепочку считать не удается, то процедура завершает свою работу вызовом процедуры обработки ошибки, которая выдает сообщение о том, что цепочка не принадлежит языку, и останавливает разбор.",процедуры,gramm,0
"попытаемся ослабить требования на вид правил грамматики: (1) при описании синтаксиса языков программирования часто встречаются правила, описывающие последовательность однотипных конструкций, отделенных друг от друга каким-либо знаком-разделителем (например, список идентификаторов при описании переменных, список параметров при вызове процедур и функций и т.п.).",последовательность однотипных,gramm,0
"в этом разделе мы рассмотрим некоторые методы, используемые для построения анализаторов (лексического, синтаксического и семантического), язык промежуточного представления программы, способ генерации промежуточной программы, ее интерпретации.",промежуточного представления программы,gramm,0
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",правила грамматики вида w,gramm,0
некоторые общепринятые способы внутреннего представления программ: a) постфиксная запись b),внутреннего представления,gramm,0
"- издание второе (переработанное и дополненное) издательский отдел факультета вмик мгу (лицензия лр no040777 от 23.07.96), 1998.-62 с. печатается по решению редакционно-издательского совета факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова 4 isbn 5-89407-032-5 издательский отдел факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова, 1999 5 элементы теори и формальных языков и грамматик введение.",совета факультета вычислительной,gramm,0
"эти действия можно выполнить с помощью функции checkid: void checkid (void) {int i; i = curr lex.value; if (tid [i].declare) / описан? / spush (tid [i].type); / тип - в стек / else error(); / описание отсутствует / } тогда для контроля контекстных условий каждой тройки - ""операнд-операция-операнд"" будем использовать функцию checkop: void checkop (void) {char op; char t1;char t2; char res; t2 = spop(); / из стека - тип второго операнда / op = spop(); / из стека - обозначение операции / t1 = spop(); / из стека - тип первого операнда / res = gettype (op,t1,t2); / допустимо ? / if (strcmp (res, ""no"")) spush (res); / да! / else error(); / нет! / } для контроля за типом операнда одноместной операции not будем использовать функцию checknot: void checknot (void) { if (strcmp (spop (), ""bool"")) error(); else spush (""bool"");} теперь главный вопрос: когда вызывать эти функции?",контроля контекстных,gramm,0
"eq ("":"")) error(); else {curr lex = getlex (); if (eq (""int"")) {curr lex = getlex (); dec (""int"");} else if (eq (""bool"")) {curr lex = getlex(); dec (""bool"");} else error(); } } } генерация внутреннего представления программ результатом работы синтаксического анализатора должно быть некоторое внутреннее представление исходной цепочки лексем, которое отражает ее синтаксическую структуру.",программ,gramm,0
"значение каждого элемента таблицы - это нетерминальный символ, к которому можно свернуть пару ""нетерминал-терминал"", которыми помечены соответствующие строка и столбец.",строка,gramm,0
"выход: m = (k , vt, f , h , s ) - детерминированный конечный автомат, допускающий тот же язык, что и автомат м.",автомат,gramm,0
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",исходного представления,gramm,0
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",переводу цепочек вида,gramm,0
"c) если в грамматике есть нетерминал, у которого несколько правил вывода, и среди них есть правила, начинающиеся нетерминальными символами, т.е. имеют вид a b1 1 ...",символами,gramm,0
"поэтому, когда говорят о языке типа k, обычно имеют в виду максимально возможный номер k. например, грамматика типа 0 g1 = ({0,1}, {a,s}, p1, s) и кс-грамматика g2 = ({0,1}, {s}, p2, s), где p1: s 0a1 p2: s 0s1 01 0a 00a1 a описывают один и тот же язык l = l(g1) = l(g2) = { 0n1n n>0}.",возможный номер,gramm,0
"генератор внутреннего представления программы на м-языке каждый элемент в полизе - это лексема, т.е. пара вида (номер класса, номер в классе).",генератор внутреннего представления программы,gramm,0
"выбор определения не влияет на множество языков, порождаемых грамматиками этого класса, поскольку доказано, что множество языков, порождаемых праволинейными грамматиками, совпадает с множеством языков, порождаемых леволинейными грамматиками.",языков,gramm,0
"его можно выполнять сразу после синтаксического анализа, некоторые требования можно контролировать во время генерации кода (например, ограничения на типы операндов в выражении), а можно совместить с синтаксическим анализом.",генерации кода,gramm,0
в приведенном выше примере разные деревья вывода предполагают соответствие else разным then.,выше примере,gramm,0
"в конкретных компиляторах порядок этих процессов может быть несколько иным, некоторые из них могут объединяться в одну фазу, другие могут выполнятся в течение всего процесса компиляции.",процесса компиляции,gramm,0
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",решения,gramm,0
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",свободного элемента,gramm,0
"грамматики этого класса, с одной стороны, позволяют достаточно полно описать синтаксическую структуру реальных языков программирования; с другой стороны, для разных подклассов укс-грамматик существуют достаточно эффективные алгоритмы разбора.",укс-грамматик,gramm,0
"здесь введены базовые понятия и даны определения, связанные с одним из основных механизмов определения языков - грамматиками, приведена наиболее распространенная классификация грамматик (по хомскому).",определения языков -,gramm,0
"таким образом, лексический анализатор - это транслятор, входом которого служит цепочка символов, представляющих исходную программу, а выходом - последовательность лексем.",выходом - последовательность,gramm,0
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",алгоритм разбора,gramm,0
для описания синтаксиса языков программирования стараются использовать однозначные приведенные кс- грамматики.,языков,gramm,0
"например, обычной (инфиксной) записи выражения a (b+c)-(d-e)/f соответствует такая постфиксная запись: abc+ de-f/- замечание: обратите внимание на то, что в полизе порядок операндов остался таким же, как и в инфиксной записи, учтено старшинство операций, а скобки исчезли.",записи выражения a,gramm,0
"обработка описаний для контроля согласованности типов в выражениях и типов выражений в операторах, необходимо знать типы переменных, входящих в эти выражения.",выражения,gramm,0
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",действия,gramm,0
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",обозначение,gramm,0
"для студентов факультета вмк в поддержку основного лекционного курса системное программное обеспечение и для преподавателей, ведущих практические занятия по этому курсу.",поддержку основного лекционного курса,gramm,0
"31 c - очередной входной символ; d - переменная для формирования числового значения константы; tw - таблица служебных слов м-языка; td - таблица ограничителей м-языка; tid - таблица идентификаторов анализируемой программы; tnum - таблица чисел-констант, используемых в программе.",служебных слов м,gramm,0
"считаем, что к моменту интерпретации распределена память под константы и переменные, адреса занесены в поле address таблиц tid и tnum, значения констант размещены в памяти.",значения констант,gramm,0
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",правилом,gramm,0
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",спуска метод рекурсивного,gramm,0
"более формально постфиксную запись выражений можно определить таким образом: (1)если е является единственным операндом, то полиз выражения е - это этот операнд; (2)полизом выражения е1 е2, где - знак бинарной операции, е1 и е2 операнды для , является запись e1 e2 , где e1 и e2 - полиз выражений е1 и е2 соответственно; (3)полизом выражения e, где - знак унарной операции, а е - операнд , является запись e , где e - полиз выражения е; (4)полизом выражения (е) является полиз выражения е.",образом,gramm,0
"таблицы tw и td заполнены заранее, т.к. их содержимое не зависит от исходной программы; tid и tnum будут формироваться в процессе анализа; для простоты будем считать, что все таблицы одного типа; пусть tabl - имя типа этих таблиц, ptabl - указатель на tabl.",исходной программы,gramm,0
элементы теории трансляции.,элементы теории трансляции,gramm,0
"определение: символ x (vt vn) называется недостижимым в грамматике g = (vt, vn, p, s), если он не появляется ни в одной сентенциальной форме этой грамматики.",определение,gramm,0
"однако структура таких конструкций как выражение, описание, оператор и т.п., более сложная, чем структура идентификаторов и чисел.",конструкций,gramm,0
"грамматики этого класса, с одной стороны, позволяют достаточно полно описать синтаксическую структуру реальных языков программирования; с другой стороны, для разных подклассов укс-грамматик существуют достаточно эффективные алгоритмы разбора.",программирования,gramm,0
"тогда для метода рекурсивного спуска процедура l будет такой: void l() { if (c != 'a') error(); while ((c = fgetc(fp)) == ',') if ((c = fgetc(fp)) !",метода рекурсивного,gramm,0
"эти действия можно выполнить с помощью функции checkid: void checkid (void) {int i; i = curr lex.value; if (tid [i].declare) / описан? / spush (tid [i].type); / тип - в стек / else error(); / описание отсутствует / } тогда для контроля контекстных условий каждой тройки - ""операнд-операция-операнд"" будем использовать функцию checkop: void checkop (void) {char op; char t1;char t2; char res; t2 = spop(); / из стека - тип второго операнда / op = spop(); / из стека - обозначение операции / t1 = spop(); / из стека - тип первого операнда / res = gettype (op,t1,t2); / допустимо ? / if (strcmp (res, ""no"")) spush (res); / да! / else error(); / нет! / } для контроля за типом операнда одноместной операции not будем использовать функцию checknot: void checknot (void) { if (strcmp (spop (), ""bool"")) error(); else spush (""bool"");} теперь главный вопрос: когда вызывать эти функции?",функцию,gramm,0
"синтаксически управляемый перевод на практике синтаксический, семантический анализ и генерация внутреннего представления программы часто осуществляются одновременно.",практике,gramm,0
"московский государственный университет им. м.в.ломоносова факультет вычислительной математики и кибернетики волкова и.а., руденко т.в.",факультет вычислительной,gramm,0
для этого в алгоритме интерпретации вместо выполнения операции нужно генерировать соответствующие команды объектной программы.,команды объектной,gramm,0
"чтобы можно было ссылаться на элементы полиза, будем считать, что все они перенумерованы, начиная с 1 (допустим, занесены в последовательные элементы одномерного массива).",элементы полиза,gramm,0
"мы выберем последний вариант: как только синтаксический анализатор распознает конструкцию, на компоненты которой наложены некоторые ограничения, проверяется их выполнение.",выполнение,gramm,0
"генерация внутреннего представления программы будет проходить во время синтаксического анализа параллельно с контролем контекстных условий, поэтому для генерации можно использовать информацию, ""собранную"" синтаксическим и семантическим анализаторами; например, при генерации полиза выражений можно воспользоваться содержимым стека, с которым работает семантический анализатор.",условий,gramm,0
"многоадресный код с неявно именуемыми результатами e) связные списочные структуры, представляющие синтаксическое дерево.",дерево,gramm,0
3 - целые константы 4 - лексемы-идентификаторы ( во время интерпретации будет использовать-ся значение) 5 - лексемы-идентификаторы ( во время интерпретации будет использовать-ся адрес).,лексемы-идентификаторы,gramm,0
"чтобы отличать вызовы семантических процедур от других символов грамматики, будем заключать их в угловые скобки.",других символов,gramm,0
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",структуры языков,gramm,0
"например, для грамматики g = ({a,b, }, {s,a,b}, p, s), где p: s a a a bb b b bb разбор будет недетерминированным (т.к. у нетерминалов a и b есть одинаковые правые части - bb).",нетерминалов a,gramm,0
"действительно, в цепочке a,a,a,a,a из нетерминала l может выводиться и подцепочка a , и подцепочка a,a , и вся цепочка a,a,a,a,a. неясно, какую из них выбрать в качестве подцепочки, выводимой из l. если принять решение, что в таких случаях будем выбирать самую длинную подцепочку (что и требуется при разборе реальных языков), то разбор становится детерминированным.",разборе реальных,gramm,0
"void interpreter(void) { int ip; int i, j, arg; for (i = 0; i<=n; i++) {curr lex = p[i]; switch (curr lex.class) { case 0: ipush (curr lex.value); break; / метку полиза - в стек / case 1: if (eq (""true"")) ipush (1); else ipush (0); break; / логическое значение - в стек / case 2: if (eq (""+"")) {ipush (ipop() + ipop()); break}; / выполнили операцию сложения, результат - в стек / if (eq (""-"")) {arg = ipop(); ipush (ipop() - arg); break;} / аналогично для других двухместных арифметических и логических операций / if (eq (""not"")) {ipush (!",в стек,gramm,0
"запись выражения в такой форме очень удобна для последующей интерпретации (т.е. вычисления значения этого выражения) с помощью стека: выражение просматривается один раз слева направо, при этом (1)если очередной элемент полиза - это операнд, то его значение заносится в стек; (2)если очередной элемент полиза - это операция, то на ""верхушке"" стека сейчас находятся ее операнды (это следует из определения полиза и предшествующих действий алгоритма); они извлекаются из стека, над ними выполняется операция, результат снова заносится в стек; (3)когда выражение, записанное в полизе, прочитано, в стеке останется один элемент - это значение всего выражения.",результат,gramm,0
"эти действия можно выполнить с помощью функции checkid: void checkid (void) {int i; i = curr lex.value; if (tid [i].declare) / описан? / spush (tid [i].type); / тип - в стек / else error(); / описание отсутствует / } тогда для контроля контекстных условий каждой тройки - ""операнд-операция-операнд"" будем использовать функцию checkop: void checkop (void) {char op; char t1;char t2; char res; t2 = spop(); / из стека - тип второго операнда / op = spop(); / из стека - обозначение операции / t1 = spop(); / из стека - тип первого операнда / res = gettype (op,t1,t2); / допустимо ? / if (strcmp (res, ""no"")) spush (res); / да! / else error(); / нет! / } для контроля за типом операнда одноместной операции not будем использовать функцию checknot: void checknot (void) { if (strcmp (spop (), ""bool"")) error(); else spush (""bool"");} теперь главный вопрос: когда вызывать эти функции?",обозначение,gramm,0
"возможность выбора обусловлена тем, что для каждой укс- грамматики существует почти эквивалентная кс-грамматика.",выбора,gramm,0
"состояние, в которое мы при этом попадаем, становится текущим.",состояние,gramm,0
"f, r, w) относятся к классу ограничителей, как и все другие операции модельного языка; 2) для ссылок на номера элементов полиза введем лексемы класса 0, т.е. (0,p) - лексема, обозначающая p-ый элемент в полизе; 3) для того, чтобы различать операнды-значения-переменных и операнды-адреса-переменных (например, в полизе оператора присваивания), операнды-значения будем обозначать лексемами класса 4, а для операндов-адресов введем лексемы класса 5.",элемент,gramm,0
"типы операндов и обозначение операции будем хранить в стеке; для этого нам нужны функции для работы со стеком строк: 49 void spush (char s); / значение s - в стек / char spop (void); / из стека - строку / если в выражении встречается лексема-целое число или логические константы true или false, то соответствующий тип сразу заносим в стек с помощью spush(""int"") или spush(""bool"").",функции,gramm,0
"определение: декартовым произведением a b множеств a и b называется множество { (a,b) a a, b b}.",определение,gramm,0
"тогда функция void dec (char t) {int i; while ((i = ipop()) != -1) decid(i,t); } считывает из стека номера строк tid и заносит в них информацию о наличии описания и о типе t. с учетом этих функций правило вывода с действиями для обработки описаний будет таким: d < ipush (-1) > i < ipush (curr lex.value) > {, i < ipush (curr lex.value) >}: [ int < dec (""int"") > bool < dec (""bool"") > ] контроль контекстных условий в выражении пусть есть функция char gettype (char op, char t1, char t2), которая проверяет допустимость сочетания операндов типа t1 (первый операнд) и типа t2 (второй операнд) в операции op; если типы совместимы, то выдает тип результата этой операции; иначе - строку ""no"".",операции,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",присваивания,gramm,0
тип выражения и совместимость типов операндов в выражении определяются по обычным правилам (как в паскале).,паскале,gramm,0
"результат: номер строки таблицы с информацией о лексеме; int putnum (); - запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum с информацией о константе-лексеме; void makelex (int k, int i); - формирование и вывод внутреннего представления лексемы; k - номер класса, i - номер в классе; void gc (void) - функция, читающая из входного потока очередной символ исходной программы и заносящая его в переменную с; void id or word (void); - функция, определяющая является слово в буфере buf идентификатором или служебным словом и формирующая лексему соответствующего класса; void is dlm (void); - если символ в буфере buf является разделителем, то формирует соответствующую лексему, иначе производится переход в состояние er.",разделителем,gramm,0
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",формирования числового,gramm,0
"1) язык типа 0: l(g) = {a2 bn2-1 n >= 1} g: s aacfd f afb ab ab bba ab ba ad d cb bc 11 cb c bcd 2) язык типа 1: l(g) = { an bn cn, n >= 1} g: s asbc abc cb bc bb bb bc bc cc cc 3) язык типа 2: l(g) = {(ac)n (cb)n n > 0} g: s aqb accb q csc 4) язык типа 3: l(g) = { {a,b}+, где нет двух рядом стоящих а} g: s a b a a ba b b bb ab разбор цепочек цепочка принадлежит языку, порождаемому грамматикой, только в том случае, если существует ее вывод из цели этой грамматики.",порождаемому грамматикой,gramm,0
"при работе этого алгоритма возможны следующие ситуации: (1) прочитана вся цепочка; на каждом шаге находилась единственная нужная ""свертка""; на последнем шаге свертка произошла к символу s. это означает, что исходная цепочка a1a2...an l(g).",алгоритма возможны,gramm,0
"однако правило вывода для нетерминального символа a будет иметь альтернативы, начинающиеся одинаковыми терминальными символами, следовательно, потребуются дальнейшие преобразования, и успех не гарантирован.",символа,gramm,0
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",правилам,gramm,0
"тогда, если first(a) follow(a) , то метод рекурсивного спуска неприменим к данной грамматике.",данной грамматике,gramm,0
"здесь не приводятся доказательства сформулированных фактов, свойств, теорем, доказательства правильности алгоритмов; их можно найти в книгах, указанных в списке литературы.",свойств,gramm,0
"например, для грамматики g = ({a,b, }, {s,a,b}, p, s), где p: s a a a bb b b bb разбор будет недетерминированным (т.к. у нетерминалов a и b есть одинаковые правые части - bb).",правые части -,gramm,0
"определенная нами неоднозначность - это свойство грамматики, а не языка, т.е. для некоторых неоднозначных грамматик существуют эквивалентные им однозначные грамматики.",свойство,gramm,0
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",методы,gramm,0
"синтаксически управляемый перевод на практике синтаксический, семантический анализ и генерация внутреннего представления программы часто осуществляются одновременно.",представления,gramm,0
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",обработки,gramm,0
"64 scanf(""%d"", ip); break;}; / ""r"" - обозначение операции ввода / if (eq (""w"")) {arg = ipop(); printf (""%d"", arg); break;}; / ""w"" - обозначение операции вывода / case 3: ip = tnum [curr lex.value].address; ipush( ip); break; / значение константы - в стек / case 4: ip = tid [curr lex.value].address; ipush( ip); break; / значение переменной - в стек / case 5: ip = tid [curr lex.value].address; ipush((int)ip); break; / адрес переменной - в стек / } / конец switch / } / конец for / }",обозначение операции,gramm,0
излагаемые алгоритмы и методы иллюстрируются на примере модельного паскалеподобного языка ( м-языка ).,примере модельного,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",метод рекурсивного,gramm,0
в основе каждого из этих способов лежит некоторый метод представления синтаксического дерева.,способов,gramm,0
"попытаемся ослабить требования на вид правил грамматики: (1) при описании синтаксиса языков программирования часто встречаются правила, описывающие последовательность однотипных конструкций, отделенных друг от друга каким-либо знаком-разделителем (например, список идентификаторов при описании переменных, список параметров при вызове процедур и функций и т.п.).",описании переменных,gramm,0
"определение: язык l(g) является языком типа k, если его можно описать грамматикой типа k. соотношения между типами языков: (1) каждый регулярный язык является кс-языком, но существуют кс-языки, которые не являются регулярными ( например, l = {anbn n>0}).",определение,gramm,0
"(2) если грамматика не удовлетворяет требованиям применимости метода рекурсивного спуска, то можно попытаться преобразовать ее, т.е. получить эквивалентную грамматику, пригодную для анализа этим методом.",применимости,gramm,0
"чтобы можно было ссылаться на элементы полиза, будем считать, что все они перенумерованы, начиная с 1 (допустим, занесены в последовательные элементы одномерного массива).",последовательные элементы,gramm,0
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",виде строки,gramm,0
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",очистка,gramm,0
"bn n1 ... np, где bi vn; aj vt; i, j, ij (vt vn) , то можно заменить вхождения нетерминалов bi их правилами вывода в надежде, что правило нетерминала a станет удовлетворять требованиям метода рекурсивного спуска: a 11 1 ...",спуска,gramm,0
"при этом терминалы распознаются самой процедурой, а нетерминалы соответствуют вызовам процедур, носящих их имена.",вызовам процедур,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",построению дерева разбора методом,gramm,0
для записи правил вывода с одинаковыми левыми частями 1 2 ... n будем пользоваться сокращенной записью 1 2 ... n.,записью,gramm,0
"алгоритм удаления бесплодных символов: вход: кс-грамматика g = (vt, vn, p, s).",удаления,gramm,0
"в любом месте программы, кроме идентификаторов, служебных слов и чисел, может находиться произвольное число пробелов и комментариев вида {< любые символы, кроме } и >}.",служебных слов,gramm,0
"теперь каждая дуга в дс может выглядеть так: a t1,t2,...,tn b d1;d2;...;dm смысл ti прежний - если в состоянии a очередной анализируемый символ совпадает с ti для какого-либо i = 1, 2 ,... n, то осуществляется переход в состояние b; при этом необходимо выполнить действия d1, d2, ... ,dm.",состояние,gramm,0
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",программе идентификаторов,gramm,0
"замечание: чаще всего синтаксическим деревом называют дерево вывода исходной цепочки, в котором удалены вершины, соответствующие цепным правилам вида a b, где a, b vn.",замечание,gramm,0
"однако структура таких конструкций как выражение, описание, оператор и т.п., более сложная, чем структура идентификаторов и чисел.",выражение,gramm,0
"синтаксически управляемый перевод на практике синтаксический, семантический анализ и генерация внутреннего представления программы часто осуществляются одновременно.",анализ,gramm,0
"при нисходящем разборе дерево вывода формируется от корня к листьям; на каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти такое правило вывода, чтобы имеющиеся в нем терминальные символы проектировались на символы исходной цепочки.",разборе дерево вывода,gramm,0
с практической точки зрения наибольший интерес представляет разбор по контекстно-свободным (кс и укс) грамматикам.,зрения наибольший,gramm,0
"в этом разделе будут рассмотрены некоторые алгоритмы и технические приемы, применяемые при построении трансляторов.",разделе,gramm,0
"пусть есть функции: void clear (void); - очистка буфера buf; void add (void); - добавление символа с в конец буфера buf; int look (ptabl т); - поиск в таблице т лексемы из буфера buf; результат: номер строки таблицы с информацией о лексеме либо 0, если такой лексемы в таблице т нет; int putl (ptabl т);",информацией,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",исходной цепочки,gramm,0
"замечание: укс-язык, содержащий пустую цепочку, не является кз-языком.",языком,gramm,0
для этого дополним грамматику вызовами соответствующих процедур генерации.,генерации,gramm,0
"об используемых функциях: int id (void); - результат равен 1, если curr lex.class = 4, т.е. curr lex представляет идентификатор, и 0 - в противном случае; int num (void); - результат равен 1, если curr lex.class = 3, т.е. curr lex представляет число-константу, и 0 - в противном случае; int eq (char s); - результат равен 1, если curr lex представляет строку s, и 0 - иначе ; void error (void) - функция обработки ошибки; при обнаружении ошибки работа анализатора прекращается.",обнаружении ошибки работа,gramm,0
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",функция,gramm,0
"пусть полиз оператора, помеченного меткой l, начинается с номера p, тогда оператор перехода goto l в полизе можно записать как p !",полизе,gramm,0
"здесь не приводятся доказательства сформулированных фактов, свойств, теорем, доказательства правильности алгоритмов; их можно найти в книгах, указанных в списке литературы.",правильности алгоритмов,gramm,0
в операторе присваивания типы переменной и выражения должны совпадать.,операторе присваивания типы переменной,gramm,0
"во втором издании исправлены неточности и ошибки первого издания, расширен набор задач: номера первого издания сохранены, но появились дополнительные пункты, отмеченные малыми латинскими буквами.",дополнительные пункты,gramm,0
"интерпретатор полиза для модельного языка польская инверсная запись была выбрана нами в качестве языка внутреннего представления программы, в частности, потому, что записанная таким образом программа может быть легко проинтерпретирована.",интерпретатор,gramm,0
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",помощью,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",результата,gramm,0
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",анализатором,gramm,0
"введем вспомогательную операцию - условный переход ""по лжи"" с семантикой if (not b) then goto l это двухместная операция c операндами b и l. обозначим ее !",операцию,gramm,0
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",правила,gramm,0
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",единственная дуга,gramm,0
"многоадресный код с неявно именуемыми результатами e) связные списочные структуры, представляющие синтаксическое дерево.",структуры,gramm,0
"лексический анализ рассмотрим методы и средства, которые обычно используются при построении лексических анализаторов.",средства,gramm,0
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется левым (левосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого левого нетерминала.",предыдущей заменой самого левого,gramm,0
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",оператора присваивания элементы,gramm,0
"пример: совокупность процедур рекурсивного спуска для грамматики g = ({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba будет такой: #include <stdio.h> int c; file fp;/ указатель на файл, в котором находится анализируе-мая цепочка / void a(); void b(); void error(); / функция обработки ошибок / void s() {a(); b(); 40 if (c != ' ') error(); } void a() {if (c=='a') c = fgetc(fp); else if (c == 'c') {c = fgetc(fp); a();} else error(); } void b() {if (c == 'b') {c = fgetc(fp); a();} else error(); } void error() {printf(""error !!!",функция,gramm,0
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется правым (правосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого правого нетерминала.",кс- грамматике g,gramm,0
язык внутреннего представления программы основные свойства языка внутреннего представления программ: a) он позволяет фиксировать синтаксическую структуру исходной программы; b) текст на нем можно автоматически генерировать во время синтаксического анализа; c) его конструкции должны относительно просто транслироваться в объектный код либо достаточно эффективно интерпретироваться.,представления программы основные,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",уровней,gramm,0
"поэтому, когда говорят о языке типа k, обычно имеют в виду максимально возможный номер k. например, грамматика типа 0 g1 = ({0,1}, {a,s}, p1, s) и кс-грамматика g2 = ({0,1}, {s}, p2, s), где p1: s 0a1 p2: s 0s1 01 0a 00a1 a описывают один и тот же язык l = l(g1) = l(g2) = { 0n1n n>0}.",грамматика типа,gramm,0
"если операнд - лексема-переменная, то необходимо проверить, описана ли она; если описана, то ее тип надо занести в стек.",лексема-,gramm,0
"если допустить в правилах вывода грамматики пустую альтернативу, т.е. правила вида a a1 1 ... an n , то метод рекурсивного спуска может оказаться неприменимым (несмотря на то, что в остальном достаточные условия применимости выполняются).",правила вида,gramm,0
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",алгоритмы,gramm,0
лексический анализатор для м-языка вход лексического анализатора - символы исходной программы на м-языке; результат работы - исходная программа в виде последовательности лексем (их внутреннего представления).,результат работы,gramm,0
"64 scanf(""%d"", ip); break;}; / ""r"" - обозначение операции ввода / if (eq (""w"")) {arg = ipop(); printf (""%d"", arg); break;}; / ""w"" - обозначение операции вывода / case 3: ip = tnum [curr lex.value].address; ipush( ip); break; / значение константы - в стек / case 4: ip = tid [curr lex.value].address; ipush( ip); break; / значение переменной - в стек / case 5: ip = tid [curr lex.value].address; ipush((int)ip); break; / адрес переменной - в стек / } / конец switch / } / конец for / }",операции,gramm,0
"среди всех состояний выделяется начальное (считается, что в начальный момент своей работы автомат находится в этом состоянии) и конечное (если автомат завершает работу переходом в это состояние, то анализируемая цепочка им допускается).",автомат,gramm,0
"тогда функция void dec (char t) {int i; while ((i = ipop()) != -1) decid(i,t); } считывает из стека номера строк tid и заносит в них информацию о наличии описания и о типе t. с учетом этих функций правило вывода с действиями для обработки описаний будет таким: d < ipush (-1) > i < ipush (curr lex.value) > {, i < ipush (curr lex.value) >}: [ int < dec (""int"") > bool < dec (""bool"") > ] контроль контекстных условий в выражении пусть есть функция char gettype (char op, char t1, char t2), которая проверяет допустимость сочетания операндов типа t1 (первый операнд) и типа t2 (второй операнд) в операции op; если типы совместимы, то выдает тип результата этой операции; иначе - строку ""no"".",действиями,gramm,0
"замечание: фактически, мы расширили понятие контекстно- свободной грамматики, добавив в ее правила вывода символы- действия.",правила вывода символы- действия,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",вывода,gramm,0
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",текущее состояние,gramm,0
"каждая лексема - это структура struct lex {int class; int value;}, возможные значения поля class: 0 - лексемы-метки (номера элементов в полизе) 1 - логические константы true либо false ( других лексем - служебных слов в полизе нет) 2 - операции (других лексем-ограничителей в полизе нет)",значения,gramm,0
"но время работы такого алгоритма (синтаксического анализа с возвратами) экспоненциально зависит от длины цепочки, что с практической точки зрения совершенно неприемлемо.",зрения,gramm,0
"существуют табличные методы анализа ([3]), применимые ко всему классу кс-грамматик и требующие для разбора цепочек длины n времени cn3 (алгоритм кока-янгера-касами) либо cn2 (алгоритм эрли).",времени,gramm,0
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",подмножество множества,gramm,0
"эти действия можно выполнить с помощью функции checkid: void checkid (void) {int i; i = curr lex.value; if (tid [i].declare) / описан? / spush (tid [i].type); / тип - в стек / else error(); / описание отсутствует / } тогда для контроля контекстных условий каждой тройки - ""операнд-операция-операнд"" будем использовать функцию checkop: void checkop (void) {char op; char t1;char t2; char res; t2 = spop(); / из стека - тип второго операнда / op = spop(); / из стека - обозначение операции / t1 = spop(); / из стека - тип первого операнда / res = gettype (op,t1,t2); / допустимо ? / if (strcmp (res, ""no"")) spush (res); / да! / else error(); / нет! / } для контроля за типом операнда одноместной операции not будем использовать функцию checknot: void checknot (void) { if (strcmp (spop (), ""bool"")) error(); else spush (""bool"");} теперь главный вопрос: когда вызывать эти функции?",помощью,gramm,0
"естественно, возникает вопрос: если грамматика не удовлетворяет этим условиям, то существует ли эквивалентная кс-грамматика, для которой метод рекурсивного спуска применим?",эквивалентная кс-грамматика,gramm,0
"типы операндов и обозначение операции будем хранить в стеке; для этого нам нужны функции для работы со стеком строк: 49 void spush (char s); / значение s - в стек / char spop (void); / из стека - строку / если в выражении встречается лексема-целое число или логические константы true или false, то соответствующий тип сразу заносим в стек с помощью spush(""int"") или spush(""bool"").",соответствующий тип,gramm,0
"определение: обозначим через v+ множество, содержащее все цепочки конечной длины в алфавите v, исключая пустую цепочку .",определение,gramm,0
"внутреннее представление лексем - это пара (номер класса, номер в классе).",номер класса,gramm,0
"например, обычной (инфиксной) записи выражения a (b+c)-(d-e)/f соответствует такая постфиксная запись: abc+ de-f/- замечание: обратите внимание на то, что в полизе порядок операндов остался таким же, как и в инфиксной записи, учтено старшинство операций, а скобки исчезли.",записи,gramm,0
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",символов,gramm,0
"важно отметить, что это изменение касается только внутреннего представления программы и не требует изменения входного языка.",изменения входного,gramm,0
"удаление символов сопровождается удалением правил вывода, содержащих эти символы.",символов,gramm,0
"метод восходящего разбора заключается в том, что исходную цепочку пытаются свернуть к начальному символу s; на каждом шаге ищут подцепочку, которая совпадает с правой частью какого-либо правила вывода; если такая подцепочка находится, то она заменяется нетерминалом из левой части этого правила.",подцепочка,gramm,0
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",языков,gramm,0
"- операция выбора элемента полиза, номер которого равен p. немного сложнее окажется запись в полизе условных операторов и операторов цикла.",выбора элемента,gramm,0
"алгоритм удаления недостижимых символов: вход: кс-грамматика g = (vt, vn, p, s) выход: кс-грамматика g = (vt , vn , p , s), не содержащая недостижимых символов, для которой l(g) = l(g ).",грамматика g,gramm,0
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",строки таблицы,gramm,0
основные понятия и определения определение: алфавит - это конечное множество символов.,множество,gramm,0
номер в классе - это номер строки в таблице лексем соответствующего класса.,классе,gramm,0
"метод восходящего разбора заключается в том, что исходную цепочку пытаются свернуть к начальному символу s; на каждом шаге ищут подцепочку, которая совпадает с правой частью какого-либо правила вывода; если такая подцепочка находится, то она заменяется нетерминалом из левой части этого правила.",правила вывода,gramm,0
"- операция выбора элемента полиза, номер которого равен p. немного сложнее окажется запись в полизе условных операторов и операторов цикла.",операция,gramm,0
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",анализ генерация,gramm,0
анализ этой ситуации будет дан ниже.,анализ,gramm,0
для описания синтаксиса языков программирования стараются использовать однозначные приведенные кс- грамматики.,описания,gramm,0
"попытаемся ослабить требования на вид правил грамматики: (1) при описании синтаксиса языков программирования часто встречаются правила, описывающие последовательность однотипных конструкций, отделенных друг от друга каким-либо знаком-разделителем (например, список идентификаторов при описании переменных, список параметров при вызове процедур и функций и т.п.).",вызове,gramm,0
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",внутреннего представления,gramm,0
"пусть s = {s1, s2, ..., sp}, тогда s - все состояния из k , имеющие вид [...si...], .si s для какого-либо 1 <= i <= p. замечание: в множестве k могут оказаться состояния, которые недостижимы из начального состояния, их можно исключить.",замечание,gramm,0
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",спуска применим,gramm,0
в условном операторе и в операторе цикла в качестве условия возможно только логическое выражение.,операторе цикла,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",формальных параметров,gramm,0
"соглашение: предположим, что анализируемая цепочка заканчивается специальным символом - признаком конца цепочки.",специальным символом,gramm,0
"bn n1 ... np, где bi vn; aj vt; i, j, ij (vt vn) , то можно заменить вхождения нетерминалов bi их правилами вывода в надежде, что правило нетерминала a станет удовлетворять требованиям метода рекурсивного спуска: a 11 1 ...",вхождения,gramm,0
"синтаксический анализатор для м-языка будем считать, что синтаксический и лексический анализаторы взаимодействуют следующим образом: анализ исходной программы идет под управлением синтаксического анализатора; если для продолжения анализа ему нужна очередная лексема, то он запрашивает ее у лексического анализатора; тот выдает одну лексему и ""замирает"" до тех пор, пока синтаксический анализатор не запросит следующую лексему.",анализа,gramm,0
"если договориться, что else должно соответствовать ближайшему к нему then, и подправить грамматику g, то неоднозначность будет устранена: s if b then s if b then s else s a s if b then s else s a проблема, порождает ли данная кс-грамматика однозначный язык (т.е. существует ли эквивалентная ей однозначная грамматика), является алгоритмически неразрешимой.",грамматику g,gramm,0
"eq ("":"")) error(); else {curr lex = getlex (); if (eq (""int"")) {curr lex = getlex (); dec (""int"");} else if (eq (""bool"")) {curr lex = getlex(); dec (""bool"");} else error(); } } } генерация внутреннего представления программ результатом работы синтаксического анализатора должно быть некоторое внутреннее представление исходной цепочки лексем, которое отражает ее синтаксическую структуру.",программ результатом работы,gramm,0
(учебное пособие для студентов ii курса),ii курса,gramm,0
"важно отметить, что это изменение касается только внутреннего представления программы и не требует изменения входного языка.",изменение,gramm,0
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",анализируемой цепочки,gramm,0
"тогда грамматика, содержащая действия по контролю контекстных условий и переводу условного оператора модельного языка в полиз, будет такой: s if e < eqbool(); pl2 = free++; put lex (make op (""!f"")) > then s < pl3 = free++; put lex (make op (""!"")); p[pl2] = make labl (free) > else s < p[pl3] = make lable (free) > замечание: переменные pl2 и pl3 должны быть локализованы в процедуре s, иначе возникнет ошибка при обработке вложенных условных операторов.",ошибка,gramm,0
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",элементы массива,gramm,0
"43 проблема заключается в том, что подцепочка, следующая за цепочкой, выводимой из a, начинается таким же символом, как и цепочка, выводимая из а.",подцепочка,gramm,0
"язык l называют кс-языком, т.к. существует кс-грамматика, его описывающая.",кс-грамматика,gramm,0
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",основные определения,gramm,0
"(3) на некотором шаге не нашлось нужной свертки, т.е. для полученного на предыдущем шаге нетерминала a и расположенного непосредственно справа от него очередного терминала ai исходной цепочки не нашлось нетерминала b, для которого в грамматике было бы правило вывода b aai.",предыдущем шаге,gramm,0
"их порождающей мощности достаточно для описания большей части синтаксической структуры языков программирования, для различных подклассов кс-грамматик имеются хорошо разработанные практически приемлемые способы решения задачи разбора.",задачи,gramm,0
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",текущую лексему,gramm,0
"если для синтаксического анализа используется метод рекурсивного спуска, то в тела процедур рс-метода необходимо вставить вызовы дополнительных ""семантических"" процедур (семантические действия).",анализа,gramm,0
диаграмма состояний для лексического анализатора приведена на следующей странице.,странице,gramm,0
"для грамматик этого класса, как мы уже видели, существует простой и эффективный алгоритм анализа того, принадлежит ли заданная цепочка языку, порождаемому этой грамматикой.",цепочка языку,gramm,0
"интуитивно это объясняется тем, что цепочки с i = j должны порождаться группой правил вывода, отличных от правил, порождающих цепочки с j = k. но тогда, по крайней мере, некоторые из цепочек с i = j = k будут порождаться обеими группами правил и, следовательно, будут иметь по два разных 14 дерева вывода.",группой правил вывода,gramm,0
тип выражения и совместимость типов операндов в выражении определяются по обычным правилам; старшинство операций задано синтаксисом.,тип выражения,gramm,0
"для более удобной работы с диаграммами состояний введем несколько соглашений: a) если из одного состояния в другое выходит несколько дуг, помеченных разными символами, то будем изображать одну дугу, помеченную всеми этими символами; b) непомеченная дуга будет соответствовать переходу при любом символе, кроме тех, которыми помечены другие дуги, выходящие из этого состояния.",соглашений,gramm,0
"тогда грамматика, содержащая действия по контролю контекстных условий и переводу условного оператора модельного языка в полиз, будет такой: s if e < eqbool(); pl2 = free++; put lex (make op (""!f"")) > then s < pl3 = free++; put lex (make op (""!"")); p[pl2] = make labl (free) > else s < p[pl3] = make lable (free) > замечание: переменные pl2 и pl3 должны быть локализованы в процедуре s, иначе возникнет ошибка при обработке вложенных условных операторов.",условного оператора,gramm,0
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",анализаторы,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",последовательность,gramm,0
"пусть есть функции: void clear (void); - очистка буфера buf; void add (void); - добавление символа с в конец буфера buf; int look (ptabl т); - поиск в таблице т лексемы из буфера buf; результат: номер строки таблицы с информацией о лексеме либо 0, если такой лексемы в таблице т нет; int putl (ptabl т);",таблицы,gramm,0
e e1 e1 [ = < > ] e1 e1 t {[ + - or ] t} t f {[ / and ] f} f i n [ true false ] not f (e) 50 именно это свойство грамматики позволит провести синтаксически-управляемый контроль контекстных условий.,управляемый контроль,gramm,0
"(4) на некотором шаге работы алгоритма оказалось, что есть несколько дуг, выходящих из текущего состояния, помеченных очередным анализируемым символом, но ведущих в разные состояния.",разные состояния,gramm,0
"один из наиболее важных результатов теории конечных автоматов состоит в том, что класс языков, определяемых недетерминированными конечными автоматами, совпадает с классом языков, определяемых детерминированными конечными автоматами.",результатов теории конечных автоматов,gramm,0
"выбор конструкций, которые будут выделяться как отдельные лексемы, зависит от языка и от точки зрения разработчиков компилятора.",точки зрения разработчиков,gramm,0
соответствующие изменения надо сделать и в синтаксическом анализаторе.,изменения,gramm,0
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется правым (правосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого правого нетерминала.",предыдущей заменой,gramm,0
"- издание второе (переработанное и дополненное) издательский отдел факультета вмик мгу (лицензия лр no040777 от 23.07.96), 1998.-62 с. печатается по решению редакционно-издательского совета факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова 4 isbn 5-89407-032-5 издательский отдел факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова, 1999 5 элементы теори и формальных языков и грамматик введение.",языков,gramm,0
первый этап: разработка дс.,первый этап,gramm,0
эти вершины будем называть состояниями.,вершины,gramm,0
"важно отметить, что это изменение касается только внутреннего представления программы и не требует изменения входного языка.",представления,gramm,0
лексический анализатор заполнил поле name; значения полей declare и type будем заполнять на этапе семантического анализа.,значения полей,gramm,0
"левую рекурсию всегда можно заменить правой: a 1a ... ma a 1a ... na будет получена грамматика, эквивалентная данной, т.к. из нетерминала a по-прежнему выводятся цепочки вида j { i}, где i = 1,2,...,n; j = 1,2,...,m.",левую рекурсию,gramm,0
"- издание второе (переработанное и дополненное) издательский отдел факультета вмик мгу (лицензия лр no040777 от 23.07.96), 1998.-62 с. печатается по решению редакционно-издательского совета факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова 4 isbn 5-89407-032-5 издательский отдел факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова, 1999 5 элементы теори и формальных языков и грамматик введение.",решению редакционно,gramm,0
"теперь каждая дуга в дс может выглядеть так: a t1,t2,...,tn b d1;d2;...;dm смысл ti прежний - если в состоянии a очередной анализируемый символ совпадает с ti для какого-либо i = 1, 2 ,... n, то осуществляется переход в состояние b; при этом необходимо выполнить действия d1, d2, ... ,dm.",анализируемый символ,gramm,0
"определение: недетерминированный конечный автомат (нка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt в множество подмножеств k; h k - конечное множество начальных состояний; s k - конечное множество заключительных состояний.",подмножеств,gramm,0
"здесь введены базовые понятия и даны определения, связанные с одним из основных механизмов определения языков - грамматиками, приведена наиболее распространенная классификация грамматик (по хомскому).",понятия,gramm,0
"пример: совокупность процедур рекурсивного спуска для грамматики g = ({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba будет такой: #include <stdio.h> int c; file fp;/ указатель на файл, в котором находится анализируе-мая цепочка / void a(); void b(); void error(); / функция обработки ошибок / void s() {a(); b(); 40 if (c != ' ') error(); } void a() {if (c=='a') c = fgetc(fp); else if (c == 'c') {c = fgetc(fp); a();} else error(); } void b() {if (c == 'b') {c = fgetc(fp); a();} else error(); } void error() {printf(""error !!!",спуска,gramm,0
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",состояние,gramm,0
"тогда функция void dec (char t) {int i; while ((i = ipop()) != -1) decid(i,t); } считывает из стека номера строк tid и заносит в них информацию о наличии описания и о типе t. с учетом этих функций правило вывода с действиями для обработки описаний будет таким: d < ipush (-1) > i < ipush (curr lex.value) > {, i < ipush (curr lex.value) >}: [ int < dec (""int"") > bool < dec (""bool"") > ] контроль контекстных условий в выражении пусть есть функция char gettype (char op, char t1, char t2), которая проверяет допустимость сочетания операндов типа t1 (первый операнд) и типа t2 (второй операнд) в операции op; если типы совместимы, то выдает тип результата этой операции; иначе - строку ""no"".",сочетания,gramm,0
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",правилом вывода,gramm,0
"семантика условного оператора if e then s1 else s2 такова, что значения операндов для операций безусловного перехода и перехода ""по лжи"" в момент генерации операций еще неизвестны: if (!e) goto l2; s1; goto l3; l2: s2; l3:... поэтому придется запоминать номера элементов в массиве p, соответствующих этим операндам, а затем, когда станут известны их значения, заполнять пропущенное.",элементов,gramm,0
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); следовательно, достаточно извлечь его из стека и проверить: void eqbool (void) {if (strcmp (spop(), ""bool"")) error();} тогда правила для условного оператора и оператора цикла будут такими: if e <eqbool()> then s else s while e <eqbool()> do s в итоге получаем процедуры для синтаксического анализа методом рекурсивного спуска с синтаксически-управляемым контролем контекстных условий, которые легко написать по правилам грамматики с действиями.",результате контроля,gramm,0
"32 буква,цифра gc(); makelex(2,n:=); makelex(2,n:); add();gc(); gc(); id or word(); makelex(3,putnum()); is dlm(); makelex(2,j) h : { цифра makelex (2, n ); gc(); gc(); d=c- 0 ; gc(); clear(); add(); clear(); add(); gc(); буква id = num цифра d=d 10+(c- 0 ); gc(); com } gc(); er ass fin dlm gc(); замечания: 1) символом nx в диаграмме (и в тексте программы) обозначен номер лексемы x в ее классе.",тексте программы,gramm,0
"6 определение: обращением (или реверсом) цепочки называется цепочка, символы которой записаны в обратном порядке.",символы,gramm,0
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",генерации полиза,gramm,0
"тогда функция void dec (char t) {int i; while ((i = ipop()) != -1) decid(i,t); } считывает из стека номера строк tid и заносит в них информацию о наличии описания и о типе t. с учетом этих функций правило вывода с действиями для обработки описаний будет таким: d < ipush (-1) > i < ipush (curr lex.value) > {, i < ipush (curr lex.value) >}: [ int < dec (""int"") > bool < dec (""bool"") > ] контроль контекстных условий в выражении пусть есть функция char gettype (char op, char t1, char t2), которая проверяет допустимость сочетания операндов типа t1 (первый операнд) и типа t2 (второй операнд) в операции op; если типы совместимы, то выдает тип результата этой операции; иначе - строку ""no"".",описаний,gramm,0
"в качестве примера приведем функцию для нетерминала d (раздел описаний): #include <string.h> #define maxsize tid 1000 #define maxsize td 50 char td[maxsize td]; struct record {char name; int declare; char type; / ... / }; struct record tid [maxsize tid]; / описание функций error(), getlex(), id(), eq(char ), типа struct lex и переменной curr lex - в алгоритме рекурсивного спуска для м-языка / void error(void); struct lex {int class; int value;}; struct lex curr lex; struct lex getlex (void); int id (void); int eq (char s); void ipush (int i); int ipop (void); void decid (int i, char t) {if (tid [i].declare) error(); else {tid [i].declare = 1; strcpy (tid [i].type, t);} } void dec (char t) {int i; while ((i = ipop()) !",описание функций,gramm,0
"f(a, t) = b означает, что из состояния a по входному символу t происходит переход в состояние b. определение: конечный автомат допускает цепочку a1a2...an, если f(h,a1) = a1; f(a1,a2) = a2; . . .",конечный автомат,gramm,0
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",методом,gramm,0
"63 идея алгоритма очень проста: просматриваем полиз слева направо; если встречаем операнд, то записываем его в стек; если встретили знак операции, то извлекаем из стека нужное количество операндов и выполняем операцию, результат (если он есть) заносим в стек и т.д.",операцию,gramm,0
"42 b) если в грамматике есть нетерминал, у которого несколько правил вывода начинаются одинаковыми терминальными символами, т.е. имеют вид a a 1 a 2 ... a n 1 ... m, где a vt; i, j (vt vn) , то непосредственно применять рс-метод нельзя.",вывода,gramm,0
множество состояний к состоит из всех подмножеств множества к.,подмножеств множества,gramm,0
"считаем, что к моменту интерпретации распределена память под константы и переменные, адреса занесены в поле address таблиц tid и tnum, значения констант размещены в памяти.",памяти,gramm,0
"определение: множество follow(a) -это множество терминальных символов, которые следуют за цепочками, выводимыми из а в грамматике g = (vt, vn, p, s), т.е. follow(a) = { a vt s a , a , a vn, , , (vt vn) }.",символов,gramm,0
"31 c - очередной входной символ; d - переменная для формирования числового значения константы; tw - таблица служебных слов м-языка; td - таблица ограничителей м-языка; tid - таблица идентификаторов анализируемой программы; tnum - таблица чисел-констант, используемых в программе.",формирования числового,gramm,0
"; arg = ipop(); if (!arg) {i = j-1}; break;}; / если значение arg ложно, то интерпретация будет продолжена с j -го элемента полиза, иначе порядок не изменится / if (eq ("":="")) {arg = ipop(); ip = (int )ipop(); ip = arg; break;}; if (eq (""r"")) {ip = (int ) ipop();",интерпретация,gramm,0
"определение: дерево называется деревом вывода (или деревом разбора) в кс-грамматике g = {vt, vn, p, s), если выполнены следующие условия: (1) каждая вершина дерева помечена символом из множества (vn vt ) , при этом корень дерева помечен символом s; листья - символами из (vt ); (2) если вершина дерева помечена символом a vn, а ее непосредственные потомки - символами a1, a2, ... , an, где каждое ai (vt vn), то a a1a2...an - правило вывода в этой грамматике; (3) если вершина дерева помечена символом a vn, а ее единственный непосредственный потомок помечен символом , то a - правило вывода в этой грамматике.",определение,gramm,0
"теперь, параллельно с анализом исходной цепочки лексем, будем выполнять действия по генерации внутреннего представления программы.",генерации,gramm,0
"31 c - очередной входной символ; d - переменная для формирования числового значения константы; tw - таблица служебных слов м-языка; td - таблица ограничителей м-языка; tid - таблица идентификаторов анализируемой программы; tnum - таблица чисел-констант, используемых в программе.",значения константы,gramm,0
"f, r, w) относятся к классу ограничителей, как и все другие операции модельного языка; 2) для ссылок на номера элементов полиза введем лексемы класса 0, т.е. (0,p) - лексема, обозначающая p-ый элемент в полизе; 3) для того, чтобы различать операнды-значения-переменных и операнды-адреса-переменных (например, в полизе оператора присваивания), операнды-значения будем обозначать лексемами класса 4, а для операндов-адресов введем лексемы класса 5.",операнды-значения,gramm,0
некоторые общепринятые способы внутреннего представления программ: a) постфиксная запись b),запись,gramm,0
грамматики этих классов широко используются при трансляции языков программирования.,трансляции языков программирования,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",дерева разбора методом,gramm,0
"введем состояние ошибки (er); переход в это состояние будет означать, что исходная цепочка языку не принадлежит.",переход,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",разбора методом,gramm,0
"во втором издании исправлены неточности и ошибки первого издания, расширен набор задач: номера первого издания сохранены, но появились дополнительные пункты, отмеченные малыми латинскими буквами.",издания,gramm,0
"эти действия можно выполнить с помощью функции checkid: void checkid (void) {int i; i = curr lex.value; if (tid [i].declare) / описан? / spush (tid [i].type); / тип - в стек / else error(); / описание отсутствует / } тогда для контроля контекстных условий каждой тройки - ""операнд-операция-операнд"" будем использовать функцию checkop: void checkop (void) {char op; char t1;char t2; char res; t2 = spop(); / из стека - тип второго операнда / op = spop(); / из стека - обозначение операции / t1 = spop(); / из стека - тип первого операнда / res = gettype (op,t1,t2); / допустимо ? / if (strcmp (res, ""no"")) spush (res); / да! / else error(); / нет! / } для контроля за типом операнда одноместной операции not будем использовать функцию checknot: void checknot (void) { if (strcmp (spop (), ""bool"")) error(); else spush (""bool"");} теперь главный вопрос: когда вызывать эти функции?",стека - тип второго,gramm,0
"31 c - очередной входной символ; d - переменная для формирования числового значения константы; tw - таблица служебных слов м-языка; td - таблица ограничителей м-языка; tid - таблица идентификаторов анализируемой программы; tnum - таблица чисел-констант, используемых в программе.",слов м-языка,gramm,0
авторы выражают благодарность пильщикову в.н.,благодарность,gramm,0
существует несколько способов построения промежуточной программы.,промежуточной программы,gramm,0
"определение: недетерминированный конечный автомат (нка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt в множество подмножеств k; h k - конечное множество начальных состояний; s k - конечное множество заключительных состояний.",определение,gramm,0
"по нашей диаграмме знак ""!="" представлен двумя лексемами, хотя нужно сделать одну лексему, по аналогии с "":="".",диаграмме знак,gramm,0
контроль контекстных условий в операторах s i := e if e then s else e while e do s b read (i) write (e) 1) оператор присваивания i := e контекстное условие: в операторе присваивания типы переменной i и выражения e должны совпадать.,типы переменной,gramm,0
"естественно, возникает вопрос: если грамматика не удовлетворяет этим условиям, то существует ли эквивалентная кс-грамматика, для которой метод рекурсивного спуска применим?",спуска,gramm,0
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",символов,gramm,0
"в этом случае во время интерпретации операции ""-"" возникнет неоднозначность: сколько операндов надо извлекать из стека и какую операцию выполнять.",интерпретации операции,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",методом,gramm,0
"соглашение: в дальнейшем, если особо не оговорено, под регулярной грамматикой будем понимать леволинейную грамматику.",соглашение,gramm,0
"(4) на некотором шаге работы алгоритма оказалось, что есть более одной подходящей свертки, т.е. в грамматике разные нетерминалы имеют правила вывода с одинаковыми правыми частями, и поэтому непонятно, к какому из них производить свертку.",грамматике разные,gramm,0
тип выражения и совместимость типов операндов в выражении определяются по обычным правилам; старшинство операций задано синтаксисом.,синтаксисом,gramm,0
"здесь введены базовые понятия и даны определения, связанные с одним из основных механизмов определения языков - грамматиками, приведена наиболее распространенная классификация грамматик (по хомскому).",базовые понятия,gramm,0
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",процессов,gramm,0
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",правило,gramm,0
для этого дополним грамматику вызовами соответствующих процедур генерации.,процедур,gramm,0
"во втором издании исправлены неточности и ошибки первого издания, расширен набор задач: номера первого издания сохранены, но появились дополнительные пункты, отмеченные малыми латинскими буквами.",пункты,gramm,0
"таблицы tw и td заполнены заранее, т.к. их содержимое не зависит от исходной программы; tid и tnum будут формироваться в процессе анализа; для простоты будем считать, что все таблицы одного типа; пусть tabl - имя типа этих таблиц, ptabl - указатель на tabl.",таблиц,gramm,0
определение: цепочкой символов в алфавите v называется любая конечная последовательность символов этого алфавита.,символов,gramm,0
"для кс-грамматик можно ввести удобное графическое представление вывода, называемое деревом вывода, причем для всех эквивалентных выводов деревья вывода совпадают.",графическое представление вывода,gramm,0
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",понятия,gramm,0
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",функцией,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",польская запись,gramm,0
"предполагается, что термин ""символ"" имеет достаточно ясный интуитивный смысл и не нуждается в дальнейшем уточнении.",уточнении,gramm,0
"кроме того, нужно проверять, нет ли повторных описаний идентификаторов.",идентификаторов,gramm,0
"для этого будем использовать функции работы со стеком целых чисел: void ipush (int i); / значение i - в стек / int ipop (void); / из стека - целое / будем считать, что (-1) - ""дно"" стека;",функции работы,gramm,0
"в качестве примера приведем функцию для нетерминала d (раздел описаний): #include <string.h> #define maxsize tid 1000 #define maxsize td 50 char td[maxsize td]; struct record {char name; int declare; char type; / ... / }; struct record tid [maxsize tid]; / описание функций error(), getlex(), id(), eq(char ), типа struct lex и переменной curr lex - в алгоритме рекурсивного спуска для м-языка / void error(void); struct lex {int class; int value;}; struct lex curr lex; struct lex getlex (void); int id (void); int eq (char s); void ipush (int i); int ipop (void); void decid (int i, char t) {if (tid [i].declare) error(); else {tid [i].declare = 1; strcpy (tid [i].type, t);} } void dec (char t) {int i; while ((i = ipop()) !",раздел описаний,gramm,0
"генератор внутреннего представления программы на м-языке каждый элемент в полизе - это лексема, т.е. пара вида (номер класса, номер в классе).",классе,gramm,0
"1-""да"", 0-""нет"" / char type; / тип переменной / ... }; тогда таблица идентификаторов tid - это массив структур #define maxsize tid 1000 struct record tid [maxsize tid]; 48 причем i-ая строка соответствует идентификатору-лексеме вида (4,i).",идентификатору-лексеме,gramm,0
для записи правил вывода с одинаковыми левыми частями 1 2 ... n будем пользоваться сокращенной записью 1 2 ... n.,записи,gramm,0
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",ограничителей,gramm,0
"запись выражения в такой форме очень удобна для последующей интерпретации (т.е. вычисления значения этого выражения) с помощью стека: выражение просматривается один раз слева направо, при этом (1)если очередной элемент полиза - это операнд, то его значение заносится в стек; (2)если очередной элемент полиза - это операция, то на ""верхушке"" стека сейчас находятся ее операнды (это следует из определения полиза и предшествующих действий алгоритма); они извлекаются из стека, над ними выполняется операция, результат снова заносится в стек; (3)когда выражение, записанное в полизе, прочитано, в стеке останется один элемент - это значение всего выражения.",значения,gramm,0
"удаление символов сопровождается удалением правил вывода, содержащих эти символы.",удалением,gramm,0
"интерпретатор полиза для модельного языка польская инверсная запись была выбрана нами в качестве языка внутреннего представления программы, в частности, потому, что записанная таким образом программа может быть легко проинтерпретирована.",интерпретатор полиза,gramm,0
"типы операндов и обозначение операции будем хранить в стеке; для этого нам нужны функции для работы со стеком строк: 49 void spush (char s); / значение s - в стек / char spop (void); / из стека - строку / если в выражении встречается лексема-целое число или логические константы true или false, то соответствующий тип сразу заносим в стек с помощью spush(""int"") или spush(""bool"").",работы,gramm,0
"таблицы tw и td заполнены заранее, т.к. их содержимое не зависит от исходной программы; tid и tnum будут формироваться в процессе анализа; для простоты будем считать, что все таблицы одного типа; пусть tabl - имя типа этих таблиц, ptabl - указатель на tabl.",таблицы,gramm,0
"удаление символов сопровождается удалением правил вывода, содержащих эти символы.",правил вывода,gramm,0
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",операции,gramm,0
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",генерация объектной,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",записи,gramm,0
"во втором издании исправлены неточности и ошибки первого издания, расширен набор задач: номера первого издания сохранены, но появились дополнительные пункты, отмеченные малыми латинскими буквами.",ошибки,gramm,0
"- операция выбора элемента полиза, номер которого равен p. немного сложнее окажется запись в полизе условных операторов и операторов цикла.",запись,gramm,0
"генерация внутреннего представления программы будет проходить во время синтаксического анализа параллельно с контролем контекстных условий, поэтому для генерации можно использовать информацию, ""собранную"" синтаксическим и семантическим анализаторами; например, при генерации полиза выражений можно воспользоваться содержимым стека, с которым работает семантический анализатор.",семантический анализатор,gramm,0
"запись выражения в такой форме очень удобна для последующей интерпретации (т.е. вычисления значения этого выражения) с помощью стека: выражение просматривается один раз слева направо, при этом (1)если очередной элемент полиза - это операнд, то его значение заносится в стек; (2)если очередной элемент полиза - это операция, то на ""верхушке"" стека сейчас находятся ее операнды (это следует из определения полиза и предшествующих действий алгоритма); они извлекаются из стека, над ними выполняется операция, результат снова заносится в стек; (3)когда выражение, записанное в полизе, прочитано, в стеке останется один элемент - это значение всего выражения.",действий,gramm,0
"семантика условного оператора if e then s1 else s2 такова, что значения операндов для операций безусловного перехода и перехода ""по лжи"" в момент генерации операций еще неизвестны: if (!e) goto l2; s1; goto l3; l2: s2; l3:... поэтому придется запоминать номера элементов в массиве p, соответствующих этим операндам, а затем, когда станут известны их значения, заполнять пропущенное.",генерации операций,gramm,0
"естественно, возникает вопрос: если грамматика не удовлетворяет этим условиям, то существует ли эквивалентная кс-грамматика, для которой метод рекурсивного спуска применим?",спуска применим,gramm,0
длина вывода равна 3.,длина вывода,gramm,0
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); если при анализе идентификатора i проверить, описан ли он, и занести его тип в тот же стек ( для этого можно использовать функцию checkid() ), то достаточно будет в нужный момент считать из стека два элемента и сравнить их: void eqtype (void) { if (strcmp (spop (), spop ())) error();} следовательно, правило для оператора присваивания: i <checkid()> := e <eqtype()> 51 2) условный оператор и оператор цикла if e then s else s while e do s контекстные условия: в условном операторе и в операторе цикла в качестве условия возможны только логические выражения.",условий,gramm,0
язык внутреннего представления программы основные свойства языка внутреннего представления программ: a) он позволяет фиксировать синтаксическую структуру исходной программы; b) текст на нем можно автоматически генерировать во время синтаксического анализа; c) его конструкции должны относительно просто транслироваться в объектный код либо достаточно эффективно интерпретироваться.,свойства языка,gramm,0
"замечание: может оказаться так, что знак бинарной операции по написанию совпадает со знаком унарной; например, знак ""-"" в большинстве языков программирования означает и бинарную операцию вычитания, и унарную операцию изменения знака.",унарную операцию изменения знака,gramm,0
"для кс-грамматик можно ввести удобное графическое представление вывода, называемое деревом вывода, причем для всех эквивалентных выводов деревья вывода совпадают.",вывода,gramm,0
"1-""да"", 0-""нет"" / char type; / тип переменной / ... }; тогда таблица идентификаторов tid - это массив структур #define maxsize tid 1000 struct record tid [maxsize tid]; 48 причем i-ая строка соответствует идентификатору-лексеме вида (4,i).",массив,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",словами,gramm,0
"нам придется расширить набор лексем: 1) будем считать, что новые операции (!, !",новые операции,gramm,0
в интерпретаторах и при смешанной стратегии трансляции некоторые этапы могут вообще отсутствовать.,трансляции,gramm,0
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",генерации,gramm,0
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",свойством,gramm,0
"процесс построения такого вывода ( а, следовательно, и определения принадлежности цепочки языку) называется разбором.",построения,gramm,0
определение: язык в алфавите v - это подмножество цепочек конечной длины в этом алфавите.,подмножество цепочек конечной,gramm,0
"f(a,t) = {b1,b2,...,bn} означает, что из состояния a по входному символу t можно осуществить переход в любое из состояний bi, i = 1, 2, ... ,n. в этом случае можно предложить алгоритм, который будет перебирать все возможные варианты сверток (переходов) один за другим; если цепочка принадлежит языку, то будет найден путь, ведущий к успеху; если будут просмотрены все варианты, и 28 каждый из них будет завершаться неудачей, то цепочка языку не принадлежит.",состояний,gramm,0
номер в классе - это номер строки в таблице лексем соответствующего класса.,лексем,gramm,0
"содержательный пример - генерация внутреннего представления программы для м-языка, приведен ниже, а здесь в качестве иллюстрации рассмотрим более простой пример.",представления,gramm,0
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",исходном представлении,gramm,0
"обработка описаний для контроля согласованности типов в выражениях и типов выражений в операторах, необходимо знать типы переменных, входящих в эти выражения.",типы переменных,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",эквивалентно построению дерева разбора,gramm,0
"в грамматике модельного языка задано старшинство операций: наивысший приоритет имеет операция отрицания, затем в порядке убывания приоритета - группа операций умножения ( , /, and), группа операций сложения (+,-,or), операции отношения.",порядке убывания приоритета -,gramm,0
"но чаще информацию о возможных свертках представляют в виде диаграммы состояний (дс) - неупорядоченного ориентированного помеченного графа, который строится следующим образом: (1) строят вершины графа, помеченные нетерминалами грамматики (для каждого нетерминала - одну вершину), и еще одну вершину, помеченную символом, отличным от нетерминальных (например, h).",нетерминалами,gramm,0
язык внутреннего представления программы основные свойства языка внутреннего представления программ: a) он позволяет фиксировать синтаксическую структуру исходной программы; b) текст на нем можно автоматически генерировать во время синтаксического анализа; c) его конструкции должны относительно просто транслироваться в объектный код либо достаточно эффективно интерпретироваться.,анализа,gramm,0
"можно преобразовать правила вывода данного нетерминала, объединив правила с общими началами в одно правило: a aa 1 ... m a 1 2 ... n будет получена грамматика, эквивалентная данной.",правила вывода,gramm,0
"об используемых функциях: int id (void); - результат равен 1, если curr lex.class = 4, т.е. curr lex представляет идентификатор, и 0 - в противном случае; int num (void); - результат равен 1, если curr lex.class = 3, т.е. curr lex представляет число-константу, и 0 - в противном случае; int eq (char s); - результат равен 1, если curr lex представляет строку s, и 0 - иначе ; void error (void) - функция обработки ошибки; при обнаружении ошибки работа анализатора прекращается.",константу,gramm,0
именно этот способ описания языков чаще всего будет использоваться нами в дальнейшем.,описания языков,gramm,0
"каждый оператор языка программирования может быть представлен как n-местная операция с семантикой, соответствующей семантике этого оператора.",местная операция,gramm,0
"генерация внутреннего представления программы будет проходить во время синтаксического анализа параллельно с контролем контекстных условий, поэтому для генерации можно использовать информацию, ""собранную"" синтаксическим и семантическим анализаторами; например, при генерации полиза выражений можно воспользоваться содержимым стека, с которым работает семантический анализатор.",представления,gramm,0
"в этом разделе изложены некоторые аспекты теории формальных языков, существенные с точки зрения трансляции.",зрения трансляции,gramm,0
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",часть подцепочки,gramm,0
"грамматики этого класса, с одной стороны, позволяют достаточно полно описать синтаксическую структуру реальных языков программирования; с другой стороны, для разных подклассов укс-грамматик существуют достаточно эффективные алгоритмы разбора.",структуру реальных,gramm,0
"определенная нами неоднозначность - это свойство грамматики, а не языка, т.е. для некоторых неоднозначных грамматик существуют эквивалентные им однозначные грамматики.",неоднозначность,gramm,0
"\n""); exit(0); } о применимости метода рекурсивного спуска метод рекурсивного спуска применим в том случае, если каждое правило грамматики имеет вид: a) либо a , где (vt vn) и это единственное правило вывода для этого нетерминала; b) либо a a1 1 a2 2 ... an n, где ai vt для всех i = 1,2,...,n; ai aj для i j; i (vt vn) , т.",спуска,gramm,0
"определение: обозначим через v множество, содержащее все цепочки конечной длины в алфавите v, включая пустую цепочку .",множество,gramm,0
язык внутреннего представления программы основные свойства языка внутреннего представления программ: a) он позволяет фиксировать синтаксическую структуру исходной программы; b) текст на нем можно автоматически генерировать во время синтаксического анализа; c) его конструкции должны относительно просто транслироваться в объектный код либо достаточно эффективно интерпретироваться.,внутреннего представления программ,gramm,0
"если договориться, что else должно соответствовать ближайшему к нему then, и подправить грамматику g, то неоднозначность будет устранена: s if b then s if b then s else s a s if b then s else s a проблема, порождает ли данная кс-грамматика однозначный язык (т.е. существует ли эквивалентная ей однозначная грамматика), является алгоритмически неразрешимой.",неоднозначность,gramm,0
"например, для грамматики g = ({a,b, }, {s,a,b}, p, s), где p: s a a a bb b b bb разбор будет недетерминированным (т.к. у нетерминалов a и b есть одинаковые правые части - bb).",части -,gramm,0
"однако структура таких конструкций как выражение, описание, оператор и т.п., более сложная, чем структура идентификаторов и чисел.",оператор,gramm,0
"замечание: если в этом алгоритме переставить шаги (1) и (2), то не всегда результатом будет приведенная грамматика.",результатом,gramm,0
"для студентов факультета вмк в поддержку основного лекционного курса системное программное обеспечение и для преподавателей, ведущих практические занятия по этому курсу.",поддержку основного,gramm,0
"если такую подцепочку считать не удается, то процедура завершает свою работу вызовом процедуры обработки ошибки, которая выдает сообщение о том, что цепочка не принадлежит языку, и останавливает разбор.",вызовом процедуры,gramm,0
"однако в грамматике g = ({a,b,с}, {s,a}, p, s), где p: s baс a aa нет проблем с применением метода рекурсивного спуска.",грамматике g,gramm,0
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется левым (левосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого левого нетерминала.",кс- грамматике,gramm,0
"замечание: может оказаться так, что знак бинарной операции по написанию совпадает со знаком унарной; например, знак ""-"" в большинстве языков программирования означает и бинарную операцию вычитания, и унарную операцию изменения знака.",операцию,gramm,0
"если такую подцепочку считать не удается, то процедура завершает свою работу вызовом процедуры обработки ошибки, которая выдает сообщение о том, что цепочка не принадлежит языку, и останавливает разбор.",работу вызовом процедуры обработки,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",признак конца цепочки,gramm,0
"лексический анализ рассмотрим методы и средства, которые обычно используются при построении лексических анализаторов.",построении лексических,gramm,0
"выпишем условие, при котором -правило вывода делает неприменимым рс-метод.",условие,gramm,0
"если допустить в правилах вывода грамматики пустую альтернативу, т.е. правила вида a a1 1 ... an n , то метод рекурсивного спуска может оказаться неприменимым (несмотря на то, что в остальном достаточные условия применимости выполняются).",достаточные условия,gramm,0
"если для синтаксического анализа используется метод рекурсивного спуска, то в тела процедур рс-метода необходимо вставить вызовы дополнительных ""семантических"" процедур (семантические действия).",вызовы,gramm,0
"31 c - очередной входной символ; d - переменная для формирования числового значения константы; tw - таблица служебных слов м-языка; td - таблица ограничителей м-языка; tid - таблица идентификаторов анализируемой программы; tnum - таблица чисел-констант, используемых в программе.",служебных слов,gramm,0
"выбор определения не влияет на множество языков, порождаемых грамматиками этого класса, поскольку доказано, что множество языков, порождаемых неукорачивающими 9 грамматиками, совпадает с множеством языков, порождаемых кз- грамматиками.",множеством,gramm,0
57 в полизе операнды выписаны слева направо в порядке их использования.,использования,gramm,0
тип выражения и совместимость типов операндов в выражении определяются по обычным правилам (как в паскале).,совместимость типов,gramm,0
"особое внимание уделяется контекстно-свободным грамматикам и, в частности, их важному подклассу - регулярным грамматикам.",особое внимание,gramm,0
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",автомата,gramm,0
"попытаемся ослабить требования на вид правил грамматики: (1) при описании синтаксиса языков программирования часто встречаются правила, описывающие последовательность однотипных конструкций, отделенных друг от друга каким-либо знаком-разделителем (например, список идентификаторов при описании переменных, список параметров при вызове процедур и функций и т.п.).",разделителем,gramm,0
"нужно отметить, что в языках программирования ограничителем подобных серий всегда является символ, отличный от разделителя, поэтому подобных проблем не возникает.",программирования ограничителем подобных,gramm,0
лексический анализатор для м-языка вход лексического анализатора - символы исходной программы на м-языке; результат работы - исходная программа в виде последовательности лексем (их внутреннего представления).,вход лексического,gramm,0
"однако перед лексическим анализатором стоит более сложная задача: он должен сам выделить в исходном тексте цепочку символов, представляющую лексему, а также преобразовать ее в пару (тип лексемы, указатель на информацию о ней).",анализатором,gramm,0
проиллюстрируем работу алгоритма на примере.,работу,gramm,0
"здесь не приводятся доказательства сформулированных фактов, свойств, теорем, доказательства правильности алгоритмов; их можно найти в книгах, указанных в списке литературы.",списке литературы,gramm,0
элементы теории трансляции.,теории трансляции,gramm,0
"12 в грамматике для одной и той же цепочки может быть несколько выводов, эквивалентных в том смысле, что в них в одних и тех же местах применяются одни и те же правила вывода, но в различном порядке.",вывода,gramm,0
для записи правил вывода с одинаковыми левыми частями 1 2 ... n будем пользоваться сокращенной записью 1 2 ... n.,вывода,gramm,0
"true, false, read и write - служебные слова (их нельзя переопределять, как стандартные идентификаторы паскаля).",стандартные идентификаторы,gramm,0
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); следовательно, достаточно извлечь его из стека и проверить: void eqbool (void) {if (strcmp (spop(), ""bool"")) error();} тогда правила для условного оператора и оператора цикла будут такими: if e <eqbool()> then s else s while e <eqbool()> do s в итоге получаем процедуры для синтаксического анализа методом рекурсивного спуска с синтаксически-управляемым контролем контекстных условий, которые легко написать по правилам грамматики с действиями.",действиями,gramm,0
"определение: кс-грамматика g называется приведенной, если в ней нет недостижимых и бесплодных символов.",определение,gramm,0
"при нисходящем разборе дерево вывода формируется от корня к листьям; на каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти такое правило вывода, чтобы имеющиеся в нем терминальные символы проектировались на символы исходной цепочки.",правило,gramm,0
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",символом-меткой дуги,gramm,0
"тогда функция void dec (char t) {int i; while ((i = ipop()) != -1) decid(i,t); } считывает из стека номера строк tid и заносит в них информацию о наличии описания и о типе t. с учетом этих функций правило вывода с действиями для обработки описаний будет таким: d < ipush (-1) > i < ipush (curr lex.value) > {, i < ipush (curr lex.value) >}: [ int < dec (""int"") > bool < dec (""bool"") > ] контроль контекстных условий в выражении пусть есть функция char gettype (char op, char t1, char t2), которая проверяет допустимость сочетания операндов типа t1 (первый операнд) и типа t2 (второй операнд) в операции op; если типы совместимы, то выдает тип результата этой операции; иначе - строку ""no"".",сочетания операндов,gramm,0
"32 буква,цифра gc(); makelex(2,n:=); makelex(2,n:); add();gc(); gc(); id or word(); makelex(3,putnum()); is dlm(); makelex(2,j) h : { цифра makelex (2, n ); gc(); gc(); d=c- 0 ; gc(); clear(); add(); clear(); add(); gc(); буква id = num цифра d=d 10+(c- 0 ); gc(); com } gc(); er ass fin dlm gc(); замечания: 1) символом nx в диаграмме (и в тексте программы) обозначен номер лексемы x в ее классе.",символом,gramm,0
"каждая лексема - это структура struct lex {int class; int value;}, возможные значения поля class: 0 - лексемы-метки (номера элементов в полизе) 1 - логические константы true либо false ( других лексем - служебных слов в полизе нет) 2 - операции (других лексем-ограничителей в полизе нет)",лексема -,gramm,0
"постфиксная польская запись может использоваться не только для интерпретации промежуточной программы, но и для генерации по ней объектной программы.",программы,gramm,0
"нужно отметить, что в языках программирования ограничителем подобных серий всегда является символ, отличный от разделителя, поэтому подобных проблем не возникает.",подобных серий,gramm,0
"для того, чтобы решить эту задачу, опираясь на способ анализа с помощью диаграммы состояний, введем на дугах дополнительный вид пометок - пометки-действия.",пометок,gramm,0
диаграмма состояний для лексического анализатора приведена на следующей странице.,анализатора,gramm,0
"для более удобной работы с диаграммами состояний введем несколько соглашений: a) если из одного состояния в другое выходит несколько дуг, помеченных разными символами, то будем изображать одну дугу, помеченную всеми этими символами; b) непомеченная дуга будет соответствовать переходу при любом символе, кроме тех, которыми помечены другие дуги, выходящие из этого состояния.",разными символами,gramm,0
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",обозначение операции,gramm,0
"24 это можно сделать в виде таблицы, строки которой помечены нетерминальными символами грамматики, столбцы - терминальными.",строки,gramm,0
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",номер первого свободного элемента,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",признак,gramm,0
"если для нетерминала а правил вывода несколько, то они должны начинаться с терминалов, причем все эти терминалы должны быть различными.",терминалы должны,gramm,0
"6 определение: обращением (или реверсом) цепочки называется цепочка, символы которой записаны в обратном порядке.",определение,gramm,0
грамматики этих классов широко используются при трансляции языков программирования.,языков программирования,gramm,0
"в этом разделе мы рассмотрим некоторые методы, используемые для построения анализаторов (лексического, синтаксического и семантического), язык промежуточного представления программы, способ генерации промежуточной программы, ее интерпретации.",методы,gramm,0
информацию о типе переменных и о наличии их описания естественно заносить в ту же таблицу.,описания,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",вызове,gramm,0
"общий вид этих правил: l a a,l ( либо в сокращенной форме l a {,a} ) 41 формально здесь не выполняются условия применимости метода рекурсивного спуска, т.к. две альтернативы начинаются одинаковыми терминальными символами.",применимости метода рекурсивного,gramm,0
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",результате,gramm,0
"определение: символ x (vt vn) называется недостижимым в грамматике g = (vt, vn, p, s), если он не появляется ни в одной сентенциальной форме этой грамматики.",символ,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",применений правил вывода эквивалентна,gramm,0
"каждый оператор языка программирования может быть представлен как n-местная операция с семантикой, соответствующей семантике этого оператора.",оператора,gramm,0
"определение: недетерминированный конечный автомат (нка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt в множество подмножеств k; h k - конечное множество начальных состояний; s k - конечное множество заключительных состояний.",конечный автомат,gramm,0
"с теоретической точки зрения существует алгоритм, который по любой данной кс-грамматике и данной цепочке выясняет, принадлежит ли цепочка языку, порождаемому этой грамматикой.",алгоритм,gramm,0
"грамматика g = (vt, vn, p, s) называется леволинейной, если каждое правило из р имеет вид a bt либо a t, где a vn, b vn, t vt.",грамматика g,gramm,0
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",работе,gramm,0
"поэтому для описания синтаксиса языков программирования нужны более мощные грамматики, чем регулярные.",описания,gramm,0
существует несколько способов построения промежуточной программы.,способов построения промежуточной,gramm,0
"если допустить в правилах вывода грамматики пустую альтернативу, т.е. правила вида a a1 1 ... an n , то метод рекурсивного спуска может оказаться неприменимым (несмотря на то, что в остальном достаточные условия применимости выполняются).",вывода грамматики пустую,gramm,0
"9 замечание: a) запись вида { } означает итерацию цепочки , т.е. в порождаемой цепочке в этом месте может находиться либо , либо , либо , либо и т.д. b) запись вида [ ] означает, что в порождаемой цепочке в этом месте может находиться либо , либо . c) p - цель грамматики; символ - маркер конца текста программы.",итерацию цепочки,gramm,0
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",символом,gramm,0
"пусть полиз оператора, помеченного меткой l, начинается с номера p, тогда оператор перехода goto l в полизе можно записать как p !",оператор,gramm,0
для ее обозначения будем использовать символ .,обозначения,gramm,0
"синтаксически управляемый перевод на практике синтаксический, семантический анализ и генерация внутреннего представления программы часто осуществляются одновременно.",перевод,gramm,0
"для того, чтобы решить эту задачу, опираясь на способ анализа с помощью диаграммы состояний, введем на дугах дополнительный вид пометок - пометки-действия.",пометки,gramm,0
примеры грамматик и языков.,примеры грамматик,gramm,0
"например, s 000a111 в грамматике g1 (см. пример выше), т.к. существует вывод s 0a1 00a11 000a111.",пример выше,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",вывода эквивалентна,gramm,0
"кроме того, можно дополнить функции семантического анализа действиями по генерации: void checkop p (void) {char op; char t1; char t2; char res; t2 = spop(); op = spop(); t1 = spop(); res = gettype (op,t1,t2); if (strcmp (res, ""no"")) {spush (res); put lex (make op (op));} / дополнение!",действиями,gramm,0
"алгоритмы анализа, расходующие на обработку входной цепочки линейное время, применимы только к некоторым подклассам кс-грамматик.",обработку входной цепочки линейное,gramm,0
"таким образом, лексический анализатор - это транслятор, входом которого служит цепочка символов, представляющих исходную программу, а выходом - последовательность лексем.",программу,gramm,0
"в основе таких анализаторов лежат регулярные грамматики, поэтому рассмотрим грамматики этого класса более подробно.",основе,gramm,0
"- операция выбора элемента полиза, номер которого равен p. немного сложнее окажется запись в полизе условных операторов и операторов цикла.",операторов цикла,gramm,0
"для этого нам потребуется следующая функция: void decid (int i, char t) - в i-той строке таблицы tid контролирует и заполняет поле declare и, если лексема (4,i) впервые встретилась в разделе описаний, заполняет поле type: void decid (int i, char t) {if (tid [i].declare) error(); / повторное описание / else {tid [i].declare = 1; / описан ! / strcpy (tid [i].type, t);} / тип t ! / } раздел описаний имеет вид d i {,i}: [int bool], т.е. имени типа (int или bool) предшествует список идентификаторов.",таблицы,gramm,0
"определение: недетерминированный конечный автомат (нка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt в множество подмножеств k; h k - конечное множество начальных состояний; s k - конечное множество заключительных состояний.",пятерка,gramm,0
"для студентов факультета вмк в поддержку основного лекционного курса системное программное обеспечение и для преподавателей, ведущих практические занятия по этому курсу.",лекционного курса системное программное,gramm,0
"существуют табличные методы анализа ([3]), применимые ко всему классу кс-грамматик и требующие для разбора цепочек длины n времени cn3 (алгоритм кока-янгера-касами) либо cn2 (алгоритм эрли).",алгоритм кока-,gramm,0
"во втором издании исправлены неточности и ошибки первого издания, расширен набор задач: номера первого издания сохранены, но появились дополнительные пункты, отмеченные малыми латинскими буквами.",втором издании,gramm,0
"m полученная грамматика будет эквивалентна исходной, т.к. из b по-прежнему выводятся цепочки вида { i} j либо { i} .",исходной,gramm,0
"считаем, что к моменту интерпретации распределена память под константы и переменные, адреса занесены в поле address таблиц tid и tnum, значения констант размещены в памяти.",интерпретации,gramm,0
"здесь не приводятся доказательства сформулированных фактов, свойств, теорем, доказательства правильности алгоритмов; их можно найти в книгах, указанных в списке литературы.",книгах,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",операторах цикла,gramm,0
"f(a, t) = b означает, что из состояния a по входному символу t происходит переход в состояние b. определение: конечный автомат допускает цепочку a1a2...an, если f(h,a1) = a1; f(a1,a2) = a2; . . .",состояния,gramm,0
в операторе присваивания типы переменной и выражения должны совпадать.,присваивания,gramm,0
"попытаемся ослабить требования на вид правил грамматики: (1) при описании синтаксиса языков программирования часто встречаются правила, описывающие последовательность однотипных конструкций, отделенных друг от друга каким-либо знаком-разделителем (например, список идентификаторов при описании переменных, список параметров при вызове процедур и функций и т.п.).",процедур,gramm,0
"= 'a') error(); } важно, чтобы подцепочки, следующие за цепочкой символов, выводимых из l, не начинались с разделителя (в нашем примере - с запятой), иначе процедура l попытается считать часть исходной цепочки, которая не выводится из l. например, она может порождаться нетерминалом b - соседом l в сентенциальной форме, как в грамматике s lb l a {, a} b ,b если для этой грамматики написать анализатор, действующий рс-методом, то цепочка а,а,а,b будет признана им ошибочной, хотя в действительности это не так.",цепочкой символов,gramm,0
"определение: конечный автомат (ка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt k, определяющее поведение автомата; отображение f часто называют функцией переходов; h k - начальное состояние; 26 s k - заключительное состояние (либо конечное множество заключительных состояний).",автомат,gramm,0
"43 проблема заключается в том, что подцепочка, следующая за цепочкой, выводимой из a, начинается таким же символом, как и цепочка, выводимая из а.",проблема,gramm,0
"в этом разделе изложены некоторые аспекты теории формальных языков, существенные с точки зрения трансляции.",точки зрения,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",задача,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",подцепочку,gramm,0
"определение: порождающая грамматика g - это четверка (vt, vn, p, s), где vt - алфавит терминальных символов ( терминалов ), vn - алфавит нетерминальных символов (нетерминалов), не пересекаю- щийся с vt, p - конечное подмножество множества (vt vn)+ (vt vn) ; элемент ( , ) множества p называется правилом вывода и записывается в виде , 7 s - начальный символ (цель) грамматики, s vn.",конечное подмножество,gramm,0
"определение: обозначим через v множество, содержащее все цепочки конечной длины в алфавите v, включая пустую цепочку .",конечной длины,gramm,0
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",характере взаимодействия,gramm,0
"важно отметить, что это изменение касается только внутреннего представления программы и не требует изменения входного языка.",внутреннего представления программы,gramm,0
"замечание: чаще всего синтаксическим деревом называют дерево вывода исходной цепочки, в котором удалены вершины, соответствующие цепным правилам вида a b, где a, b vn.",дерево вывода исходной,gramm,0
"для студентов факультета вмк в поддержку основного лекционного курса системное программное обеспечение и для преподавателей, ведущих практические занятия по этому курсу.",курса системное,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",т.п. проверку контекстных,gramm,0
"f(a, t) = b означает, что из состояния a по входному символу t происходит переход в состояние b. определение: конечный автомат допускает цепочку a1a2...an, если f(h,a1) = a1; f(a1,a2) = a2; . . .",входному символу t,gramm,0
"соглашение: предположим, что анализируемая цепочка заканчивается специальным символом - признаком конца цепочки.",конца цепочки,gramm,0
"в терминах диаграммы состояний это означает, что из одного состояния выходит несколько дуг, ведущих в разные состояния, но помеченных одним и тем же символом.",состояний,gramm,0
"здесь введены базовые понятия и даны определения, связанные с одним из основных механизмов определения языков - грамматиками, приведена наиболее распространенная классификация грамматик (по хомскому).",классификация грамматик,gramm,0
семантика оператора цикла while b do s может быть описана так: l0: if (not b) then goto l1; s; goto l0; l1: ... .,оператора,gramm,0
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",представления программы,gramm,0
"введем состояние ошибки (er); переход в это состояние будет означать, что исходная цепочка языку не принадлежит.",состояние,gramm,0
"нужно отметить, что в языках программирования ограничителем подобных серий всегда является символ, отличный от разделителя, поэтому подобных проблем не возникает.",программирования,gramm,0
"1) язык типа 0: l(g) = {a2 bn2-1 n >= 1} g: s aacfd f afb ab ab bba ab ba ad d cb bc 11 cb c bcd 2) язык типа 1: l(g) = { an bn cn, n >= 1} g: s asbc abc cb bc bb bb bc bc cc cc 3) язык типа 2: l(g) = {(ac)n (cb)n n > 0} g: s aqb accb q csc 4) язык типа 3: l(g) = { {a,b}+, где нет двух рядом стоящих а} g: s a b a a ba b b bb ab разбор цепочек цепочка принадлежит языку, порождаемому грамматикой, только в том случае, если существует ее вывод из цели этой грамматики.",разбор цепочек,gramm,0
"32 буква,цифра gc(); makelex(2,n:=); makelex(2,n:); add();gc(); gc(); id or word(); makelex(3,putnum()); is dlm(); makelex(2,j) h : { цифра makelex (2, n ); gc(); gc(); d=c- 0 ; gc(); clear(); add(); clear(); add(); gc(); буква id = num цифра d=d 10+(c- 0 ); gc(); com } gc(); er ass fin dlm gc(); замечания: 1) символом nx в диаграмме (и в тексте программы) обозначен номер лексемы x в ее классе.",лексемы x,gramm,0
"f, тогда в полизе она будет записана как b p !",полизе,gramm,0
"известны более широкие подклассы кс- грамматик, для которых существуют эффективные анализаторы, обладающие тем же свойством, что и анализатор, написанный методом рекурсивного спуска, - входная цепочка считывается один раз слева направо и процесс разбора полностью детерминирован, в результате на обработку цепочки длины n расходуется время cn.",анализатор,gramm,0
"замечание: фактически, мы расширили понятие контекстно- свободной грамматики, добавив в ее правила вывода символы- действия.",понятие контекстно-,gramm,0
"в результате контроля контекстных условий выражения e в стеке останется тип этого выражения (как тип результата последней операции); если при анализе идентификатора i проверить, описан ли он, и занести его тип в тот же стек ( для этого можно использовать функцию checkid() ), то достаточно будет в нужный момент считать из стека два элемента и сравнить их: void eqtype (void) { if (strcmp (spop (), spop ())) error();} следовательно, правило для оператора присваивания: i <checkid()> := e <eqtype()> 51 2) условный оператор и оператор цикла if e then s else s while e do s контекстные условия: в условном операторе и в операторе цикла в качестве условия возможны только логические выражения.",анализе идентификатора,gramm,0
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",представления программы оптимизация,gramm,0
"60 пусть есть грамматика, описывающая простейшее арифметическое выражение: e t {+t} t f { f} f a b (e) тогда грамматика с действиями по переводу этого выражения в полиз будет такой: e t {+t <putchar('+')>} t f { f <putchar(' ')>} f a <putchar('a')> b<putchar('b')> (e) этот метод можно использовать для перевода цепочек одного языка в цепочки другого языка (что, собственно, мы и делали, занимаясь переводами в полиз цепочек лексем).",полиз цепочек,gramm,0
"обработка описаний для контроля согласованности типов в выражениях и типов выражений в операторах, необходимо знать типы переменных, входящих в эти выражения.",обработка описаний,gramm,0
определение: длина цепочки - это число составляющих ее символов.,определение,gramm,0
"60 пусть есть грамматика, описывающая простейшее арифметическое выражение: e t {+t} t f { f} f a b (e) тогда грамматика с действиями по переводу этого выражения в полиз будет такой: e t {+t <putchar('+')>} t f { f <putchar(' ')>} f a <putchar('a')> b<putchar('b')> (e) этот метод можно использовать для перевода цепочек одного языка в цепочки другого языка (что, собственно, мы и делали, занимаясь переводами в полиз цепочек лексем).",выражение,gramm,0
"если операнд - лексема-переменная, то необходимо проверить, описана ли она; если описана, то ее тип надо занести в стек.",операнд,gramm,0
"f где p - номер элемента, с которого начинается полиз оператора, помеченного меткой l. семантика условного оператора if b then s1 else s2 с использованием введенной операции может быть описана так: if (not b) then goto l2; s1; goto l3; l2: s2; l3: ... тогда полиз условного оператора будет таким: b p2 !f s1 p3 ! s2 ... , 59 где pi - номер элемента, с которого начинается полиз оператора, помеченного меткой li, i = 2,3.",оператора,gramm,0
"знаки операций стоят таким образом, что знаку операции непосредственно предшествуют ее операнды.",знаку операции,gramm,0
"чтобы можно было ссылаться на элементы полиза, будем считать, что все они перенумерованы, начиная с 1 (допустим, занесены в последовательные элементы одномерного массива).",последовательные элементы одномерного массива,gramm,0
существует несколько способов построения промежуточной программы.,способов построения промежуточной программы,gramm,0
"в этом разделе мы рассмотрим некоторые методы, используемые для построения анализаторов (лексического, синтаксического и семантического), язык промежуточного представления программы, способ генерации промежуточной программы, ее интерпретации.",язык промежуточного представления программы,gramm,0
известно несколько различных способов описания языков [3].,способов,gramm,0
"замечание: может оказаться так, что знак бинарной операции по написанию совпадает со знаком унарной; например, знак ""-"" в большинстве языков программирования означает и бинарную операцию вычитания, и унарную операцию изменения знака.",унарной,gramm,0
"например, для грамматики g = ({a,b, }, {s,a,b,c}, p, s), где p: s c с ab ba a a ca b b cb анализатор будет таким: #include <stdio.h> int scan g(){ enum state {h, a, b, c, s, er}; / множество состояний / enum state cs; / cs - текущее состояние / file fp;/ указатель на файл, в котором находится анализируемая цепочка / int c; cs=h; fp = fopen (""data"",""r""); c = fgetc (fp); do {switch (cs) { case h: if (c == 'a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else cs = er; break; case a: if (c == 'b') {c = fgetc(fp); cs = c;} else cs = er; 27 break; case b: if (c == 'a') {c = fgetc(fp); cs = c;} else cs = er; break; case c: if (c =='a') {c = fgetc(fp); cs = a;} else if (c == 'b') {c = fgetc(fp); cs = b;} else if (c == ' ') cs = s; else cs = er; break; } } while (cs != s cs != er); if (cs == er) return -1; else return 0; } о недетерминированном разборе при анализе по регулярной грамматике может оказаться, что несколько нетерминалов имеют одинаковые правые части, и поэтому неясно, к какому из них делать свертку (см. ситуацию 4 в описании алгоритма).",нетерминалов,gramm,0
"определение: языком, порождаемым грамматикой g = (vt, vn, p, s), называется множество l(g) = { vt s }.",определение,gramm,0
аналогично можно описать способ генерации полиза других операторов модельного языка.,генерации полиза других,gramm,0
"определение: декартовым произведением a b множеств a и b называется множество { (a,b) a a, b b}.",b множеств a,gramm,0
"для этого нам потребуется следующая функция: void decid (int i, char t) - в i-той строке таблицы tid контролирует и заполняет поле declare и, если лексема (4,i) впервые встретилась в разделе описаний, заполняет поле type: void decid (int i, char t) {if (tid [i].declare) error(); / повторное описание / else {tid [i].declare = 1; / описан ! / strcpy (tid [i].type, t);} / тип t ! / } раздел описаний имеет вид d i {,i}: [int bool], т.е. имени типа (int или bool) предшествует список идентификаторов.",повторное описание,gramm,0
"замечание: если в этом алгоритме переставить шаги (1) и (2), то не всегда результатом будет приведенная грамматика.",приведенная грамматика,gramm,0
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",анализатор,gramm,0
"семантика условного оператора if e then s1 else s2 такова, что значения операндов для операций безусловного перехода и перехода ""по лжи"" в момент генерации операций еще неизвестны: if (!e) goto l2; s1; goto l3; l2: s2; l3:... поэтому придется запоминать номера элементов в массиве p, соответствующих этим операндам, а затем, когда станут известны их значения, заполнять пропущенное.",операций безусловного,gramm,0
"выбор определения не влияет на множество языков, порождаемых грамматиками этого класса, поскольку доказано, что множество языков, порождаемых праволинейными грамматиками, совпадает с множеством языков, порождаемых леволинейными грамматиками.",леволинейными грамматиками,gramm,0
"практически во всех трансляторах (и в компиляторах, и в интерпретаторах) в том или ином виде присутствует большая часть перечисленных ниже процессов: лексический анализ синтаксический анализ семантический анализ генерация внутреннего представления программы оптимизация генерация объектной программы.",программы оптимизация генерация,gramm,0
контроль контекстных условий в операторах s i := e if e then s else e while e do s b read (i) write (e) 1) оператор присваивания i := e контекстное условие: в операторе присваивания типы переменной i и выражения e должны совпадать.,контроль контекстных,gramm,0
номер в классе - это номер строки в таблице лексем соответствующего класса.,строки,gramm,0
"об используемых функциях: int id (void); - результат равен 1, если curr lex.class = 4, т.е. curr lex представляет идентификатор, и 0 - в противном случае; int num (void); - результат равен 1, если curr lex.class = 3, т.е. curr lex представляет число-константу, и 0 - в противном случае; int eq (char s); - результат равен 1, если curr lex представляет строку s, и 0 - иначе ; void error (void) - функция обработки ошибки; при обнаружении ошибки работа анализатора прекращается.",функция обработки ошибки,gramm,0
"(4) на некотором шаге работы алгоритма оказалось, что есть более одной подходящей свертки, т.е. в грамматике разные нетерминалы имеют правила вывода с одинаковыми правыми частями, и поэтому непонятно, к какому из них производить свертку.",правыми частями,gramm,0
"второй этап: по дс пишем программу 33 #include <stdio.h> #include <ctype.h> #define bufsize 80 extern ptabl tw, tid, td, tnum; char buf[bufsize]; / для накопления символов лексемы / int c; / очередной символ / int d; / для формирования числового значения константы / enum state {h, id, num, com, ass, dlm, er, fin}; enum state tc; / текущее состояние / file fp; void clear(void); / очистка буфера buf / void add(void); / добавление символа с в конец буфера buf / int look(ptabl); / поиск в таблице лексемы из buf; результат: номер строки таблицы либо 0 / int putl(ptabl); / запись в таблицу лексемы из buf, если ее там не было; результат: номер строки таблицы / int putnum(); / запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum / int j; / номер строки в таблице, где находится лексема, найденная функцией look / void makelex(int,int); / формирование и вывод внутреннего представления лексемы / void id or word(void) { if (j=look(tw)) makelex(1,j); else { j=putl(tid); makelex(4,j);} } void is dlm(void) {if(j=look(td)) {makelex(2,j); gc(); тс=h;} tc=er;} void gc(void) { c = fgetc(fp);} void scan (void) {tc = h; fp = fopen(""prog"",""r""); / в файле ""prog"" находится текст исходной программы / gc(); do {switch (tc) { case h: if (c == ' ') gc(); else if (isalpha(c)) {clear(); add();gc(); tc = id;} else if (isdigit (c)) {d = c - '0'; gc(); tc = num;} else if (c=='{') { gc(); tc = com;} else if (c == ':') { gc(); tc = ass;} else if (c == ' ') {makelex(2, n ); tc = fin;} else tc = dlm; break; case id: if (isalpha(c) isdigit(c)) {add(); gc();} else {id or word(); tc = h;} 34 break; case num: if (isdigit(c)) {d=d 10+(c - '0'); gc();} else {makelex (3, putnum()); tc = h;} break; / ........... / } / конец switch / } / конец тела цикла / while (tc != fin tc != er); if (tc == er) printf(""error !!!",программу,gramm,0
"в программе-интерпретаторе будем использовать некоторые переменные и функции, введенные нами ранее.",программе-интерпретаторе,gramm,0
"например, с помощью грамматики с действиями выполним перевод цепочек языка l1 = {0n1m n>=0, m>0} в соответствующие цепочки языка l2 = {ambn n>=0, m>0}: язык l1 можно описать грамматикой s 0s 1a a 1a вставим действия по переводу цепочек вида 0n1m в соответствующие цепочки вида ambn : s 0s <putchar('b')> 1 <putchar('a')> a a 1 <putchar('a')> a теперь при анализе цепочек языка l1 с помощью действий будут порождаться соответствующие цепочки языка l2.",действия,gramm,0
"значение каждого элемента таблицы - это нетерминальный символ, к которому можно свернуть пару ""нетерминал-терминал"", которыми помечены соответствующие строка и столбец.",соответствующие строка,gramm,0
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",переходов,gramm,0
для этого дополним грамматику вызовами соответствующих процедур генерации.,соответствующих процедур,gramm,0
"\n""); else printf(""o.k.!!!\n""); } синтаксический и семантический анализ на этапе синтаксического анализа нужно установить, имеет ли цепочка лексем структуру, заданную синтаксисом языка, и зафиксировать эту структуру.",синтаксисом языка,gramm,0
"например, пусть в грамматике есть правило a a<d1>b<d1;d2> bc<d3> , здесь a,b,c vn; a,b vt; <di> означает вызов семантической процедуры di, i = 1, 2, 3.",семантической процедуры,gramm,0
"для студентов факультета вмк в поддержку основного лекционного курса системное программное обеспечение и для преподавателей, ведущих практические занятия по этому курсу.",преподавателей,gramm,0
"за предоставленные материалы по курсу системное программное обеспечение , ценные советы и замечания при подготовке пособия, а также благодарят баландина к.а.",подготовке пособия,gramm,0
"таким образом, язык, порождаемый грамматикой, можно определить как множество терминальных сентенциальных форм.",множество,gramm,0
"f(a, t) = b означает, что из состояния a по входному символу t происходит переход в состояние b. определение: конечный автомат допускает цепочку a1a2...an, если f(h,a1) = a1; f(a1,a2) = a2; . . .",состояние,gramm,0
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",массиве,gramm,0
проиллюстрируем работу алгоритма на примере.,примере,gramm,0
"интерпретатор полиза для модельного языка польская инверсная запись была выбрана нами в качестве языка внутреннего представления программы, в частности, потому, что записанная таким образом программа может быть легко проинтерпретирована.",инверсная запись,gramm,0
"семантический анализатор для м-языка контекстные условия, выполнение которых нам надо контролировать в программах на м-языке, таковы: 1.",языка контекстные,gramm,0
"f(a,t) = {b1,b2,...,bn} означает, что из состояния a по входному символу t можно осуществить переход в любое из состояний bi, i = 1, 2, ... ,n. в этом случае можно предложить алгоритм, который будет перебирать все возможные варианты сверток (переходов) один за другим; если цепочка принадлежит языку, то будет найден путь, ведущий к успеху; если будут просмотрены все варианты, и 28 каждый из них будет завершаться неудачей, то цепочка языку не принадлежит.",возможные варианты,gramm,0
"грамматики этого класса, с одной стороны, позволяют достаточно полно описать синтаксическую структуру реальных языков программирования; с другой стороны, для разных подклассов укс-грамматик существуют достаточно эффективные алгоритмы разбора.",алгоритмы разбора,gramm,0
"определение: конечный автомат (ка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt k, определяющее поведение автомата; отображение f часто называют функцией переходов; h k - начальное состояние; 26 s k - заключительное состояние (либо конечное множество заключительных состояний).",функцией,gramm,0
"на этом этапе символы, составляющие исходную программу, группируются в отдельные лексические элементы, называемые лексемами.",этапе символы,gramm,0
"в этом разделе мы рассмотрим некоторые методы, используемые для построения анализаторов (лексического, синтаксического и семантического), язык промежуточного представления программы, способ генерации промежуточной программы, ее интерпретации.",представления программы,gramm,0
"если a 1a ... na 1 ... m b a и first(a) follow(a) (из-за вхождения а в правила вывода для в), то можно попытаться преобразовать такую грамматику: b a a 1a ... na 1 ... m a 1a ... na 1 ...",правила вывода,gramm,0
"- издание второе (переработанное и дополненное) издательский отдел факультета вмик мгу (лицензия лр no040777 от 23.07.96), 1998.-62 с. печатается по решению редакционно-издательского совета факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова 4 isbn 5-89407-032-5 издательский отдел факультета вычислительной математики и кибернетики мгу им. м.в.ломоносова, 1999 5 элементы теори и формальных языков и грамматик введение.",факультета вычислительной,gramm,0
"например, обычной (инфиксной) записи выражения a (b+c)-(d-e)/f соответствует такая постфиксная запись: abc+ de-f/- замечание: обратите внимание на то, что в полизе порядок операндов остался таким же, как и в инфиксной записи, учтено старшинство операций, а скобки исчезли.",полизе порядок операндов,gramm,0
"(4) на некотором шаге работы алгоритма оказалось, что есть несколько дуг, выходящих из текущего состояния, помеченных очередным анализируемым символом, но ведущих в разные состояния.",шаге работы алгоритма,gramm,0
"нужно отметить, что в языках программирования ограничителем подобных серий всегда является символ, отличный от разделителя, поэтому подобных проблем не возникает.",программирования ограничителем подобных серий,gramm,0
"примеры наиболее часто встречающихся контекстных условий: a) каждый используемый в программе идентификатор должен быть описан, но не более одного раза в одной зоне описания; b) при вызове функции число фактических параметров и их типы должны соответствовать числу и типам формальных параметров; c) обычно в языке накладываются ограничения на типы операндов любой операции, определенной в этом языке; на типы левой и правой частей в операторе присваивания; на тип 46 параметра цикла; на тип условия в операторах цикла и условном операторе и т.п. проверку контекстных условий часто называют семантическим анализом.",операторе,gramm,0
соотношения между типами грамматик: (1) любая регулярная грамматика является кс-грамматикой; (2) любая регулярная грамматика является укс-грамматикой; (3) любая кс- грамматика является укс-грамматикой; (4) любая кс-грамматика является кз-грамматикой; (5) любая кс-грамматика является неукорачивающей грамматикой; (6) любая кз-грамматика является грамматикой типа 0.,типами,gramm,0
"метод рекурсивного спуска пример: пусть дана грамматика g =({a,b,c, }, {s,a,b}, p, s), где p: s ab a a ca b ba и надо определить, принадлежит ли цепочка caba языку l(g).",спуска,gramm,0
"если подцепочку удалось найти, то работа процедуры считается нормально завершенной и осуществляется возврат в точку вызова.",процедуры,gramm,0
"определение: дерево называется деревом вывода (или деревом разбора) в кс-грамматике g = {vt, vn, p, s), если выполнены следующие условия: (1) каждая вершина дерева помечена символом из множества (vn vt ) , при этом корень дерева помечен символом s; листья - символами из (vt ); (2) если вершина дерева помечена символом a vn, а ее непосредственные потомки - символами a1, a2, ... , an, где каждое ai (vt vn), то a a1a2...an - правило вывода в этой грамматике; (3) если вершина дерева помечена символом a vn, а ее единственный непосредственный потомок помечен символом , то a - правило вывода в этой грамматике.",множества,gramm,0
"содержательный пример - генерация внутреннего представления программы для м-языка, приведен ниже, а здесь в качестве иллюстрации рассмотрим более простой пример.",простой пример,gramm,0
"в качестве примера приведем функцию для нетерминала d (раздел описаний): #include <string.h> #define maxsize tid 1000 #define maxsize td 50 char td[maxsize td]; struct record {char name; int declare; char type; / ... / }; struct record tid [maxsize tid]; / описание функций error(), getlex(), id(), eq(char ), типа struct lex и переменной curr lex - в алгоритме рекурсивного спуска для м-языка / void error(void); struct lex {int class; int value;}; struct lex curr lex; struct lex getlex (void); int id (void); int eq (char s); void ipush (int i); int ipop (void); void decid (int i, char t) {if (tid [i].declare) error(); else {tid [i].declare = 1; strcpy (tid [i].type, t);} } void dec (char t) {int i; while ((i = ipop()) !",примера,gramm,0
для описания синтаксиса языков программирования стараются использовать однозначные приведенные кс- грамматики.,описания синтаксиса,gramm,0
"существуют табличные методы анализа ([3]), применимые ко всему классу кс-грамматик и требующие для разбора цепочек длины n времени cn3 (алгоритм кока-янгера-касами) либо cn2 (алгоритм эрли).",кока-янгера-,gramm,0
"грамматика g = (vt, vn, p, s) называется контекстно- зависимой ( кз ), если каждое правило из p имеет вид , где = 1a 2; = 1 2; a vn; (vt vn)+; 1, 2 (vt vn) .",правило,gramm,0
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",определения,gramm,0
"m полученная грамматика будет эквивалентна исходной, т.к. из b по-прежнему выводятся цепочки вида { i} j либо { i} .",цепочки вида,gramm,0
основные понятия и определения определение: алфавит - это конечное множество символов.,алфавит - это конечное,gramm,0
"если ni ni-1, то i = i + 1 и переходим к шагу 2, иначе vn = ni; p состоит из правил множества p, содержащих только символы из vn vt; g = (vt, vn , p , s).",символы,gramm,0
аналогично можно описать способ генерации полиза других операторов модельного языка.,других операторов,gramm,0
"алгоритм построения детерминированного ка по нка вход: m = (k, vt, f, h, s) - недетерминированный конечный автомат.",построения детерминированного,gramm,0
алгоритм приведения грамматики: (1)обнаруживаются и удаляются все бесплодные нетерминалы.,алгоритм приведения грамматики,gramm,0
"f, r, w) относятся к классу ограничителей, как и все другие операции модельного языка; 2) для ссылок на номера элементов полиза введем лексемы класса 0, т.е. (0,p) - лексема, обозначающая p-ый элемент в полизе; 3) для того, чтобы различать операнды-значения-переменных и операнды-адреса-переменных (например, в полизе оператора присваивания), операнды-значения будем обозначать лексемами класса 4, а для операндов-адресов введем лексемы класса 5.",адреса,gramm,0
"выпишем условие, при котором -правило вывода делает неприменимым рс-метод.",неприменимым рс,gramm,0
"в грамматике модельного языка задано старшинство операций: наивысший приоритет имеет операция отрицания, затем в порядке убывания приоритета - группа операций умножения ( , /, and), группа операций сложения (+,-,or), операции отношения.",старшинство операций,gramm,0
"замечание: если при описании грамматики указаны только правила вывода р, то будем считать, что большие латинские буквы обозначают нетерминальные символы, s - цель грамматики, все остальные символы - терминальные.",латинские буквы,gramm,0
"результат: номер строки таблицы с информацией о лексеме; int putnum (); - запись в tnum константы из d, если ее там не было; результат: номер строки таблицы tnum с информацией о константе-лексеме; void makelex (int k, int i); - формирование и вывод внутреннего представления лексемы; k - номер класса, i - номер в классе; void gc (void) - функция, читающая из входного потока очередной символ исходной программы и заносящая его в переменную с; void id or word (void); - функция, определяющая является слово в буфере buf идентификатором или служебным словом и формирующая лексему соответствующего класса; void is dlm (void); - если символ в буфере buf является разделителем, то формирует соответствующую лексему, иначе производится переход в состояние er.",константе,gramm,0
"представление лексем: все лексемы м-языка разделим на несколько классов; классы перенумеруем: служебные слова - 1, ограничители - 2, константы (целые числа) - 3, идентификаторы - 4.",слова -,gramm,0
"определение: язык l(g) является языком типа k, если его можно описать грамматикой типа k. соотношения между типами языков: (1) каждый регулярный язык является кс-языком, но существуют кс-языки, которые не являются регулярными ( например, l = {anbn n>0}).",соотношения,gramm,0
"содержательный пример - генерация внутреннего представления программы для м-языка, приведен ниже, а здесь в качестве иллюстрации рассмотрим более простой пример.",представления программы,gramm,0
"eq ("":"")) error(); else {curr lex = getlex(); if (eq (""int"") eq (""bool"")) curr lex = getlex(); else error();} } } для e1 t {[ + - or ] t} void e1 (void){ t(); while (eq (""+"") eq (""-"") eq (""or"")) {curr lex = getlex(); t();} } для остальных нетерминалов грамматики модельного языка процедуры рекурсивного спуска пишутся аналогично.",нетерминалов грамматики модельного языка,gramm,0
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",представлении программы,gramm,0
"здесь не приводятся доказательства сформулированных фактов, свойств, теорем, доказательства правильности алгоритмов; их можно найти в книгах, указанных в списке литературы.",доказательства,gramm,0
"определение: вывод цепочки (vt) из s vn в кс- грамматике g = (vt, vn, p, s), называется правым (правосторонним), если в этом выводе каждая очередная сентенциальная форма получается из предыдущей заменой самого правого нетерминала.",грамматике g,gramm,0
"состояния и дуги дс - это графическое изображение функции переходов конечного автомата из состояния в состояние при условии, что очередной анализируемый символ совпадает с символом-меткой дуги.",изображение,gramm,0
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",дугу символом,gramm,0
"московский государственный университет им. м.в.ломоносова факультет вычислительной математики и кибернетики волкова и.а., руденко т.в.",вычислительной математики,gramm,0
"определение: язык l(g) является языком типа k, если его можно описать грамматикой типа k. соотношения между типами языков: (1) каждый регулярный язык является кс-языком, но существуют кс-языки, которые не являются регулярными ( например, l = {anbn n>0}).",языком типа,gramm,0
именно этот способ описания языков чаще всего будет использоваться нами в дальнейшем.,описания,gramm,0
"удаление символов сопровождается удалением правил вывода, содержащих эти символы.",удаление символов,gramm,0
"при работе этого алгоритма возможны следующие ситуации (аналогичные ситуациям, которые возникают при разборе непосредственно по регулярной грамматике): (1) прочитана вся цепочка; на каждом шаге находилась единственная дуга, помеченная очередным символом анализируемой цепочки; в результате последнего перехода оказались в состоянии s.",символом,gramm,0
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",контролю контекстных,gramm,0
"программа в таком виде в дальнейшем может либо транслироваться в объектный код, либо интерпретироваться.",объектный код,gramm,0
"- операция op заносится в полиз / else error(); } тогда грамматика, содержащая действия по контролю контекстных условий и переводу выражений модельного языка в полиз, будет такой: 62 e e1 e1 [ = > < ] < spush (td [curr lex.value] ) > e1< checkop p() > e1 t { [ + - or] < spush (td [curr lex.value] ) >t < checkop p() >} t f { [ / and] < spush (td [curr lex.value] ) >f < checkop p() >} f i < checkid(); put lex ( curr lex ) > n < spush(""int""); put lex (curr lex) > [ true false ] < spush (""bool""); put lex (curr lex) > not f < checknot(); put lex (make op (""not"")) > (e) действия, которыми нужно дополнить правило вывода оператора присваивания, также достаточно очевидны: s i < checkid(); put lex5 (curr lex) > := e < eqtype(); put lex (make op ("":="")) > при генерации полиза выражений и оператора присваивания элементы массива p заполнялись последовательно.",полиза выражений,gramm,0
"алгоритм построения детерминированного ка по нка вход: m = (k, vt, f, h, s) - недетерминированный конечный автомат.",нка вход,gramm,0
"например, для грамматики g = ({a,b}, {s,a}, p, s), где p: s baa a aa рс-анализатор, реализованный по обычной схеме, будет таким: void s(void) {if (c == b ) {c = fgetc(fp); a(); if (c != a ) error();} else error(); } void a(void) {if (c == a ) {c = fgetc(fp); a();} } тогда при анализе цепочки baaa функция a() будет вызвана три раза; она прочитает подцепочку ааа, хотя третий символ а - это часть подцепочки, выводимой из s. в результате окажется, что baaa не принадлежит языку, порождаемому грамматикой, хотя в действительности это не так.",подцепочку ааа,gramm,0
тогда полиз оператора цикла while будет таким: b p1 !f s p0 ! ...,полиз оператора,gramm,0
"соглашение 1) об используемых переменных и типах: пусть лексический анализатор выдает лексемы типа struct lex {int class; int value;}; при описанном выше характере взаимодействия лексического и синтаксического анализаторов естественно считать, что лексический анализатор - это функция getlex с прототипом struct lex getlex (void); в переменной struct lex curr lex будем хранить текущую лексему, выданную лексическим анализатором.",анализаторов,gramm,0
"соединяем эти состояния дугами по следующим правилам: a) для каждого правила грамматики вида w t соединяем дугой состояния h и w (от h к w) и помечаем дугу символом t; б) для каждого правила w vt соединяем дугой состояния v и w (от v к w) и помечаем дугу символом t; диаграмма состояний для грамматики g (см. пример выше): a a b b b a c s a b h алгоритм разбора по диаграмме состояний: 25 (1) объявляем текущим состояние h; (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: считываем очередной символ исходной цепочки и переходим из текущего состояния в другое состояние по дуге, помеченной этим символом.",алгоритм,gramm,0
основные понятия и определения определение: алфавит - это конечное множество символов.,определения определение,gramm,0
"(2) каждый кс-язык является кз-языком, но существуют кз- языки, которые не являются кс-языками ( например, l = {anbncn n>0}).",кс-языками,gramm,0
"лексический анализ важен для процесса компиляции по нескольким причинам: a) замена в программе идентификаторов, констант, ограничителей и служебных слов лексемами делает представление программы более удобным для дальнейшей обработки; b) лексический анализ уменьшает длину программы, устраняя из ее исходного представления несущественные пробелы и комментарии; c) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.",замена,gramm,0
"void interpreter(void) { int ip; int i, j, arg; for (i = 0; i<=n; i++) {curr lex = p[i]; switch (curr lex.class) { case 0: ipush (curr lex.value); break; / метку полиза - в стек / case 1: if (eq (""true"")) ipush (1); else ipush (0); break; / логическое значение - в стек / case 2: if (eq (""+"")) {ipush (ipop() + ipop()); break}; / выполнили операцию сложения, результат - в стек / if (eq (""-"")) {arg = ipop(); ipush (ipop() - arg); break;} / аналогично для других двухместных арифметических и логических операций / if (eq (""not"")) {ipush (!",результат - в стек,gramm,0
"(издание второе, переработанное и дополненное) 2 1999 3 удк 519.682.1+681.142.2 приводятся основные определения, понятия и алгоритмы теории формальных грамматик и языков, некоторые методы трансляции, а также наборы задач по каждой из рассматриваемых тем.",методы трансляции,gramm,0
"тогда оператор ввода read (i) в полизе будет записан как i r; оператор вывода write (e) - как e w. постфиксная польская запись операторов обладает всеми свойствами, характерными для постфиксной польской записи выражений, поэтому алгоритм интерпретации выражений пригоден для интерпретации всей программы, записанной на полизе (нужно только расширить набор операций; кроме того, выполнение некоторых из них не будет давать результата, записываемого в стек).",интерпретации,gramm,0
"- запись в таблицу т лексемы из буфера buf, если ее там не было;",лексемы,gramm,0
"чтобы отличать вызовы семантических процедур от других символов грамматики, будем заключать их в угловые скобки.",вызовы,gramm,0
"23 для грамматик этого типа существует алгоритм определения того, принадлежит ли анализируемая цепочка языку, порождаемому этой грамматикой (алгоритм разбора): (1) первый символ исходной цепочки a1a2...an заменяем нетерминалом a, для которого в грамматике есть правило вывода a a1 (другими словами, производим ""свертку"" терминала a1 к нетерминалу a) (2) затем многократно (до тех пор, пока не считаем признак конца цепочки) выполняем следующие шаги: полученный на предыдущем шаге нетерминал a и расположенный непосредственно справа от него очередной терминал ai исходной цепочки заменяем нетерминалом b, для которого в грамматике есть правило вывода b aai (i = 2, 3,.., n); это эквивалентно построению дерева разбора методом ""снизу-вверх"": на каждом шаге алгоритма строим один из уровней в дереве разбора, ""поднимаясь"" от листьев к корню.",символ исходной,gramm,0
"если для синтаксического анализа используется метод рекурсивного спуска, то в тела процедур рс-метода необходимо вставить вызовы дополнительных ""семантических"" процедур (семантические действия).",тела процедур,gramm,0
"правила вывода выражений модельного языка с действиями для контроля контекстных условий: e e1 e1 [ = < > ] < spush ( td [curr lex.value] ) > e1 <checkop() > e1 t { [ + - or ] < spush ( td [curr lex.value] ) > t < checkop() >} t f { [ / and ] < spush ( td [curr lex.value] ) > f < checkop() >} f i < checkid() > n < spush (""int"") > [ true false ] < spush (""bool"") > not f < checknot() > (e) замечание: td - это таблица ограничителей, к которым относятся и знаки операций; будем считать, что это массив #define maxsize td 50 char td[maxsize td]; именно из этой таблицы по номеру лексемы в классе выбираем обозначение операции в виде строки.",выражений модельного,gramm,0
"напомним, что грамматика g = (vt, vn, p, s) называется леволинейной, если каждое правило из р имеет вид a bt либо a t, где a vn, b vn, t vt.",грамматика g,gramm,0
"9 замечание: a) запись вида { } означает итерацию цепочки , т.е. в порождаемой цепочке в этом месте может находиться либо , либо , либо , либо и т.д. b) запись вида [ ] означает, что в порождаемой цепочке в этом месте может находиться либо , либо . c) p - цель грамматики; символ - маркер конца текста программы.",символ - маркер,gramm,0
"61 будем считать, что генерируемая программа размещается в массиве p, переменная free - номер первого свободного элемента в этом массиве: #define maxlen p 10000 struct lex {int class; int value;} struct lex p [ maxlen p]; int free = 0; для записи очередного элемента в массив p будем использовать функцию put lex: void put lex (struct lex l) {p[ free++] = l;} кроме того, введем модификацию этой функции - функцию put lex5, которая записывает лексему в полиз, изменяя ее класс с 4-го на 5-й (с сохранением значения поля value): void put lex5 (struct lex l) { l.class = 5; p[ free++] = l;} пусть есть функция struct lex make op(char op), которая по символьному изображению операции op находит в таблице ограничителей соответствующую строку и формирует лексему вида ( 2, i ), где i - номер найденной строки.",лексему вида,gramm,0
"последовательность применений правил вывода эквивалентна построению дерева разбора методом ""сверху вниз"": c a b a s c a b a a b s 39 c a b a a a b s c a b a a a b s c a b a a a a b s c a b a a a a b s метод рекурсивного спуска (рс-метод) реализует этот способ практически ""в лоб"": для каждого нетерминала грамматики создается своя процедура, носящая его имя; ее задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.",исходной цепочки,gramm,0
операторы ввода и вывода м-языка являются одноместными операциями.,операторы ввода,gramm,0
"отображение f определим как f ([a1a2...an], t) = [b1b2...bm], где для каждого 1 <= j <= m f(ai, t) = bj для каких-либо 1 <= i <= n. 3.",определим,gramm,0
определение: цепочкой символов в алфавите v называется любая конечная последовательность символов этого алфавита.,конечная последовательность символов,gramm,0
"для более удобной работы с диаграммами состояний введем несколько соглашений: a) если из одного состояния в другое выходит несколько дуг, помеченных разными символами, то будем изображать одну дугу, помеченную всеми этими символами; b) непомеченная дуга будет соответствовать переходу при любом символе, кроме тех, которыми помечены другие дуги, выходящие из этого состояния.",состояния,gramm,0
"определение: недетерминированный конечный автомат (нка) - это пятерка (k, vt, f, h, s), где k - конечное множество состояний; vt - конечное множество допустимых входных символов; f - отображение множества k vt в множество подмножеств k; h k - конечное множество начальных состояний; s k - конечное множество заключительных состояний.",множества,gramm,0
"12 в грамматике для одной и той же цепочки может быть несколько выводов, эквивалентных в том смысле, что в них в одних и тех же местах применяются одни и те же правила вывода, но в различном порядке.",местах,gramm,0
существует несколько способов построения промежуточной программы.,программы,gramm,0
"оператор присваивания i := e в полизе будет записан как i e := где "":="" - это двухместная операция, а i и е - ее операнды; i означает, что операндом операции "":="" является адрес переменной i, а не ее значение.",операнды,gramm,0
[among e] значением аргумента должен быть список.,значением аргумента,ai,0
"это приводит к так называемой альфа-бета процедуре поиска наилучшего первого хода от заданной позиции, в основе которой лежит достаточно очевидное сообра жение для сокращения поиска: если есть два варианта хода одного игрока, то худший в ряде случаев можно сразу отбросить, не выясняя, насколько в точности он хуже.",поиска наилучшего,ai,0
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",дерево,ai,0
"например, если для игры в восемь в качестве второй составляющей эвристической функции взять h(v)=2 s(v), то в ряде случаев такая функция будет убыстрять поиск и позволит решать более трудные задачи, но условие допустимости перестанет выполняться (так как для начального состояния на рис.15: h (v) 2 s(v) ).",задачи,ai,0
"сопоставление с образцом при обработке списков нередко приходится поверять, имеет ли некоторый список определенную структуру.",сопоставление,ai,0
"решающий граф это подграф и/или-графа, состоящий только из разрешимых вершин и доказывающий разрешимость начальной вершины.",разрешимость начальной,ai,0
[set v e] это аналог оператора присваивания.,оператора,ai,0
"таким образом, рассматриваемый алгоритм имеет ограниченную применимость, но иногда возникающие проблемы можно разрешить, построив более подходящую эвристическую функцию.",функцию,ai,0
"как и ранее, вспомогательные функции opening и is goal зависят от конкретной решаемой задачи: первая реализует раскрытие заданной вершины-аргумента и выдает как свое значение список дочерних вершин; вторая является предикатом, проверяющим, является ли исследуемая вершина-аргумент целевой.",функции,ai,0
"задача о коммивояжере: схема дорог между городами состояние решаемой задачи можно задать как список городов, которые коммивояжер уже посетил к текущему моменту.",городами,ai,0
"она имеет сходную с min max структуру: [define alpha beta (lambda (instate n) [select max [ab evalp .instate 0 t () () ]] )] аргументы этой функции: instate заданная позиция игры, для которой ищется лучший ход, n - глубина поиска.",поиска,ai,0
"(defun add state (op k1 k2) (push(list (gensym) (cons op (cond((< k1 k2) (exchange state '# (nth (sub1 k2) state))) (t (exchange state (nth (sub1 k2) state)'#))) )) dlist)) рекурсивная функция exchange, использованная в add state, формирует новое состояние игры путем перестановки заданных элементов исходного состояния-списка list.",состояния-,ai,0
"(defun limited depth search (startstate limdepth) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины; ) ;шаг 1: занесение начальной вершины (ее глубина равна 0):; ; в список нераскрытых вершин:; (setq open (list (list 's0 startstate 0))) ;шаг 2:; ls (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;определение глубины текущей вершины:; (setq depth (caddr current)) (cond ((is goal current) ;/шаг 6/; (return (solution current reflist)))) ;шаг 4:; (cond ((eql depth limdepth) (go ls))) ;шаг 5:раскрытие вершины, исключение повторных вершин и; ; модификация списков указателей и нераскрытых вершин:; (setq deslist (opening current)) (setq deslist (retain new deslist)) (cond ((null deslist) (go ls))) (setq open (append (add depth (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go ls) )) функция limited depth search применяет все описанные выше вспомогательные функции, а также описанную ниже функцию add depth, заносящую число dn (величину глубины) в описания всех дочерних состояний из списка dlist: (defun add depth (dn dlist) (cond ((null dlist) ()) (t (cons (list (caar dlist) (cadar dlist) dn) (add depth dn (cdr dlist))) ))) 2.4.2 поиск вглубь на плэнере для сравнения трудоемкости программирования поиска вглубь на языках лисп и плэнер приведем текст плэнерской функции deрth first search, выполняющей поиск вглубь от заданного состояния st, но без ограничения глубины (чтобы ограничить глубину, необходимо добавить в эту функцию дополнительный аргумент граничную глубину, и несколько простых действий).",аргумент,ai,0
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",стратегией поиска,ai,0
"дуги игрового дерева соответствуют ходам игроков, вершины конфигурациям игры, причем листья дерева это позиции, в которых игра завершается выигрышем, проигрышем или ничьей.",ходам игроков,ai,0
"(nth n l) значением аргумента n должно быть положительное целое число (обозначим его n), а значением аргумента l список.",n должно,ai,0
"если же решающего пути нет, то в случае конечного пространства состояний алгоритм завершит работу (с сообщением о неудаче поиска), в случае же бесконечного пространства алгоритм не остановится.",конечного пространства,ai,0
"иначе функция расщепляет список на две части на его первый элемент, который присваивается переменной 1, и на его хвост (т.е. без первого элемента), который становится новым значением переменной v2 ; в данном случае функция выдает результат ().",переменной,ai,0
"например, если переменная х имеет значение b, то: [is (a .x( y d) z) (a b (c d) e)] t и y:= c, z:= e, [is (a y d) (a b c d)] () и y не меняет значения.",значение b,ai,0
"например: (caddr l) (car(cdr(cdr l))) предполагается, что список-аргумент l у всех этих функций-суперпозиций, как и у ниже описываемой функции nth, содержит необходимое число элементов (в противном случае вычисление программы прерывается сообщением об ошибке).",случае вычисление программы,ai,0
"во-первых, когда список порожденных дочерних вершин оказался пуст, а во-вторых, когда уже перепробованы все установленные в развилке варианты (дочерние вершины) и все они оказались неуспешными.",развилке варианты,ai,0
"в терминах состояний и операторов решение задачи есть определенная последовательность операторов, преобразующая начальное состояние в целевое.",решение задачи,ai,0
% список возможных комбинаций из 3 точек-констант:; (points ((то (тб тя)) (тб (то тя)) (тя (то тб)))) ) [set state [1 .state]] % выделение самого состояния; % проверка условий применимости оператора схватить:; [cond ([is (тб я тб 0) .state] [set dlist (!,состояния,ai,0
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",одновременный просмотр списков,ai,0
"для этого используется несколько правил интегрирования, в том числе: правило интегрирования суммы функций, правило интегрирования по частям, правило вынесения постоянного множителя за знак интегрирования, а также применение алгебраических и тригонометрических подстановок и использование различных алгебраических и тригонометрических тождеств.",интегрирования суммы функций,ai,0
"основной операцией, выполняемой при поиске на графе, будем считать раскрытие вершины, что означает порождение (построение) всех ее дочерних вершин, путем применения к соответствующему описанию состояния задачи всех допустимых операторов.",описанию состояния задачи,ai,0
"вторая функция выполняет слияние двух упорядоченных (по невозрастанию эвристической оценки) списков состояний в результирующий упорядоченный список: (defun add depth est (dn slist) (cond ((null slist) ()) (t (cons (list (caar slist) (cadar slist) dn (est (list (cadar slist) dn)) ) (add depth est dn (cdr slist))) ) )) (defun merge (l1 l2) (cond ((null l1) l2) ((null l2) l1) ((> (car (cdddar l1)) (car(cdddar l2))) (cons (car l2) (merge l1 (cdr l2)))) (t (cons (car l1) (merge (cdr l1) l2))) )) 2.4.4 алгоритм подъема на холм на плэнере метод подъема на холм можно рассматривать как обобщение поиска в глубину, при котором на каждом шаге вглубь от некоторой вершины среди ее дочерних вершин для раскрытия выбирается наиболее перспективная вершина, т.е. с наименьшей оценкой (в классическом переборе в глубину этот выбор делается произвольно).",алгоритм подъема,ai,0
"в ходе дальнейшего построения дерева игры и получения новых оценок вершин предварительные оценки постепенно уточняются, опять же по минимаксному принципу.",оценок вершин предварительные оценки,ai,0
но в случае поиска на произвольном графе (и в этом отличие от деревьев-пространств) одно и тоже состояние может быть продублировано в разных частях построенного дерева поиска: граф как бы разворачивается в дерево путем дублирования некоторых его частей.,случае поиска,ai,0
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",пассивных позициях,ai,0
"значением этой функции является список всех состояний-вершин, лежащих на решающем пути от st до целевой вершины.",значением,ai,0
"эти составляющие задают неявно пространство задач, в котором требуется провести поиск решения задачи.",решения задачи,ai,0
"например, если для игры в восемь в качестве второй составляющей эвристической функции взять h(v)=2 s(v), то в ряде случаев такая функция будет убыстрять поиск и позволит решать более трудные задачи, но условие допустимости перестанет выполняться (так как для начального состояния на рис.15: h (v) 2 s(v) ).",условие допустимости,ai,0
"но если был обнаружен предикат pi, значение которого отлично от nil, тогда функция уже не будет рассматривать остальные предикаты, а последовательно вычислит все формы ei,j из соответствующего аргумента (ветви условного выражения) и со значением последней из них закончит свою работу.",значением,ai,0
"этот алгоритм при раскрытии каждой вершины производит упорядочение (по значению оценочной функции) порожденных дочерних вершин, и выбирает для последующего раскрытия дочернюю вершину с наименьшей оценкой, а не вершину с наименьшей оценкой среди всех нераскрытых вершин дерева поиска, как в базовом алгоритме эвристического поиска.",вершину,ai,0
"чтобы избежать такого дублирования вершин в случае перебора на графах общего вида, необходимо внести некоторые очевидные изменения в описанные базовые алгоритмы поиска вширь и вглубь.",дублирования вершин,ai,0
"как и при переборе в пространстве состояний, ограничение глубины может воспрепятствовать нахождению решения, но существующее в пределах ограничения решающее дерево будет найдено обязательно.",дерево,ai,0
"хвост этого непустого списка присваивается в качестве нового значения указанной переменной, а также выступает в качестве значения самой функции pop.",качестве значения самой функции,ai,0
"что касается формы описания задач/подзадач, то часто их удобно описывать в терминах пространства состояний, т.е. задавая начальное состояние и множество операторов, а также целевое состояние или его свойства.",операторов,ai,0
"причем, как побочный эффект сопоставления, данная последова тельность, заключенная в круглые скобки, становится новым значением переменной (правда, опять же только в случае общего соответствия списка е образцу pat).",данная последова тельность,ai,0
поэтому алгоритм подъема на холм легко программируется на основе встроенного механизма бектрекинга языка плэнер: [define climb on hill (lambda(st) [prog (dst %очередная раскрываемая вершина; reslist %список вершин решающего пути; ) [set dst .st] [set reslist (.st)] cs [set dst [among [q sort [opening .dst]]]] [cond ([memb .dst .reslist] [fail])] [set reslist (!.reslist,основе,ai,0
"решающий граф для изображения процесса редукции задач и получающихся при этом альтернативных множеств подзадач используются обычно графоподобные структуры, вершины которых представляют описания задач и подзадач, а каждая дуга связывает пару вершин, соответствующих редуцируемой задаче и одной из результирующих подзадач, причем стрелки на дугах указывают направление редукции.",изображения процесса,ai,0
"в принципе, эвристическая оценочная функция может зависеть не только от внутренних свойств оцениваемого состояния (т.е. свойств входящих в описание состояния элементов), но и от характеристик всего пространства состояний, например, от глубины местонахождения оцениваемой вершины в дереве перебора или других свойств пути к этой вершине.",дереве перебора,ai,0
"(eql e1 e2) в отличие от предыдущей функции, данная функция сравнивает значения своих аргументов, которыми могут быть не только атомы-идентификаторы, но и атомы-числа.",функции,ai,0
"(defun add state (op k1 k2) (push(list (gensym) (cons op (cond((< k1 k2) (exchange state '# (nth (sub1 k2) state))) (t (exchange state (nth (sub1 k2) state)'#))) )) dlist)) рекурсивная функция exchange, использованная в add state, формирует новое состояние игры путем перестановки заданных элементов исходного состояния-списка list.",новое состояние,ai,0
"отметим, что в отличие от базового алгоритма поиска вширь описываемая функция исключает повторно порожденные состояния (функция retain new), шаги 4 и 5 алгоритма объединены для упрощения программы.",поиска вширь,ai,0
"сначала рассмотрим эти алгоритмы для пространств, являющихся деревьями (корнем дерева является начальная вершина).",вершина,ai,0
пусть именами игроков будут плюс и минус.,именами,ai,0
"например, для шашек могут учитываться такие (статические) элементы конфигурации игры, как продвинутость и подвижность шашек, количество дамок, контроль ими центра и проч.",количество,ai,0
"заметим попутно, что, в отличие от такого неявного способа задания графа, при явном способе задания все вершины и дуги графа должны быть перечислены, например, с помощью таблиц.",дуги графа должны,ai,0
"редукция игровых задач последовательное применение к исходной конфигурации игры данной схемы редукции порождает и/или-дерево (и/или-граф), которое называют деревом (графом) игры.",конфигурации,ai,0
"один из способов повышения эффективности поиска связан с использованием информации, отражающей специфику решаемой задачи и позволяющей более целенаправленно двигаться к цели.",способов повышения,ai,0
"но если нашелся предикат pi, значение которого отлично от (), т.е. имеет значение истина , тогда функция уже не будет рассматривать остальные предикаты, а последовательно вычислит формы ei,j из этого i-го аргумента и со значением последней из них закончит свою работу.",истина,ai,0
"во-вторых, нужна таблица или процедура, связывающая ключевые операторы с возможными различиями (в gps использовалась таблица связей различие-оператор).",нужна таблица,ai,0
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",конечное число шагов,ai,0
"обычно эта задача решается путем последовательного преобразования интеграла к выражению, содержащему известные табличные интегралы.",выражению,ai,0
"вершины дерева соответствуют решаемым задачам/подзадачам, причем листья дерева соответствуют элементарным задачам перемещения дисков, а дуги связывают редуцируемую задачу с ее подзадачами.",задачам перемещения дисков,ai,0
"поэтому часто приходится использовать эвристические функции, сокращающие поиск во многих случаях, но не гарантирующие нахождение оптимального решающего пути.",нахождение оптимального,ai,0
основные виды перебора на и/или-графах различаются порядком раскрытия вершин.,перебора,ai,0
"эти составляющие задают неявно пространство задач, в котором требуется провести поиск решения задачи.",решения,ai,0
"и так до тех пор, пока в списке остаются нерассмотренные элементы.",нерассмотренные элементы,ai,0
"действительно, в первой и в третьей задачах требуется переместить всего два диска, вторая же задача может рассматриваться как элементарная, так как ее решение состоит ровно из одного хода перемещения диска 3 на колышек с. в первой и третьей задачах можно вновь применить метод редукции задач, и свести их к элементар ным задачам.",элементар ным,ai,0
"раскрыть вершину current, построив все ее дочерние вершины.",дочерние вершины,ai,0
"описываемые алгоритмы используют списки open и closed, состоящие соответственно из раскрытых и нераскрытых вершин пространства состояний.",нераскрытых вершин пространства,ai,0
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",оценки очередной,ai,0
"решение задачи ищется в пространстве состояний множестве всех состояний, достижимых из начального состояния при помощи заданных операторов.",начального состояния,ai,0
"к примеру, в задаче об обезьяне и банане различием можно считать неравенство соответствующих элементов списков, описывающих два состояния.",обезьяне,ai,0
"будем далее предполагать, что задачи и подзадачи решаются в пространстве состояний и записываются как (s i, o, sg), где s i и sg соответственно начальное и целевое состояния, причем множество o операторов преобразований состояний может быть опущено в случае его постоянности (неизменности).",o операторов,ai,0
"условия применимости и действие этих четырех операторов легко задать в виде правил продукций вида: аргумент оператора результат оператора, причем x, y, z, w, v это переменные: перейти (w) : (x, п, y, z ) (w, п, y, z) передвинуть (v) : (x, п, x, z) (v, п, v, z) взобраться : (x, п, x, z) (x, я, x, z) схватить : (тб, я, тб , 0) (тб, я, тб , 1) рис.",правил продукций,ai,0
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",случай построения дочерних вершин,ai,0
"таким образом, в подходе к решению задачи с использованием пространства состояний задача рассматривается как тройка (s i , o, sg) , где si начальное состояние; o конечное множество операторов, действующих на не более чем счетном множестве состояний; sg целевое состояние.",состояние,ai,0
для поиска указателя к очередной вершине решающего пути функция использует вспомогательную функцию look for .,функцию,ai,0
"в графе, показанном на рис.11, начальной является вершина p0, а заключительными вершины p1, p4, p5, p7 и p8 (они изображены жирными кружками).",вершины,ai,0
"из последнего неравенства следует, что условие допустимости достаточно доказать только для второй функции est2.",условие,ai,0
"тем не менее для неполных игр в шашки и шахматы (например, для эндшпилей), как и для всех несложных игр, таких как крестики-нолики на квадрате небольшого размера, можно успешно применять алгоритмы поиска на и/или-графах, позволяющие обнаруживать выигрышные и ничейные игровые стратегии.",игровые стратегии,ai,0
"в отличие от алгоритма поиска вширь, он осуществляет неполный поиск, поскольку целевая вершина может располагаться ниже граничной глубины (в таком случае она не будет обнаружена).",глубины,ai,0
"списки открытых и закрытых вершин содержат как вершины, так и их оценки, которые и используются для упорядочения поиска.",вершины,ai,0
"действительно, на каждом этапе редукции может оказаться несколько применимых операторов (т.е. способов сведения задачи к подзадачам) и, соответственно, несколько альтер нативных множеств подзадач.",сведения задачи,ai,0
"первая из этих функций была определена выше, она выбирает из своего аргумента-списка позицию с наибольшей оценкой.",аргумента-списка,ai,0
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",поиска последовательность шагов формулируемого,ai,0
"логические функции так называются функции, реализующие логические операции.",логические функции,ai,0
"значение оценочной функции est определяется как сумма числа фишек, стоящих не на своих местах, и длины пути (глубины) оцениваемого состояния-вершины в дереве поиска.",сумма числа фишек,ai,0
"у этой традиции, сложившейся почти за 30 лет существования теории эвристического поиска, существует важная причина.",лет существования,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",случае неуспешности выбранного,ai,0
"ясно, что описание решаемой задачи должно содержать описание конфигурации игры, для которой ищется нужная стратегия.",конфигурации игры,ai,0
"сформулируем теперь сам минимаксный принцип: или-вершине дерева игры приписывается оценка, равная максимуму оценок ее дочерних вершин; и-вершине игрового дерева приписывается оценка, равная минимуму оценок ее дочерних вершин.",равная максимуму,ai,0
"первая из этих функций была определена выше, она выбирает из своего аргумента-списка позицию с наибольшей оценкой.",аргумента-,ai,0
"ключевая идея этой эвристики такова: поиск различий между тем, что дано в поставленной задаче, и тем, что надо получить; последовательное устранение найденных различий с помощью подходящих средств операций.",помощью,ai,0
"описание каждого состояния задается списком, первый элемент которого это уникальный идентификатор состояния (число или атом), а второй элемент собственно описание состояния задачи.",уникальный идентификатор,ai,0
"[permex e f] функция осуществляет выход из ближайшей объемлющей функции с именем f и объявляет ее результатом значение аргумента e. при этом уничтожаются все развилки, появившиеся в программе с начала вычисления этой функции f, и замораживаются все изменения (в значениях переменных и т.п.), произведенные внутри этой функции.",результатом значение аргумента,ai,0
"префикс и целое число, от которого начинается нумерация генерируемых атомов, могут быть установлены заранее, как, например, в языке mulisp: (setq gensym-prefix 's) (setq gensym-count 2) после этого при последовательных обращениях к функции gensym она будет выдавать атомы s2, s3, s4 и т.д.",префикс,ai,0
"(defun solution (goal reflist) (prog (sollist ;список, в котором строится решение; gi edge) (setq gi (car goal)) s (cond((eq gi 's0) (return sollist))) (setq edge (look for gi reflist)) (setq sollist (cons (caddr edge) sollist)) (setq gi (car edge)) (go s) )) (defun look for (id list) (cond ((null list) (quote error)) ((eq id (cadar list)) (car list)) (t (look for id (cdr list))) )) в заключение приведем функцию, инициализирующую эвристический поиск решения игры в восемь: в самом его начале устанавливаются переменные-параметры встроенной функции gensym.",переменные-параметры,ai,0
"в первом случае местонахождение целевой вершины в пространстве состояний никак не влияет на порядок, в котором раскрываются (перебираются) вершины.",пространстве,ai,0
"однако подбор удачной эвристической функции, существенно сокращающей поиск, наиболее трудный момент при формализации задачи, часто подходящая оценочная функция выявляется только экспериментально.",подбор,ai,0
"сегментная форма вычисляется как обычная (простая) форма, но затем у ее значения, если это список, отбрасываются внешние скобки, и полученная таким образом последовательность элементов подставляется вместо сегментной формы.",внешние скобки,ai,0
"итак, для представления задачи в пространстве состояний необходимо определить следующее: форму описания состояний задачи и описание начального состояния; множество операторов и их воздействий на описания состояний; множество целевых состояний или же описание их свойств.",описание,ai,0
", а иначе функция выдает порядковый номер первого из элементов списка, равного значению e1.",значению,ai,0
"элементарные задачи интегрирования соответствуют табличным интегралам, например: отметим, что поскольку каждая из таких табличных формул содержит переменные, на самом деле она является схемой, задающей бесконечное множество элементарных задач.",элементарные задачи интегрирования,ai,0
"будем придерживаться общепринятого соглашения, по которому значение статической оценочной функции тем больше, чем больше преимуществ имеет игрок плюс (над игроком минус) в оцениваемой позиции.",значение,ai,0
"обе функции вырабатывают в качестве своего значения либо решающий путь (в виде лисповского списка) если таковой существует, и список () в противном случае.",списка,ai,0
"пусть целью поиска будет не просто нахождение решающего пути, а нахождение оптимального решающего пути решающего пути с минимальной стоимостью.",минимальной стоимостью,ai,0
"(defun limited depth search (startstate limdepth) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины; ) ;шаг 1: занесение начальной вершины (ее глубина равна 0):; ; в список нераскрытых вершин:; (setq open (list (list 's0 startstate 0))) ;шаг 2:; ls (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;определение глубины текущей вершины:; (setq depth (caddr current)) (cond ((is goal current) ;/шаг 6/; (return (solution current reflist)))) ;шаг 4:; (cond ((eql depth limdepth) (go ls))) ;шаг 5:раскрытие вершины, исключение повторных вершин и; ; модификация списков указателей и нераскрытых вершин:; (setq deslist (opening current)) (setq deslist (retain new deslist)) (cond ((null deslist) (go ls))) (setq open (append (add depth (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go ls) )) функция limited depth search применяет все описанные выше вспомогательные функции, а также описанную ниже функцию add depth, заносящую число dn (величину глубины) в описания всех дочерних состояний из списка dlist: (defun add depth (dn dlist) (cond ((null dlist) ()) (t (cons (list (caar dlist) (cadar dlist) dn) (add depth dn (cdr dlist))) ))) 2.4.2 поиск вглубь на плэнере для сравнения трудоемкости программирования поиска вглубь на языках лисп и плэнер приведем текст плэнерской функции deрth first search, выполняющей поиск вглубь от заданного состояния st, но без ограничения глубины (чтобы ограничить глубину, необходимо добавить в эту функцию дополнительный аргумент граничную глубину, и несколько простых действий).",программирования поиска,ai,0
поместить начальную вершину в список нераскрытых вершин open.,список,ai,0
"в общем случае граф поиска содержит разрешимые и неразрешимые вершины, а также вершины, относительно которых неизвестно разрешимы они или нет.",вершины,ai,0
"(cdr l) значением аргумента l должен быть непустой список, а значением функции является хвост этого списка, т.е. список, полученный отбрасыванием первого элемента.",значением функции,ai,0
"в алгоритме же перебора вглубь прежде всего раскрываются те вершины, которые были построены последними.",перебора,ai,0
"часто при поиске в пространстве состояний нетрудно обнаружить один оператор, который обязательно должен входить в решение задачи (по сути, применение этого оператора есть необходимый шаг решения этой задачи).",шаг решения,ai,0
"эта пред варительная оценка вершины w4 может быть уточнена в дальнейшем, но в соответствии с минимаксным принципом возможно только ее уменьшение, и это уменьшение не повлияет на оценку вершины w0+, поскольку последняя, опять же согласно минимаксному принципу, может только увеличиваться.",оценку,ai,0
в общем случае для полной редукции исходной задачи необходимо перепробовать несколько операторов.,задачи,ai,0
"при этом подходе производится анализ исходной задачи с целью выделения такого набора подзадач, решив которые, мы решим исходную задачу.",задачи,ai,0
"причем, как побочный эффект сопоставления, данная последова тельность, заключенная в круглые скобки, становится новым значением переменной (правда, опять же только в случае общего соответствия списка е образцу pat).",общего соответствия списка,ai,0
"в последнем случае, однако, дерево перебора может содержать дубликаты состояний и возможно зацикливание алгоритма.",возможно зацикливание,ai,0
"решающий граф для изображения процесса редукции задач и получающихся при этом альтернативных множеств подзадач используются обычно графоподобные структуры, вершины которых представляют описания задач и подзадач, а каждая дуга связывает пару вершин, соответствующих редуцируемой задаче и одной из результирующих подзадач, причем стрелки на дугах указывают направление редукции.",множеств подзадач,ai,0
"если для игры в пятнадцать средством формализации выступает язык программирования лисп или паскаль, то операторы задачи могут быть описаны в виде четырех соответствующих функций языка.",средством,ai,0
исходная позиция (корневая вершина дерева) имеет тип т и находится на глубине 0.,глубине,ai,0
"согласно этому методу, для того чтобы, в конечном счете, найти максимум функции, на каждом шаге метода производится движение в направлении наибольшей крутизны функции.",функции,ai,0
"на языке и/или-графов применение нескольких операторов редукции задачи будет означать, что сначала будет построена промежуточная и-вершина, а затем непосредственно следующие за ней или-вершины подзадач.",подзадач,ai,0
"если же решающего пути нет, то в случае конечного пространства состояний алгоритм завершит работу (с сообщением о неудаче поиска), в случае же бесконечного пространства алгоритм не остановится.",бесконечного пространства,ai,0
"эффективность алгоритмов поиска может быть оценена при помощи такого показателя, как целенаправленность.",целенаправленность,ai,0
"если же решающего пути нет, то в случае конечного пространства состояний алгоритм завершит работу (с сообщением о неудаче поиска), в случае же бесконечного пространства алгоритм не остановится.",случае конечного пространства состояний,ai,0
"однако, если присваивание, осуществленное функцией set, отменяется при неуспехе, то действие функции pset при неуспехе не будет отменено.",функции,ai,0
однако ситуация изменится при существенном увеличении размеров квадрата или же в случае неограниченного поля игры.,увеличении,ai,0
"в алгоритме перебора вширь вершины раскрываются в том порядке, в котором они строятся.",порядке,ai,0
"в подобных случаях свойство, которому должно удовлетворять целевое состояние, должно быть описано исчерпывающим образом, к примеру, путем задания булевской функции, реализующей проверку нужного свойства состояния задачи.",нужного свойства состояния задачи,ai,0
"к их числу, прежде всего, относится идея выделения так называемых ключевых операторов и различий состояний.",различий состояний,ai,0
"заметим, что от выбора формы описания состояния зависит в общем случае сложность задания операторов задачи, которые должны быть также определены при формализации задачи в пространстве состояний.",пространстве,ai,0
"отметим, что за исключением последних форм в каждой ветви (они используются для вычисления значения условного выражения), в качестве форм ei,j имеет смысл использовать только такие, которые имеют при вычислении побочный эффект, например, присваивание переменной значения и т.п. другие специальные функции (quote e) или 'e это функция блокировки вычислений: она выдает в качестве значения свой аргумент, не вычисляя его.",функция блокировки,ai,0
"функции is goal и opening можно определить так: (defun is goal (state) (eq (car(last state) 'a))) (defun opening (state) (prog (dlist ;список формируемых дочерних состояний; townl townn; последний и следующий город маршрута; new roads ; списки дорог между городами; ) (setq roads '((a b)(a d)(a e)(a g)(b d)(b c)(c d)(c h) (d e)(d h)(e g)(h g)(e h))) ; расширение списка путей(дорог) между городами: (setq roads (add ways roads)) ; последний город маршрута: (setq townl (car(last state))) ; цикл поиска соседних с городом townl городов, в которые ; может вести маршрут: opc (setq new (find townl roads)) (cond ((null new) (return dlist))) (setq townn (car new)) (setq roads (cadr new)) (cond ((or (and (eq townn 'a)(eql (length state)7)) (not (member townn state)) ) (setq dlist (cons(append state(list townn)) dlist)))) (go opc) )) так как наличие дороги (пути) между городами x и y означает также наличие пути между y и x, то первоначальный список дорог между городами должен быть расширен симметричными связями-путями это выполняет вспомогательная функция add ways: (defun add ways (rlist) (cond ((null rlist) ()) (t (cons (car rlist) (cons (list (cadar rlist) (caar rlist)) (add ways(cdr rlist))) )))) вспомогательная функция find выполняет поиск города-соседа для заданного города town: (defun find (town roads) (cond ((null roads) ()) ((eq town (caar roads)) (list (cadar roads)(cdr roads)) ) (t (find town (cdr roads))) )) приведем теперь для сравнения реализацию функций is goal и opening на языке плэнер для их применения в функции depth first search поиска вглубь.",расширение списка путей(дорог,ai,0
"действительно, в первой и в третьей задачах требуется переместить всего два диска, вторая же задача может рассматриваться как элементарная, так как ее решение состоит ровно из одного хода перемещения диска 3 на колышек с. в первой и третьей задачах можно вновь применить метод редукции задач, и свести их к элементар ным задачам.",элементар,ai,0
в этом случае к таким позициям необходимо сразу применить статическую оценочную функцию.,позициям,ai,0
"для иллюстрации этого подхода рассмотрим один из вариантов известной головоломки задачи о ханойской башне, или пирамидке.",головоломки,ai,0
"поиск вглубь для игры в восемь 2.2.3 слепой перебор и бектрекинг если продолжить выполнение алгоритмов перебора вширь и вглубь для рассмотренного на рис.13 и 14 начального состояния игры в восемь, с целью поиска конфигурации, заданной на рис.1(б), то она будет найдена на глубине 5, при этом алгоритмом поиска вширь будет раскрыто 26 и построено 46 вершин, а алгоритмом поиска вглубь соответственно 18 и 35 вершин (см. [нильсон73, раздел 3.2] или [нильсон85, раздел 2.4]).",конфигурации,ai,0
% расширение списка путей (дорог) между городами:; [set roads [add ways .roads]] % последний город маршрута:; [set town [-1 .state]] % цикл поиска следующего города маршрута:; opc [cond ([not [is (! x (.town z) ! y) .roads]] [return .dlist] )] [cond ([or [and [eq .z a] [eq [length .state] 7]] [not [memb .z .state]] ] [set dlist ((!.state .z) !,города,ai,0
"более безопасным является поиск вглубь с ограничением глубины, при котором незаключительные вершины с глубиной, равной граничной, просто считаются неразрешимыми.",граничной,ai,0
"если в процессе поиска удалось показать, что начальная вершина разрешима, то это значит, что обнаружено решение исходной задачи, которое заключено в так называемом решающем графе.",решение,ai,0
".dlist)] )] [set .roads .y] [go opc] ]] [define add ways (rlist) [prog (r x y) [cond ([fin r rlist] ()) ([is ( x y) .r] (.r (.y .x) <add ways .rlist>) )] ]] 2.5.2 задача об обезьяне (плэнер) в задаче об обезьяне и банане пространство состояний невелико, и хотя оно содержит много циклов, может быть использован поиск вглубь без ограничения глубины, осуществляемый функцией depth first search.",пространство,ai,0
"бывают и другие случаи бесперспективности подъема на холм : если поверхность-множество значений функции имеет равнинный участок (как горное плато) или же участки узкого и длинного возвышения (в виде горного хребта), и процесс поиска вывел как раз на них.",значений,ai,0
"второе же слагаемое h(v) может быть предложено исходя из эвристических соображений, свойственных конкретной решаемой задаче, как некоторая характеристика-оценка текущей вершины v (близости ее к цели).",задаче,ai,0
"если это так, то такую вершину не надо снова помещать в список open (таким образом, разрывается цикл графа-пространства и обрывается соответствующая ветвь дерева перебора).",вершину,ai,0
важной особенностью большинства этих алгоритмов является исполь зование эвристической информации.,большинства,ai,0
"в таких случаях, как и во всех сложных играх, вместо нереальной задачи поиска полной игровой стратегии решается, как правило, более простая задача поиск для заданной позиции игры достаточно хорошего первого хода.",задача поиск,ai,0
"на рис.17 показан полный граф игры для задачи v(7+), жирными дугами на нем выделен решающий и/или-граф, который доказывает, что второй игрок (т.е. игрок минус, начинающий вторым), всегда может выиграть.",дугами,ai,0
дальнейшая формализация решения задачи с использованием пространства состояний предполагает выбор некоторой конкретной формы описания состояний задачи.,формы описания состояний задачи,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",альтернативы,ai,0
"обычно эта задача решается путем последовательного преобразования интеграла к выражению, содержащему известные табличные интегралы.",интегралы,ai,0
2.2.2 поиск вглубь для формулировки алгоритма поиска вглубь необходимо определить понятие глубины вершины в дереве поиска.,формулировки,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",случае неуспешности,ai,0
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",функцией,ai,0
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",дочерние вершины текущей позиции,ai,0
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",аргумент-список,ai,0
"отметим, что плэнерская функция fail, инициирующая автоматический процесс возврата, в рассмотренной функции deрth first search применя ется только для предотвращения зацикливания, когда порожденная дочерняя вершина уже содержится в списке reslist.",функции,ai,0
"иначе функция расщепляет список на две части на его первый элемент, который присваивается переменной 1, и на его хвост (т.е. без первого элемента), который становится новым значением переменной v2 ; в данном случае функция выдает результат ().",значением,ai,0
"основу этого алгоритма составляет цикл последовательного раскрытия (шаги 2-5) концевых вершин (листьев) дерева перебора, хранящихся в списке open.",основу,ai,0
"два основных подвида слепого поиска, различающиеся порядком раскрытия вершин, это поиск вширь и поиск вглубь.",основных подвида,ai,0
"при этом в плэнере ложью считается пустой список (), а истиной любое другое выражение (чаще всего в роли истины выступает атом t).",выражение,ai,0
"(heuristic search initstate) )) 2.6 поиск на и/или-графах 2.6.1 особенности поиска и/или-граф, называемый также графом целей (задач), неявно задается при формализации задачи с использованием метода редукции, путем описания исходной задачи, операторов сведения задачи к подзадачам и множества элементарных задач.",использованием метода,ai,0
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",частный случай,ai,0
"заметим, что от выбора формы описания состояния зависит в общем случае сложность задания операторов задачи, которые должны быть также определены при формализации задачи в пространстве состояний.",задачи,ai,0
"как и ранее, вершины, непосредственно следующие за некоторой вершиной, т.е. получившиеся в результате применения к ней допустимых операторов, будем называть дочерними, а саму исходную вершину родительской.",применения,ai,0
при максимальном числе отсечений строится и оценивается мини мальное число концевых вершин.,максимальном числе отсечений,ai,0
методы поиска реше ний: пер. с англ.,методы поиска реше ний,ai,0
"идея этого алгоритма аналогична идее известного вне области искусственного интеллекта метода подъема на гору , применяемого для поиска максимума (или минимума) функции.",подъема,ai,0
в этом случае к таким позициям необходимо сразу применить статическую оценочную функцию.,случае,ai,0
арифметические функции [+ n1 n2 ... nk] (k 2) значениями аргументов должны быть числа.,функции,ai,0
"решение задачи ищется в пространстве состояний множестве всех состояний, достижимых из начального состояния при помощи заданных операторов.",помощи,ai,0
"значением функции alpha beta является дочерняя для instate вершина-позиция, соответст вующая наилучшему ходу.",позиция,ai,0
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",основе,ai,0
"исходя из оценки первой дочерней вершины начальная вершина w0+, соответст вующая исходной позиции игры, к этому моменту уже предварительно оценена величиной 3.",дочерней вершины,ai,0
"2.5.3 игра в восемь (лисп) граф-пространство состояний для головоломки-игры в восемь достаточно велик (в игре в пятнадцать фишек он на порядок больше), поэтому хотя в принципе применимы алгоритмы слепого поиска, предпочтителен все же эвристический поиск.",состояний,ai,0
"1.1.2 примеры пространств состояний разберем два характерных примера представления задач в пространстве состояний, показывающих, что такое представление возможно для различных типов задач.",примеры пространств,ai,0
"вычисление функции начинается с того, что вводятся локальные переменные vi, перечисленные в ее первом аргументе, и всем им в качестве начального значения присваивается пустой список nil.",аргументе,ai,0
"вырабатываемое функцией значение это дочерняя для instate позиция, соответствующая искомому наилучшему ходу.",наилучшему ходу,ai,0
"(defun add state (op k1 k2) (push(list (gensym) (cons op (cond((< k1 k2) (exchange state '# (nth (sub1 k2) state))) (t (exchange state (nth (sub1 k2) state)'#))) )) dlist)) рекурсивная функция exchange, использованная в add state, формирует новое состояние игры путем перестановки заданных элементов исходного состояния-списка list.",исходного состояния,ai,0
"задача о коммивояжере: часть пространства состояний обратимся теперь к известной задаче об обезьяне и банане, простейшую формулировку которой мы и рассмотрим.",обезьяне,ai,0
"если бы фишки не мешали друг другу и могли двигаться до своего места по кратчайшему пути, как если бы других фишек на квадрате не было, то сумма длин таких путей для всех фишек была бы в точности равна значению s(v) .",точности равна,ai,0
"будем использовать следующие обозначения: xs или ys некоторая конфигурация игры, причем индекс s принимает значения + или , указывая, кому принадлежит следующий ход (т.е. в конфигурации x+ следующий ход должен делать игрок плюс, а в x игрок минус); w(xs) задача доказательства того, что игрок плюс может выиграть, исходя из конфигурации xs; v(xs) задача доказательства того, что игрок минус может выиграть, отправляясь от конфигурации xs.",игрок минус,ai,0
функция производит сравнение двух произвольных s-выражений значений своих аргументов.,значений,ai,0
"поэтому в случае программирования этой задачи на языке лисп можно упростить соответствующие лисп-функции слепого поиска, например, breadth first search, обойдясь без указателей и идентификаторов вершин, а также без функций solution, connect и retain new.",поиска,ai,0
различия должны быть упорядочены по степени их значимости для решения исходной задачи.,задачи,ai,0
"особенностью языка лисп является то, что ложью считается пустой список, записываемый как () или nil, а истиной произвольное выражение, отличное от () и nil.",особенностью,ai,0
"если очередная построенная вершина соответствует целевому состоянию, то процесс поиска завершается.",поиска,ai,0
"для определенного класса функций (имеющих единственный максимум и некоторые другие свойства роста) такое использование локальной информации, т.е. знания направления наиболее крутого подъема в текущей точке, позволяет найти глобальное решение, т.е. максимум функции.",единственный максимум,ai,0
"это приводит к так называемой альфа-бета процедуре поиска наилучшего первого хода от заданной позиции, в основе которой лежит достаточно очевидное сообра жение для сокращения поиска: если есть два варианта хода одного игрока, то худший в ряде случаев можно сразу отбросить, не выясняя, насколько в точности он хуже.",процедуре поиска,ai,0
"предполагается, что в каждом списке-описании состояния, кроме идентификатора состояния и собственно описания состояния задачи, содержится также третий элемент глубина этого состояния-вершины в дереве поиска.",вершины,ai,0
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",алгоритм,ai,0
"алгоритм поиска вглубь демонстрирует также способ решения поисковых задач, называемый бектрекингом (backtracking).",алгоритм,ai,0
% список возможных комбинаций из 3 точек-констант:; (points ((то (тб тя)) (тб (то тя)) (тя (то тб)))) ) [set state [1 .state]] % выделение самого состояния; % проверка условий применимости оператора схватить:; [cond ([is (тб я тб 0) .state] [set dlist (!,условий,ai,0
"сначала рассмотрим эти алгоритмы для пространств, являющихся деревьями (корнем дерева является начальная вершина).",начальная вершина,ai,0
"однако подбор удачной эвристической функции, существенно сокращающей поиск, наиболее трудный момент при формализации задачи, часто подходящая оценочная функция выявляется только экспериментально.",функция,ai,0
[max n1 n2 ... nk] (k 2) значениями аргументов должны быть числа.,аргументов,ai,0
"тем самым в дереве перебора нет дублирования одного и того же состояния в вершинах, имеющих общую соседнюю вершину.",состояния,ai,0
"в соответствии с предположениями, сделанными в предыдущем разделе, состояние задачи (конфигурация игры) представляется списком из следующих элементов: идентификатор состояния (используются атомы s1,s2,s3, ... генерируемые встроенной лисповской функцией gensym); собственно описание состояния список из номеров фишек, записанных последовательно по рядам квадрата; число-глубина состояния-вершины в дереве перебора; числовая эвристическая оценка состояния.",число-глубина состояния,ai,0
"система gps начинала с попытки обработки более серьезных и трудно устранимых различий, переходя затем к более легким.",попытки,ai,0
"что же касается альфа-бета процедуры, то программа на лиспе [уинстон, глава 13] существенно более громоздка и трудна для понимания, чем приведенная выше плэнер-функция, поскольку в последней применяется встроенный механизм возвратов.",встроенный механизм,ai,0
"аналогично представлению в пространстве состояний, формализация задачи в рамках подхода, основанного на редукции задач, включает определение следующих составляющих: формы описания задач/подзадач и описание исходной задачи; множества операторов и их воздействий на описания задач; множества элементарных задач.",формализация,ai,0
"алгоритмы же упорядоченного перебора с применением эвристик не настолько уменьшают просматриваемую часть дерева игры, чтобы дать существенное, на несколько порядков, сокращение времени поиска.",просматриваемую часть,ai,0
"например, если переменная x имеет значение (a b), то (.x c [1 .x]) ((a b) c a) в таких списках можно использовать и сегментные формы, к которым относятся сегментные обращения к переменным (с префиксом ""!."", например: !.x) и сегментные обращения к функциям (в угловых скобках, например: <elem 5 .x>).",сегментные обращения,ai,0
"найденный путь не обязательно оптимален (возможно, существует более дешевый, еще не найденный путь из начальной вершины в v), однако стоимость найденного пути может быть использована в качестве оценки искомого пути минимальной стоимости из начальной вершины до v, т.е. в качестве первого слагаемого g(v) эвристической функции.",вершины,ai,0
"исходя из оценки первой дочерней вершины начальная вершина w0+, соответст вующая исходной позиции игры, к этому моменту уже предварительно оценена величиной 3.",оценки первой,ai,0
"к ним относятся: атомы (значение атома - сам атом), обращения к переменным с префиксом ""."" (значением является текущее значение переменной), списки в круглых скобках (значением является список из значений элементов исходного списка) и обращения к функциям, имеющие вид [f a1 a2 ... an], где f - имя функции, а ai - ее аргументы.",скобках,ai,0
"задача о ханойской башне эта задача легко может быть формализована в пространстве состояний: состояние задачи задается списком из трех элементов, каждый из которых указывает местоположение соответствующего диска (первый элемент первого диска, второй второго, третий третьего).",пространстве,ai,0
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",функции,ai,0
"рассмотрим, к примеру, игру крестики-нолики на квадрате 3 3.",игру крестики,ai,0
"в соответствии с предположениями, сделанными в предыдущем разделе, состояние задачи (конфигурация игры) представляется списком из следующих элементов: идентификатор состояния (используются атомы s1,s2,s3, ... генерируемые встроенной лисповской функцией gensym); собственно описание состояния список из номеров фишек, записанных последовательно по рядам квадрата; число-глубина состояния-вершины в дереве перебора; числовая эвристическая оценка состояния.",следующих элементов,ai,0
"пример такой структуры приведен на рис.10(а): задача g может быть решена путем решения либо задач d1 и d2, либо e1, e2 и e3 либо задачи f. при этом ребра, относящиеся к одному и тому же множеству подзадач, связываются специальной дугой.",подзадач,ai,0
этот идентификатор получается склеиванием специального префикса и очередного номера (целого числа).,целого числа,ai,0
"3.4 плэнер-алгоритмы поиска на игровых деревьях рассмотрим сначала описание на языке плэнер функции min max, реализующей минимаксную процедуру.",языке плэнер,ai,0
"неразрешимость вершины (и соответствующей задачи) дерева поиска может быть определена рекурсивным образом аналогично определению разрешимой вершины, данному в первой главе пособия: вершина, не являющаяся заключительной и не имеющая дочерних вершин, неразрешима; или-вершина неразрешима тогда и только тогда, когда неразрешимы все ее дочерние вершины; и-вершина неразрешима тогда и только тогда, неразрешима хотя бы одна из ее дочерних вершин.",неразрешимость,ai,0
"таким образом, в подходе к решению задачи с использованием пространства состояний задача рассматривается как тройка (s i , o, sg) , где si начальное состояние; o конечное множество операторов, действующих на не более чем счетном множестве состояний; sg целевое состояние.",o конечное множество операторов,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",варианта,ai,0
"к примеру, такими вехами являются состояния (ввa) и (ввc) задачи о пирамидке, изображенные на рис.8.",примеру,ai,0
"кроме того, само найденное целевое состояние может считаться решением, поскольку представляет список городов, входящих в искомый маршрут.",список городов,ai,0
[define is goal(state) [prog (x y z) [is ( x y z 1) [1 .state]] ]] [define opening (state) [prog(x y z (dlist ()) % список дочерних вершин; pc % точка текущего положения обезьяны; p1 p2 % две другие точки-константы пола;,другие точки-константы,ai,0
"действительно, минимаксные оценки основаны на просмотре игры вперед и учитывают разные особенности, которые могут возникнуть в последующем, в то время как простое применение оценочной функции учитывает лишь свойства позиции как таковой.",свойства,ai,0
"тогда исходную задачу можно свести к трем подзадачам: первая задача (s i, sop) состоит в поиске пути от начального состояния исходной задачи к одному из состояний, к которому применим ключевой оператор op; вторая задача является элементарной, она заключается в применении этого ключевого оператора; третья задача (op(s), sg) состоит в поиске пути от состояния, полученного применением ключевого оператора, к целевому состоянию исходной задачи.",применении,ai,0
"причем согласно минимаксному принципу оценка может только увеличиться (поскольку подсчитывается как максимум оценок дочерних вершин), но даже если она увеличится, это не повлияет на оценку вершины w1 , поскольку последняя при уточнении по минимаксному принци пу может только уменьшаться (так как равна минимуму оценок дочерних вершин).",минимаксному принци,ai,0
"интуитивно ясно, и это можно показать на примерах, что новая эвристическая функция имеет большую эвристическую силу, т.е. более эффективно направляет поиск к цели.",функция,ai,0
"(defun heuristic search(startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины;) ;шаг 1:; (setq open (list(list 's0 startstate 0 (est (list startstate 0)) ))) ;шаг 2:; hs (cond ((null open) (return()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) (setq depth (caddr current)) ;шаг 4:; (cond ((is goal current) (return (solution current reflist)))) ;шаг 5:; (setq deslist (opening current)) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go нs))) ;шаг 6:; (setq open (merge (add depth est (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go hs) )) данная лисповская функция использует (как и ранее рассмотренные функции breadth first search и limited depth search) вспомогательные функции opening, solution, is goal, connect, est (которые зависят от конкретной поисковой задачи) и ранее определенную функцию retain new, а также еще две вспомогательные функции add depth est и merge.",список дочерних,ai,0
"действительно, отправляясь от начальной ситуации, можно построить конфигурации, возникающие в результате выполнения возможных в этой ситуации ходов, затем построить множество конфигураций, получающихся после применения следующего хода, и так далее пока не будет достигнута целевая конфигурация.",результате выполнения,ai,0
"вначале функция выдает как свое значение первый элемент списка и завершает на этом работу, после чего программа продолжает свои вычисления.",программа,ai,0
"заметим, что эвристическая сила функции должна учитывать общий объем вычислительных затрат при поиске, поэтому кроме числа раскрытых и построенных вершин важен и такой показатель, как сложность вычисления самой оценочной функции.",эвристическая сила функции должна,ai,0
"если список glist не пуст, то перейти на шаг 3, в ином случае закончить текущую процедуру, выдав в качестве результата сформированный решающий граф для задачи-цели goal .",процедуру,ai,0
"другим важным понятием является понятие оператора, т.е. допустимого хода в задаче.",понятием,ai,0
"решающий граф для одной задачи интегрирования подход, основанный на редукции задач, применим и имеет преимущества по сравнению с подходом, использующим представление в пространстве состояний, когда получающиеся при редукции подзадачи можно решать независимо друг от друга, как в примере с интегрированием.",пространстве,ai,0
"функция return может использоваться только внутри функции prog, поскольку она завершает вычисление ближайшей объемлющей блочной функции, объявляя ее значением значение аргумента e. [go e] это оператор перехода.",значением,ai,0
"для проведения отсечений функция использует вспомогательные величины amax и bmin, являющиеся соответственно максимальной из альфа-величин и минимальной из бета-величин вершин, предшествующих оцениваемой вершине pos.",отсечений функция,ai,0
"в алгоритме подъема на холм , применяемом для поиска в пространстве состояний, роль функции метода подъема на гору играет эвристическая оценочная функция, взятая с обратным знаком.",алгоритме,ai,0
"значение функции длина этого списка, т.е. число элементов на верхнем уровне списка.",верхнем уровне списка,ai,0
"встроенный механизм возвратов языка плэнер совсем не облегчает программирование других разновидностей поиска перебора вширь и эвристического поиска, и оно выполняется обычно без использования этого механизма, т.е. почти так же, как и в языках программирования без встроенного бектрекинга.",поиска перебора,ai,0
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",закрытия,ai,0
"значением функции ab evalp (как и mm evalp) является либо вычисленная оценка позиции pos (при depth>0), либо список дочерних для pos позиций с их числовыми оценками (при depth=0).",вычисленная оценка позиции,ai,0
"при этом предполагается, что если на одном колышке находится более одного диска, то любой больший диск расположен ниже любого меньшего.",больший диск расположен ниже,ai,0
"некоторые листья являются заключительными вершинами, соответствующими элементарным задачам позициям, выигрышным для игрока плюс.",заключительными вершинами,ai,0
"в задаче об обезьяне и банане приоритет (значимость) различий можно установить, например, следующим образом: различие в четвертом, затем во втором, затем в третьем и первом элементах описания состояния задачи.",первом элементах,ai,0
"заметим попутно, что, в отличие от такого неявного способа задания графа, при явном способе задания все вершины и дуги графа должны быть перечислены, например, с помощью таблиц.",явном способе,ai,0
"рядом с этими вершинами находятся их минимаксные оценки, полученные при движении в обратном (по отношению к построению дерева) направлении.",оценки,ai,0
"алгоритмы поиска формулируются проще для и/или-графов, являющихся деревьями: при этом организация перебора значительно упрощается, поскольку любая задача (цель) может встретиться в таком графе-дереве ровно один раз.",графов,ai,0
принципы искусственного интеллекта: пер. с англ.,интеллекта,ai,0
в задаче об обезьяне естественно связать различия и операторы-кандидаты в ключевые следующим образом: различие в первом элементе списка-описания состояния (положение обезьяны в плоскости пола) операторы перейти и передвинуть.,следующим образом,ai,0
"представленная в решающем графе выигрышная стратегия может быть сформулирована словесно так: если в очередном ходе игрок плюс берет одну монету, то в следующем ходе минус должен взять две, а если плюс берет две монеты, то минус должен забрать одну.",графе выигрышная,ai,0
"основной операцией, выполняемой при поиске на графе, будем считать раскрытие вершины, что означает порождение (построение) всех ее дочерних вершин, путем применения к соответствующему описанию состояния задачи всех допустимых операторов.",поиске,ai,0
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",оценок вершин дерева,ai,0
"задача о коммивояжере: часть пространства состояний обратимся теперь к известной задаче об обезьяне и банане, простейшую формулировку которой мы и рассмотрим.",состояний,ai,0
"эти листья оценены статической функцией, и вершина w2+ получила точную минимаксную оценку 3, а вершина w1 предварительную оценку 3.",статической функцией,ai,0
"представленная в решающем графе выигрышная стратегия может быть сформулирована словесно так: если в очередном ходе игрок плюс берет одну монету, то в следующем ходе минус должен взять две, а если плюс берет две монеты, то минус должен забрать одну.",монеты,ai,0
важной особенностью большинства этих алгоритмов является исполь зование эвристической информации.,особенностью большинства,ai,0
"дуги игрового дерева соответствуют ходам игроков, вершины конфигурациям игры, причем листья дерева это позиции, в которых игра завершается выигрышем, проигрышем или ничьей.",дуги игрового,ai,0
"решающий граф это подграф и/или-графа, состоящий только из разрешимых вершин и доказывающий разрешимость начальной вершины.",вершины,ai,0
"исключение составляет случай, когда множество задач состоит только из одного элемента, в этом случае будет образована ровно одна вершина, будем для определенности считать ее или-вершиной.",случае,ai,0
"раскрыть вершину current, образовав все ее дочерние вершины.",дочерние вершины,ai,0
"вершины и указатели, построенные в процессе поиска, образуют поддерево всего неявно определенного при формализации задачи графа-пространства состояний.",состояний,ai,0
"в общем случае, эта оценка может быть получена при наличии оценки хотя бы одной дочерней вершины.",оценки,ai,0
в общем случае для полной редукции исходной задачи необходимо перепробовать несколько операторов.,общем случае,ai,0
"функция проверяет, совпадает ли какой-нибудь элемент (верхнего уровня) этого списка со значением аргумента e1.",значением аргумента,ai,0
"формируемая при поиске структура из вершин и указателей называется графом поиска, по окончании поиска в нем содержится решающий граф.",графом,ai,0
"сопоставление с образцом при обработке списков нередко приходится поверять, имеет ли некоторый список определенную структуру.",обработке списков,ai,0
"важно, что рассмотренные правила работают в ходе построения игрового дерева вглубь; это означает, что предварительные оценки промежу точных вершин появляются лишь по мере продвижения от концевых вершин дерева вверх к корню и реально отсечения могут начаться только после того, как получена хотя бы одна точная минимаксная оценка промежуточной вершины.",предварительные оценки промежу точных,ai,0
"аналогично представлению в пространстве состояний, формализация задачи в рамках подхода, основанного на редукции задач, включает определение следующих составляющих: формы описания задач/подзадач и описание исходной задачи; множества операторов и их воздействий на описания задач; множества элементарных задач.",операторов,ai,0
"определение новых функций для этого служит встроенная функция defun, к которой возможно любое из следующих обращений: (defun f (lambda(v1 v2 ... vn) e)) (n 0) (defun f (v1 v2 ... vn) e) значением этой функциональной формы является имя определяемой функции, т.е. f. побочным же эффектом вычисления этой формы будет опре деление новой лисповской функции с именем f, аргументами (формальными параметрами) vi и телом e - формой, зависящей от vi.",встроенная функция,ai,0
"игровое дерево, построенное минимаксной процедурой в принципе статическую оценочную функцию можно было бы применить и к промежуточным вершинам, и на основе этих оценок осуществить выбор наилучшего первого хода, например, сразу выбрать ход, максимизирующий значение статической оценочной функции среди вершин, дочерних к исходной.",оценок,ai,0
реализация этого алгоритма на языке плэнер приводится в следующем разделе настоящей главы.,разделе,ai,0
"наибольшее число отсечений достигается, когда при переборе в глубину первой обнаруживается конечная вершина, статическая оценка которой станет в последствии минимаксной оценкой начальной вершины.",минимаксной оценкой начальной вершины,ai,0
но в случае поиска на произвольном графе (и в этом отличие от деревьев-пространств) одно и тоже состояние может быть продублировано в разных частях построенного дерева поиска: граф как бы разворачивается в дерево путем дублирования некоторых его частей.,деревьев-,ai,0
"задача о ханойской башне эта задача легко может быть формализована в пространстве состояний: состояние задачи задается списком из трех элементов, каждый из которых указывает местоположение соответствующего диска (первый элемент первого диска, второй второго, третий третьего).",первый элемент,ai,0
"цель поиска на и/или-графе показать, что разрешима исходная задача, т.е. начальная вершина.",цель поиска,ai,0
.dst)] [cond ([is goal .dst] [return .reslist]) (t [go cs])] ])] эта функция является усложнением ранее рассмотренной плэнерской функции depth first search (добавлено обращение к функции q sort).,усложнением,ai,0
"это преобразование включает в себя, вообще говоря, проведение указателей от дочерних вершин к их родительским эти указатели необходимы для определения разрешимых и неразрешимых вершин и решающего графа (последний состоит только из разрешимых вершин).",проведение,ai,0
ключевой оператор может быть использован для следующего способа сведения исходной задачи к подзадачам.,способа сведения исходной,ai,0
"в терминах состояний и операторов решение задачи есть определенная последовательность операторов, преобразующая начальное состояние в целевое.",операторов решение задачи,ai,0
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",оценками,ai,0
"действительно, на каждом этапе редукции может оказаться несколько применимых операторов (т.е. способов сведения задачи к подзадачам) и, соответственно, несколько альтер нативных множеств подзадач.",операторов,ai,0
"на каждом этапе работы система определяла различие между текущим состоянием (объектом) задачи и целевым состоянием (объектом), а затем выбирала и пыталась применить оператор для уменьшения найденного различия.",система,ai,0
"статическая оценочная функция, будучи применена к некоторой вершине-конфигурации игры, дает числовое значение, оценивающее различные достоинства этой игровой позиции.",числовое значение,ai,0
"(last l) значением функции является список из одного элемента последнего элемента верхнего уровня списка-аргумента l. например, если переменная x имеет своим значением список (p(q r)), а переменная y список (t), то значение формы (cons x y) равно ((p(q r))t), значение формы (list x y) равно ((p(q r))(t)), значение формы (append x y) равно (p(q r) t); значение формы (last x) равно ((q r)).",уровня списка-аргумента,ai,0
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",пор задача,ai,0
"если они равны (т.е. представляют собой одно и то же s-выражение), то значение функции равно t, иначе nil.",значение функции равно,ai,0
"пример такой структуры приведен на рис.10(а): задача g может быть решена путем решения либо задач d1 и d2, либо e1, e2 и e3 либо задачи f. при этом ребра, относящиеся к одному и тому же множеству подзадач, связываются специальной дугой.",специальной дугой,ai,0
"очень часто оценочная функция выбирается следующим образом: статическая оценочная функция положительна в игровых конфигурациях, где игрок плюс имеет преимущества; статическая оценочная функция отрицательна в конфигурациях, где минус имеет преимущества; статическая оценочная функция близка к нулю в позициях, не дающих преимущества ни одному из игроков.",игровых конфигурациях,ai,0
"условия применимости и действие этих четырех операторов легко задать в виде правил продукций вида: аргумент оператора результат оператора, причем x, y, z, w, v это переменные: перейти (w) : (x, п, y, z ) (w, п, y, z) передвинуть (v) : (x, п, x, z) (v, п, v, z) взобраться : (x, п, x, z) (x, я, x, z) схватить : (тб, я, тб , 0) (тб, я, тб , 1) рис.",аргумент,ai,0
"если выбрать такую форму описания в задаче о пирамидке, то элементарная задача перекладывания самого большого диска с колышка а на с записывалась бы как (вва) (ввс), а исходная задача как (ааа) (ссс).",элементарная задача перекладывания,ai,0
"в графе-пространстве состояний этому оператору обычно соответствует дуга, связывающая две практически отдельные части графа.",отдельные части,ai,0
"у этой традиции, сложившейся почти за 30 лет существования теории эвристического поиска, существует важная причина.",существования теории,ai,0
"язык плэнер учитывает эту потребность и предлагает для такой проверки механизм сопоставления с образцом, который реализует встроенная функция is: [is pat e] здесь pat это образец, который задает требуемую структуру списка, а значение аргумента e тот список (обозначим его e), который проверяется на соответствие данному образцу.",требуемую структуру,ai,0
"по сути, статическая функция вычисляет эвристическую оценку шансов на выигрыш одного из игроков.",статическая функция,ai,0
"логические функции так называются три функции, реализующие основные логические операции.",операции,ai,0
"что же касается альфа-бета процедуры, то программа на лиспе [уинстон, глава 13] существенно более громоздка и трудна для понимания, чем приведенная выше плэнер-функция, поскольку в последней применяется встроенный механизм возвратов.",громоздка,ai,0
"этот граф является деревом действительно, при применении любого оператора список уже посещенных городов может только удлиниться, поэтому в процессе построения новых вершин не может возникнуть вершина, встречавшаяся прежде.",процессе построения новых,ai,0
"именно с этим связана одна из слабостей применяемого в системе gps подхода: процедуры вычисления различий и уменьшающих их операторов должны быть отдельно реализованы для каждой конкретной задачи (или для очень узкой предметной области, включающей несколько видов задач), в противном случае снижалась эффективность решения задач.",процедуры вычисления,ai,0
для обоих подходов описываются используемые алгоритмы поиска решения.,поиска решения,ai,0
"(defun limited depth search (startstate limdepth) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины; ) ;шаг 1: занесение начальной вершины (ее глубина равна 0):; ; в список нераскрытых вершин:; (setq open (list (list 's0 startstate 0))) ;шаг 2:; ls (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;определение глубины текущей вершины:; (setq depth (caddr current)) (cond ((is goal current) ;/шаг 6/; (return (solution current reflist)))) ;шаг 4:; (cond ((eql depth limdepth) (go ls))) ;шаг 5:раскрытие вершины, исключение повторных вершин и; ; модификация списков указателей и нераскрытых вершин:; (setq deslist (opening current)) (setq deslist (retain new deslist)) (cond ((null deslist) (go ls))) (setq open (append (add depth (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go ls) )) функция limited depth search применяет все описанные выше вспомогательные функции, а также описанную ниже функцию add depth, заносящую число dn (величину глубины) в описания всех дочерних состояний из списка dlist: (defun add depth (dn dlist) (cond ((null dlist) ()) (t (cons (list (caar dlist) (cadar dlist) dn) (add depth dn (cdr dlist))) ))) 2.4.2 поиск вглубь на плэнере для сравнения трудоемкости программирования поиска вглубь на языках лисп и плэнер приведем текст плэнерской функции deрth first search, выполняющей поиск вглубь от заданного состояния st, но без ограничения глубины (чтобы ограничить глубину, необходимо добавить в эту функцию дополнительный аргумент граничную глубину, и несколько простых действий).",глубину,ai,0
однако ситуация изменится при существенном увеличении размеров квадрата или же в случае неограниченного поля игры.,случае неограниченного,ai,0
конец алгоритма.,алгоритма,ai,0
"если есть хотя бы одна целевая вершина, то завершить поиск и выдать решение задачи, получающееся просмотром указателей назад от найденной целевой вершины к начальной.",решение задачи,ai,0
"предполагается, что в каждом списке-описании состояния, кроме идентификатора состояния и собственно описания состояния задачи, содержится также третий элемент глубина этого состояния-вершины в дереве поиска.",третий элемент,ai,0
поэтому алгоритм подъема на холм легко программируется на основе встроенного механизма бектрекинга языка плэнер: [define climb on hill (lambda(st) [prog (dst %очередная раскрываемая вершина; reslist %список вершин решающего пути; ) [set dst .st] [set reslist (.st)] cs [set dst [among [q sort [opening .dst]]]] [cond ([memb .dst .reslist] [fail])] [set reslist (!.reslist,список вершин,ai,0
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",алгоритмах,ai,0
"иными словами, для ао -алгоритма верна аналогичная теорема о допустимости, гарантирующая нахождение решения с минимальной стоимостью (так называемого оптимального дерева) при условии, что дерево решения существует.",допустимости,ai,0
"заметим, что часть получаемых таким образом операторов редукции (как, например, операторы, соответствующие правилу интегрирования по частям или правилу интегрирования суммы функций), действительно редуцируют исходную задачу и порождают и-вершину в и/или-графе, в то время как алгебраические и тригонометрические подстановки и тождества (как, например, деление числителя на знаменатель или дополнение до полного квадрата) лишь заменяют одно подынтегральное выражение на другое, порождая, таким образом, или-вершины.",правилу интегрирования,ai,0
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",проверка,ai,0
"2.5.3 игра в восемь (лисп) граф-пространство состояний для головоломки-игры в восемь достаточно велик (в игре в пятнадцать фишек он на порядок больше), поэтому хотя в принципе применимы алгоритмы слепого поиска, предпочтителен все же эвристический поиск.",алгоритмы,ai,0
"действительно, отправляясь от начальной ситуации, можно построить конфигурации, возникающие в результате выполнения возможных в этой ситуации ходов, затем построить множество конфигураций, получающихся после применения следующего хода, и так далее пока не будет достигнута целевая конфигурация.",конфигураций,ai,0
(= n1 n2) (/= n1 n2) (> n1 n2) (>= n1 n2) (< n1 n2) (<= n1 n2) значениями аргументов этих функций должны быть числа.,аргументов,ai,0
"(push е v) в качестве второго аргумента этой функции (он не вычисляется) должно быть задано имя переменной, в качестве первого произвольная форма.",качестве второго,ai,0
в соответствии с первой характеристикой различают слепой и эвристический поиск.,характеристикой,ai,0
"в то же время алгоритм поиска вглубь может оказаться предпочтительнее в тех случаях, когда он начат с ветви дерева, содержащей целевое состояние, решение задачи будет обнаружено раньше, чем при поиске вширь.",время алгоритм поиска,ai,0
"наибольшее число отсечений достигается, когда при переборе в глубину первой обнаруживается конечная вершина, статическая оценка которой станет в последствии минимаксной оценкой начальной вершины.",вершины,ai,0
"алгоритмы же упорядоченного перебора с применением эвристик не настолько уменьшают просматриваемую часть дерева игры, чтобы дать существенное, на несколько порядков, сокращение времени поиска.",поиска,ai,0
"если требуется вычислить список в круглых скобках (e1 e2 ... en) (n 0) т.е. если он рассматривается как форма, то все его элементы должны быть формами.",круглых скобках,ai,0
"важно, что алгоритм подъема на холм дает тот же результат, что и базовый алгоритм эвристического поиска в тех случаях, когда оценочная функция обладает определенными свойствами, в частности, имеет один (глобальный) экстремум.",базовый алгоритм,ai,0
"описанные ниже лисп-функции для игры в восемь могут быть пригодны и для игры в пятнадцать, так как размер стороны игрового квадрата, равный 3, используется в них как глобальная переменная size.",стороны,ai,0
"отметим, что в плэнере идентификатор nil не имеет никакого отношения к пустому списку.",идентификатор,ai,0
рассмотренные рекурсивные процедуры могут быть легко детализированы для получения либо простого поиска вглубь (при произвольном выборе вершины на шаге 3 or-процедуры) или получения алгоритма подъема на холм (если список glist упорядочен по неубыванию эвристической оценочной функции и на шаге 3 or-процедуры выбирается вершина с наименьшей оценкой).,вершины,ai,0
"решение задачи в пространстве состояний подразумевает просмотр неявно заданного графа, для чего необходимо преобразование в явную форму достаточно большой его части, включающей искомую целевую вершину.",задачи,ai,0
"в частности, в роли истины может использоваться атом t. (null e) эта функция проверяет, является ли значение ее аргумента пустым списком; если да, то значение функции равно t, иначе nil.",значение,ai,0
"каждая из выделенных подзадач в общем случае является более простой, чем исходная, и может быть решена каким-либо методом, в том числе с использованием пространства состояний.",состояний,ai,0
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",оператора,ai,0
"[permex e f] функция осуществляет выход из ближайшей объемлющей функции с именем f и объявляет ее результатом значение аргумента e. при этом уничтожаются все развилки, появившиеся в программе с начала вычисления этой функции f, и замораживаются все изменения (в значениях переменных и т.п.), произведенные внутри этой функции.",именем,ai,0
"показано [нильсон73, раздел 3.9], что если эти функции статичны (т.е. не изменяются в процессе поиска), то более информированный алгоритм раскрывает всегда меньшее число вершин, прежде чем находит путь минимальной стоимости.",стоимости,ai,0
"(cdr l) значением аргумента l должен быть непустой список, а значением функции является хвост этого списка, т.е. список, полученный отбрасыванием первого элемента.",отбрасыванием первого,ai,0
"после прерывания перебора предварительные оценки вершин в точках отсечения остаются неуточненными, но, как уже отмечалось, это не препятствует правильному нахождению предварительных оценок всех предшествующих вершин, как и точной оценки корневой вершины и ее дочерних вершин, а значит, и искомого наилучшего первого хода.",прерывания перебора предварительные оценки,ai,0
это можно сделать следующим образом: глубина корня дерева равна нулю; глубина каждой некорневой вершины на единицу больше глубины ее родительской вершины.,вершины,ai,0
"кроме того, в ходе поиска целесообразно тем или иным способом сохранять подграфы, являющиеся кандидатами на решающий граф задачи по окончании поиска один из них станет решением задачи.",задачи,ai,0
"каждая из них получает на вход вершину goal соответствующего типа и список ее дочерних вершин glist, результат процедуры либо решающее дерево с корнем в вершине goal, либо сообщение о неуспехе (неразрешимости этой вершины).",вход вершину,ai,0
"(push е v) в качестве второго аргумента этой функции (он не вычисляется) должно быть задано имя переменной, в качестве первого произвольная форма.",качестве первого,ai,0
эта функция определяется на множестве вершин пространства состояний и принимает числовые значения.,значения,ai,0
"3.2 минимаксная процедура с целью поиска достаточно хорошего первого хода просматривается обычно часть игрового дерева, построенного от заданной конфигурации.",часть игрового,ai,0
"оценим размер полного дерева игры: начальная вершина имеет 9 дочерних вершин, каждая из которых в свою очередь имеет 8 дочерних; каждая вершина глубины 2 имеет 7 дочерних и т.д.",глубины,ai,0
"пространство состояний в задаче о ханойской башне это решение можно обнаружить перебором всех возможных перемещений дисков, но метод редукции задач позволяет решить рассматриваемую задачу быстрее.",состояний,ai,0
"для игры крестики-нолики на фиксированном квадрате возможна такая статиче ская оценочная функция: + , если p есть позиция выигрыша игрока плюс e(p) = , если p есть позиция выигрыша игрока минус (nl+ +nc+ +nd+ ) (nl +nc +nd ) в остальных случаях где: + очень большое положительное число; очень маленькое отрицательное число; nl+, nc+, nd+ соответственно число строк, столбцов и диагоналей, открытых для игрока плюс (т.е. где он еще может поставить три выигрышных крестика подряд); nl , nc , nd аналогичные числа для игрока минус.",игры крестики,ai,0
"из последнего неравенства следует, что условие допустимости достаточно доказать только для второй функции est2.",второй функции,ai,0
[return e] это оператор досрочного выхода из блока.,выхода,ai,0
"для проведения отсечений функция использует вспомогательные величины amax и bmin, являющиеся соответственно максимальной из альфа-величин и минимальной из бета-величин вершин, предшествующих оцениваемой вершине pos.",вершине,ai,0
"стоимость пути от начальной вершины до вершины v в дереве перебора, а h(v) эвристическая оценка оптимального пути из вершины v в целевую вершину, является допустимым, если h(v) h (v) для всех вершин v пространства состояний.",оценка оптимального,ai,0
"тогда решением задачи будет путь в этом графе, ведущий от начального состояния к целевому.",решением,ai,0
"в заключение отметим, что статическая оценочная функция и альфа-бета процедура две непременные составляющие почти всех компьютерных игро вых программ (в том числе коммерческих).",игро вых,ai,0
"глубина вершин в формируемом алгоритмами и/или-дереве перебора может быть определена точно так же, как в случае деревьев перебора в пространстве состояний.",формируемом алгоритмами,ai,0
"этот способ предлагает опреде ленную организацию перебора всех возможных вариантов решения задачи, число которых может быть велико.",возможных вариантов,ai,0
"число фишек позиции-вершины v, стоящих не на своем месте (фишка стоит не на своем месте, если ее позиция отлична от позиции в целевом состоянии).",позиции-,ai,0
"1.2.3 пример: задача символьного интегрирования в качестве примера применения метода редукции рассмотрим решение задачи символьного интегрирования, т.е. нахождения неопределенного интеграла .",решение задачи символьного,ai,0
"на каждом этапе работы система определяла различие между текущим состоянием (объектом) задачи и целевым состоянием (объектом), а затем выбирала и пыталась применить оператор для уменьшения найденного различия.",задачи,ai,0
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",отсечение неперспективных,ai,0
"таким образом, в подходе к решению задачи с использованием пространства состояний задача рассматривается как тройка (s i , o, sg) , где si начальное состояние; o конечное множество операторов, действующих на не более чем счетном множестве состояний; sg целевое состояние.",решению задачи,ai,0
две следующие процедуры похожи друг на друга.,процедуры похожи,ai,0
"некоторые выражения можно вычислять, получая в результате значения (ими являются выражения); такие выражения называются формами.",результате значения,ai,0
"(not e) эта функция реализует логическое отрицание и является, по сути, дубликатом функции null: если значение аргумента равно nil ( ложь ), то функция выдает результат t ( истина ), а при любом другом значении аргумента в качестве результата выдается nil.",другом значении аргумента,ai,0
"встроенный механизм возвратов языка плэнер совсем не облегчает программирование других разновидностей поиска перебора вширь и эвристического поиска, и оно выполняется обычно без использования этого механизма, т.е. почти так же, как и в языках программирования без встроенного бектрекинга.",языках программирования,ai,0
"такое небольшое по размерам пространство состояний получено, в частности, вследствие того, что игнорировались все точки пола, кроме трех, соответствующих первоначальному расположению обезьяны, ящика и бананов.",расположению обезьяны,ai,0
"показано [нильсон73, раздел 5.14], что в случае, когда самые сильные ходы рассматриваются первыми, количество концевых вершин глубины n, которые будут построены и оценены альфа-бета процедурой, примерно равно числу концевых вершин, которые были бы построены и оценены на глубине n/2 обычной минимаксной процедурой.",концевых вершин глубины n,ai,0
"в соответствии с предположениями, сделанными в предыдущем разделе, состояние задачи (конфигурация игры) представляется списком из следующих элементов: идентификатор состояния (используются атомы s1,s2,s3, ... генерируемые встроенной лисповской функцией gensym); собственно описание состояния список из номеров фишек, записанных последовательно по рядам квадрата; число-глубина состояния-вершины в дереве перебора; числовая эвристическая оценка состояния.",глубина состояния,ai,0
"в заключение отметим, что статическая оценочная функция и альфа-бета процедура две непременные составляющие почти всех компьютерных игро вых программ (в том числе коммерческих).",функция,ai,0
"зафиксируем также три следующие значимые точки в плоскости пола: то точка первоначального местоположения обезьяны; тя точка первоначального расположения ящика; тб точка пола, расположенная непосредственно под связкой бананов.",точка первоначального местоположения обезьяны,ai,0
"однако этот случай соответствует полному отсутствию какой-нибудь эвристической информации о задаче, и оценочная функция est не имеет никакой эвристической силы, т.е. не сокращает возникающий перебор.",случай,ai,0
"предположим, что на множестве дуг пространства состояний определена функция стоимости: с(va, vb) стоимость дуги-перехода от вершины va к вершине vb .",дуг пространства состояний,ai,0
поместить начальную вершину в список нераскрытых вершин open и вычислить ее оценку.,вершин,ai,0
"если глубина вершины current равна граничной глубине d, то перейти к шагу 2, в ином случае перейти к следующему шагу.",глубина вершины,ai,0
"в подобных случаях свойство, которому должно удовлетворять целевое состояние, должно быть описано исчерпывающим образом, к примеру, путем задания булевской функции, реализующей проверку нужного свойства состояния задачи.",случаях свойство,ai,0
"проиллюстрируем работу алгоритма эвристического поиска опять же на примере игры в восемь (для той же начальной ситуации, что на рис.",алгоритма эвристического,ai,0
"показано [нильсон73, раздел 3.9], что если эти функции статичны (т.е. не изменяются в процессе поиска), то более информированный алгоритм раскрывает всегда меньшее число вершин, прежде чем находит путь минимальной стоимости.",функции статичны,ai,0
"если аргументы равны, то значение функции равно t, иначе nil.",функции равно,ai,0
вычисленное значение формы становится значением функции f. операции над списками (car l) значением аргумента l должен быть непустой список; значением же функции является первый элемент верхнего уровня этого списка.,вычисленное значение,ai,0
"работая в соответствии с этой эвристикой, gps применяла несколько схем редукции задач, и на основе выявления различий между объектами задачи и применения уменьшающих эти различия операторов рекурсивно формировала систему (дерево) целей (задач и подзадач).",объектами,ai,0
"[permex e f] функция осуществляет выход из ближайшей объемлющей функции с именем f и объявляет ее результатом значение аргумента e. при этом уничтожаются все развилки, появившиеся в программе с начала вычисления этой функции f, и замораживаются все изменения (в значениях переменных и т.п.), произведенные внутри этой функции.",аргумента,ai,0
предварительная оценка определяется соответственно как минимум или максимум уже известных к настоящему моменту оценок дочерних вершин.,моменту,ai,0
"условия применимости и действие этих четырех операторов легко задать в виде правил продукций вида: аргумент оператора результат оператора, причем x, y, z, w, v это переменные: перейти (w) : (x, п, y, z ) (w, п, y, z) передвинуть (v) : (x, п, x, z) (v, п, v, z) взобраться : (x, п, x, z) (x, я, x, z) схватить : (тб, я, тб , 0) (тб, я, тб , 1) рис.",правил,ai,0
"функции is goal и opening можно определить так: (defun is goal (state) (eq (car(last state) 'a))) (defun opening (state) (prog (dlist ;список формируемых дочерних состояний; townl townn; последний и следующий город маршрута; new roads ; списки дорог между городами; ) (setq roads '((a b)(a d)(a e)(a g)(b d)(b c)(c d)(c h) (d e)(d h)(e g)(h g)(e h))) ; расширение списка путей(дорог) между городами: (setq roads (add ways roads)) ; последний город маршрута: (setq townl (car(last state))) ; цикл поиска соседних с городом townl городов, в которые ; может вести маршрут: opc (setq new (find townl roads)) (cond ((null new) (return dlist))) (setq townn (car new)) (setq roads (cadr new)) (cond ((or (and (eq townn 'a)(eql (length state)7)) (not (member townn state)) ) (setq dlist (cons(append state(list townn)) dlist)))) (go opc) )) так как наличие дороги (пути) между городами x и y означает также наличие пути между y и x, то первоначальный список дорог между городами должен быть расширен симметричными связями-путями это выполняет вспомогательная функция add ways: (defun add ways (rlist) (cond ((null rlist) ()) (t (cons (car rlist) (cons (list (cadar rlist) (caar rlist)) (add ways(cdr rlist))) )))) вспомогательная функция find выполняет поиск города-соседа для заданного города town: (defun find (town roads) (cond ((null roads) ()) ((eq town (caar roads)) (list (cadar roads)(cdr roads)) ) (t (find town (cdr roads))) )) приведем теперь для сравнения реализацию функций is goal и opening на языке плэнер для их применения в функции depth first search поиска вглубь.",цикл поиска соседних,ai,0
"логические функции так называются три функции, реализующие основные логические операции.",логические операции,ai,0
"в построенном таким образом частичном дереве игры оцениваются его концевые вершины (листья), и по полученным оценкам определяется наилучший ход от заданной игровой конфигурации.",частичном дереве,ai,0
"представленная в решающем графе выигрышная стратегия может быть сформулирована словесно так: если в очередном ходе игрок плюс берет одну монету, то в следующем ходе минус должен взять две, а если плюс берет две монеты, то минус должен забрать одну.",очередном ходе,ai,0
[define is goal(state) [prog (x y z) [is ( x y z 1) [1 .state]] ]] [define opening (state) [prog(x y z (dlist ()) % список дочерних вершин; pc % точка текущего положения обезьяны; p1 p2 % две другие точки-константы пола;,положения обезьяны,ai,0
различие в третьем элементе (положение ящика) оператор передвинуть.,положение ящика,ai,0
"у некоторых вершин дерева осталась неуточненная, предварительная оценка, однако этих приближенных оценок оказалось достаточно для того, чтобы определить точную минимаксную оценку начальной вершины и наилучший первый ход.",вершины,ai,0
"заметим, что функция s(v) не учитывает должным образом трудность обмена местами двух соседних фишек, а поэтому ее эвристическая сила в принципе может быть повышена.",трудность,ai,0
"рассмотрим сначала идею работы альфа-бета процедуры на примере игрового дерева, приведенного на рис.19.",идею работы,ai,0
"при этом структура на рис.10(а) преобразуется в структуру, изображенную на рис.10(б): для двух из трех альтернативных множеств подзадач добавлены соответственно вершины d и e. рис.",множеств,ai,0
"в приведенном примере алгоритм поиска вглубь, сформулированный для пространств, являющихся деревьями, применялся к пространству состояний, являющемуся графом (в котором могут быть циклы).",приведенном примере,ai,0
"в то же время основной механизм решения задач в системе gps не был проблемно-ориентированным: он представлял собой реализацию универсального эвристического метода решения задач, часто применяемого человеком, и известного как анализ целей и средств (means-ends analysis).",эвристического метода решения задач,ai,0
"функции is goal и opening можно определить так: (defun is goal (state) (eq (car(last state) 'a))) (defun opening (state) (prog (dlist ;список формируемых дочерних состояний; townl townn; последний и следующий город маршрута; new roads ; списки дорог между городами; ) (setq roads '((a b)(a d)(a e)(a g)(b d)(b c)(c d)(c h) (d e)(d h)(e g)(h g)(e h))) ; расширение списка путей(дорог) между городами: (setq roads (add ways roads)) ; последний город маршрута: (setq townl (car(last state))) ; цикл поиска соседних с городом townl городов, в которые ; может вести маршрут: opc (setq new (find townl roads)) (cond ((null new) (return dlist))) (setq townn (car new)) (setq roads (cadr new)) (cond ((or (and (eq townn 'a)(eql (length state)7)) (not (member townn state)) ) (setq dlist (cons(append state(list townn)) dlist)))) (go opc) )) так как наличие дороги (пути) между городами x и y означает также наличие пути между y и x, то первоначальный список дорог между городами должен быть расширен симметричными связями-путями это выполняет вспомогательная функция add ways: (defun add ways (rlist) (cond ((null rlist) ()) (t (cons (car rlist) (cons (list (cadar rlist) (caar rlist)) (add ways(cdr rlist))) )))) вспомогательная функция find выполняет поиск города-соседа для заданного города town: (defun find (town roads) (cond ((null roads) ()) ((eq town (caar roads)) (list (cadar roads)(cdr roads)) ) (t (find town (cdr roads))) )) приведем теперь для сравнения реализацию функций is goal и opening на языке плэнер для их применения в функции depth first search поиска вглубь.",списки дорог,ai,0
"вначале функция выдает как свое значение первый элемент списка и завершает на этом работу, после чего программа продолжает свои вычисления.",первый элемент,ai,0
"немаловажно, что алгоритмы слепого перебора описаны нами в форме, пригодной для их программирования с использованием любого языка, не только языка программирования задач искусственного интеллекта.",программирования задач искусственного,ai,0
2.2.1 поиск вширь базовый алгоритм поиска вширь состоит из следующей последова тельности шагов: шаг 1.,тельности шагов,ai,0
"наиболее интересной представляется задача поиска выигрышной стратегии для одного из игроков, отправляясь от некоторой конкретной позиции игры (не обязательно начальной).",игроков,ai,0
значением аргумента функции go должен быть идентификатор одна из меток ближайшей объемлющей блочной функции.,аргумента функции,ai,0
"а-алгоритм эвристического поиска с функцией h(v), удовлетворяющей этому условию, получил название а -алгоритма [нильсон73, разделы 3.7-3.9; лорьер, раздел 5.6].",алгоритм,ai,0
"с точки зрения синтаксиса, обращения к функциям, как и обрабатываемые ими данные, представ ляют собой так называемые s-выражения.",точки зрения синтаксиса,ai,0
"определение новых функций для определения новой функции следует обратиться к встроенной функции define: [define f dexp] вычисление функции define в качестве побочного эффекта приводит к появлению в программе новой функции с именем f и с так называемым определяющим выражением dexp, которое должно иметь следующий вид: (lambda (v1 v2 ... vn) e) (n 0) где vi - формальные параметры новой функции, а e - форма, зависящая от vi .",определения новой,ai,0
"если они равны, то значение функции равно t, иначе ().",значение функции равно,ai,0
"в то же время алгоритм поиска вглубь может оказаться предпочтительнее в тех случаях, когда он начат с ветви дерева, содержащей целевое состояние, решение задачи будет обнаружено раньше, чем при поиске вширь.",решение задачи,ai,0
"при последующем обращении к этой новой функции [f a1 a2 ... an] сначала вычисляются аргументы (фактические параметры) ai, затем вводятся локальные переменные vi, которым присваиваются значения соответствующих аргументов ai, и далее вычисляется форма e при этих значениях переменных vi, после чего эти переменные уничтожаются.",обращении,ai,0
"для формализации этой задачи в рамках подхода, основанного на редукции задач, необходимо определить форму описания задач/подзадач, операторы редукции и элементарные задачи.",форму описания,ai,0
"в общем случае в процессе решения возможно возникновение многих подобных точек выбора, называемых обычно точками бектрекинга или развилками; к каждой из таких точек может потребоваться возврат для выбора других вариантов решения.",процессе,ai,0
следующие две особые функции используются для упрощения записи часто используемых конструкций (setq v(cdr v)) и (setq v(cons(e v)).,упрощения,ai,0
"разновидность алгоритма эвристического поиска, применяемого для поиска оптимального решающего пути и использующего при этом оценочную функцию указанного выше вида ( ), известна в литературе как а-алгоритм [нильсон85, раздел 2.4].",разновидность,ai,0
"если сравнивать эту плэнер-функцию с вышеприведенными лисп-функциями для поиска вширь и вглубь, то нетрудно заметить, что встроенный механизм бектрекинга позволил обойтись без многих вспомогательных структур списков открытых и закрытых вершин, списка указателей между вершинами и др., а также без операций по их модификации.",списка указателей,ai,0
"[num e] эта функция-предикат проверяет, является ли числом значение ее аргумента.",функция-предикат,ai,0
"к примеру, в задаче о пирамидке ключевым оператором был оператор переноса на нужный колышек нижнего диска 3 (см. рис.8).",оператор переноса,ai,0
"как и в случае алгоритмов слепого поиска, множество порождаемых алгоритмом вершин и указателей образует дерево, в листьях которого находятся нераскрытые вершины.",случае алгоритмов,ai,0
"тогда возможным состояниям соответствуют списки из элементов a, b, c, d, e, h, g без повторений, исключение составляет только элемент-город a, он может встретиться в списке дважды в начале списка и его конце.",списки,ai,0
при выбранной форме описания задач результирующие подзадачи естественно интерпретируются как задачи нахождения пути между определенными состояниями-вехами в пространстве состояний.,описания,ai,0
"аналогично представлению в пространстве состояний, формализация задачи в рамках подхода, основанного на редукции задач, включает определение следующих составляющих: формы описания задач/подзадач и описание исходной задачи; множества операторов и их воздействий на описания задач; множества элементарных задач.",описание,ai,0
"значением этой функции является список всех состояний-вершин, лежащих на решающем пути от st до целевой вершины.",вершин,ai,0
"в противоположность слепому поиску, эвристический поиск использует априорную, эвристическую информацию об общем виде пространства состояний и/или о том, где в этом пространстве расположена цель, поэтому для раскрытия обычно выбирается наиболее перспективная вершина.",раскрытия,ai,0
краткие сведения о языках лисп и плэнер 4.1 язык программирования лисп в языке лисп все действия описываются в виде функций.,программирования,ai,0
"операторы сведения (редукции) этой задачи к подзадачам определяются исходя из ходов, допустимых в проводимой игре: если в некоторой конфигурации x+ очередной ход делает игрок плюс, и имеется n допустимых ходов, приводящих соответственно к конфигурациям x1 , x2 , ..., xn , то для решения задачи w(x+) необходимо решить по крайней мере одну из подзадач w(xi ).",сведения,ai,0
"два основных подвида слепого поиска, различающиеся порядком раскрытия вершин, это поиск вширь и поиск вглубь.",вершин,ai,0
"в дополнение отметим, что подход с использованием пространства состояний можно рассматривать как вырожденный случай подхода, основанного на редукции задач, так как применение оператора в пространстве состояний сводит обычно исходную задачу к несколько более простой задаче, т.е. редуцирует ее.",использованием пространства,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",априори,ai,0
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,реализация алгоритмов слепого,ai,0
"к примеру, в задаче об обезьяне и банане различием можно считать неравенство соответствующих элементов списков, описывающих два состояния.",элементов списков,ai,0
"пример и/или-графа сформулируем общее рекурсивное определение разрешимости вершины в и/или-графе: заключительные вершины разрешимы, так как они соответствуют элементарным задачам; или-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима по крайней мере одна из ее дочерних вершин; и-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима каждая из ее дочерних вершин.",вершин,ai,0
"действительно, запоминание всех альтернатив продолжения поиска (нераскрытых вершин) осуществляется в списке open, на шаге 3 производится выбор варианта-альтернативы, а возврат к этому шагу для выбора следующей альтернативы осуществляется на шагах 4 и 5.",варианта-альтернативы,ai,0
"исходя из оценки первой дочерней вершины начальная вершина w0+, соответст вующая исходной позиции игры, к этому моменту уже предварительно оценена величиной 3.",величиной,ai,0
"1.1.2 примеры пространств состояний разберем два характерных примера представления задач в пространстве состояний, показывающих, что такое представление возможно для различных типов задач.",характерных примера представления,ai,0
"функции is goal и opening можно определить так: (defun is goal (state) (eq (car(last state) 'a))) (defun opening (state) (prog (dlist ;список формируемых дочерних состояний; townl townn; последний и следующий город маршрута; new roads ; списки дорог между городами; ) (setq roads '((a b)(a d)(a e)(a g)(b d)(b c)(c d)(c h) (d e)(d h)(e g)(h g)(e h))) ; расширение списка путей(дорог) между городами: (setq roads (add ways roads)) ; последний город маршрута: (setq townl (car(last state))) ; цикл поиска соседних с городом townl городов, в которые ; может вести маршрут: opc (setq new (find townl roads)) (cond ((null new) (return dlist))) (setq townn (car new)) (setq roads (cadr new)) (cond ((or (and (eq townn 'a)(eql (length state)7)) (not (member townn state)) ) (setq dlist (cons(append state(list townn)) dlist)))) (go opc) )) так как наличие дороги (пути) между городами x и y означает также наличие пути между y и x, то первоначальный список дорог между городами должен быть расширен симметричными связями-путями это выполняет вспомогательная функция add ways: (defun add ways (rlist) (cond ((null rlist) ()) (t (cons (car rlist) (cons (list (cadar rlist) (caar rlist)) (add ways(cdr rlist))) )))) вспомогательная функция find выполняет поиск города-соседа для заданного города town: (defun find (town roads) (cond ((null roads) ()) ((eq town (caar roads)) (list (cadar roads)(cdr roads)) ) (t (find town (cdr roads))) )) приведем теперь для сравнения реализацию функций is goal и opening на языке плэнер для их применения в функции depth first search поиска вглубь.",связями-путями,ai,0
"так же как в пространстве состояний, применяются: поиск вширь (вершины раскрываются в том порядке, в котором строились); поиск вглубь (в первую очередь раскрываются те вершины, которые были построены последними, глубина поиска обычно ограничивается); подъем на холм и эвристический поиск (выбор вершины для раскрытия производится на основе эвристических оценок вершин).",выбор вершины,ai,0
"напомним, что при этом должны быть определены следующие составляющие: форма описания задач и подзадач; операторы, сводящие задачи к подзадачам; элементарные задачи; а также задано описание исходной задачи.",описания,ai,0
"что же касается альфа-бета процедуры, то программа на лиспе [уинстон, глава 13] существенно более громоздка и трудна для понимания, чем приведенная выше плэнер-функция, поскольку в последней применяется встроенный механизм возвратов.",понимания,ai,0
"проверить, является ли заданная вершина goal заключительной.",вершина,ai,0
"неразрешимость вершины (и соответствующей задачи) дерева поиска может быть определена рекурсивным образом аналогично определению разрешимой вершины, данному в первой главе пособия: вершина, не являющаяся заключительной и не имеющая дочерних вершин, неразрешима; или-вершина неразрешима тогда и только тогда, когда неразрешимы все ее дочерние вершины; и-вершина неразрешима тогда и только тогда, неразрешима хотя бы одна из ее дочерних вершин.",первой главе,ai,0
"для игры крестики-нолики на фиксированном квадрате возможна такая статиче ская оценочная функция: + , если p есть позиция выигрыша игрока плюс e(p) = , если p есть позиция выигрыша игрока минус (nl+ +nc+ +nd+ ) (nl +nc +nd ) в остальных случаях где: + очень большое положительное число; очень маленькое отрицательное число; nl+, nc+, nd+ соответственно число строк, столбцов и диагоналей, открытых для игрока плюс (т.е. где он еще может поставить три выигрышных крестика подряд); nl , nc , nd аналогичные числа для игрока минус.",статиче,ai,0
"причем согласно минимаксному принципу оценка может только увеличиться (поскольку подсчитывается как максимум оценок дочерних вершин), но даже если она увеличится, это не повлияет на оценку вершины w1 , поскольку последняя при уточнении по минимаксному принци пу может только уменьшаться (так как равна минимуму оценок дочерних вершин).",минимаксному принципу оценка,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",вариант,ai,0
"именно с этим связана одна из слабостей применяемого в системе gps подхода: процедуры вычисления различий и уменьшающих их операторов должны быть отдельно реализованы для каждой конкретной задачи (или для очень узкой предметной области, включающей несколько видов задач), в противном случае снижалась эффективность решения задач.",случае,ai,0
"заметим попутно, что язык плэнер, по сравнению с прологом, предлагает более гибкие средства управления бектрекингом, краткое описание этих средств находится в разделе 4.2 пособия.",управления бектрекингом,ai,0
разрешимость этой вершины зависит от разрешимости других вершин графа.,других вершин графа,ai,0
"действительно, отправляясь от начальной ситуации, можно построить конфигурации, возникающие в результате выполнения возможных в этой ситуации ходов, затем построить множество конфигураций, получающихся после применения следующего хода, и так далее пока не будет достигнута целевая конфигурация.",начальной ситуации,ai,0
"в add state применяется встроенная лисповская функция nth, выбирающая из заданного списка элемент с заданным порядковым номером (отсчет элементов начинается с нуля).",отсчет элементов,ai,0
"встроенный же режим возвратов обеспечивает запоминание мест развилок и то, какие альтернативы в них еще не рассматривались, обеспечивает возврат программы по неуспеху к последней развилке и отмену ранее произведенных изменений в значениях переменных.",возврат программы,ai,0
"возврат же к предыдущей по времени возникновения развилке (т.е. точке бектрекинга, организованной на предыдущем шаге цикла и лежащей на один шаг вверх в дереве перебора) будет инициирован самой функцией among в двух следующих случаях.",следующих случаях,ai,0
"2.2 слепой поиск слепые алгоритмы поиска вширь (breadth first search) и поиска вглубь (depth first search) различаются тем, какая вершина выбирается для очередного раскрытия.",слепые алгоритмы,ai,0
"при этом подходе производится анализ исходной задачи с целью выделения такого набора подзадач, решив которые, мы решим исходную задачу.",подходе,ai,0
"предполагается также, что используемая алгоритмом операция раскрытия вершин организована таким образом, что она не порождает никакое состояние, идентичное состоянию в уже построенной вершине, являющейся родительской для раскрываемой вершины.",образом,ai,0
"для рассмотренных примеров работы алгоритмов для игры в восемь этот показатель равен соответственно: эвристический поиск 5/13, поиск вширь 5/46, поиск вглубь 5/35, ясно, что алгоритм эвристического поиска с хорошо подобранной оценочной функцией находит решение задачи быстрее алгоритмов слепого перебора.",примеров работы,ai,0
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",вершины,ai,0
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",составных элементов описания,ai,0
"усовершенствованный таким образом алгоритм поиска вширь всегда завершит работу в случае существования решения, а усовершенствованный алгоритм поиска вглубь закончится в любом случае, независимо от существования решения.",образом,ai,0
"в рассмотренных на рис.1 примерах задач искомое целевое состояние задается явно, т.е. известно местоположение каждой фишки в целевой конфигурации.",конфигурации,ai,0
"в описание состояния включается также в качестве первого элемента списка обозначение того оператора движения пустой клетки, который привел к данному состоянию.",качестве первого,ai,0
"описываемые алгоритмы используют списки open и closed, состоящие соответственно из раскрытых и нераскрытых вершин пространства состояний.",списки,ai,0
"решение задачи длиною в пять ходов найдено в результате раскрытия 6 и построения 13 вершин это существенно меньше, чем при использовании слепого перебора (соответствующие числа были: для поиска вширь 26 и 46 вершин, для поиска вглубь 18 и 35 вершин).",решение задачи,ai,0
"будем далее предполагать, что задачи и подзадачи решаются в пространстве состояний и записываются как (s i, o, sg), где s i и sg соответственно начальное и целевое состояния, причем множество o операторов преобразований состояний может быть опущено в случае его постоянности (неизменности).",случае,ai,0
"рассмотрим, к примеру, игру крестики-нолики на квадрате 3 3.",крестики-нолики,ai,0
"в отличие от алгоритма поиска вширь, он осуществляет неполный поиск, поскольку целевая вершина может располагаться ниже граничной глубины (в таком случае она не будет обнаружена).",вершина,ai,0
исходная позиция (корневая вершина дерева) имеет тип т и находится на глубине 0.,вершина дерева,ai,0
"при использовании подхода, основанного на редукции задач, выигрышная стратегия ищется в процессе доказательства того, что игра может быть выиграна.",доказательства,ai,0
"успешно или нет завершилось вычисление очередного выражения программы, далее будет вычисляться следующее выражение.) в каких местах программы ставить развилки и с какими альтернативами, считать ли выбранный путь вычисления неуспешным и когда вырабатывать неуспех за все это отвечает автор программы.",выражения,ai,0
"причем в обоих случаях отсечение было неглубоким, поскольку необходимая для соблюдения соот ветствующего правила отсечения альфа- или бета-величина находилась в непосредственно предшествующей к точке отсечения вершине.",правила,ai,0
"операторы сведения (редукции) этой задачи к подзадачам определяются исходя из ходов, допустимых в проводимой игре: если в некоторой конфигурации x+ очередной ход делает игрок плюс, и имеется n допустимых ходов, приводящих соответственно к конфигурациям x1 , x2 , ..., xn , то для решения задачи w(x+) необходимо решить по крайней мере одну из подзадач w(xi ).",подзадачам,ai,0
"особенностью задачи интегрирования является то, что, например, при интегрировании по частям может оказаться несколько способов разбиения исходного подынтегрального выражения на части и соответственно несколько способов применения этого правила интегрирования.",разбиения исходного,ai,0
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",процедура,ai,0
описанный алгоритм поиска вширь является полным.,алгоритм поиска вширь,ai,0
"во-вторых, нужна таблица или процедура, связывающая ключевые операторы с возможными различиями (в gps использовалась таблица связей различие-оператор).",различие,ai,0
"при этом роль, аналогичную операторам в пространстве состояний, играют операторы, сводящие задачи в подзадачи.",операторы,ai,0
"на этом построение игрового дерева заканчивается, полученный резуль тат лучший первый ход тот же самый, что и при минимаксной процедуре.",построение,ai,0
"важно, что рассмотренные правила работают в ходе построения игрового дерева вглубь; это означает, что предварительные оценки промежу точных вершин появляются лишь по мере продвижения от концевых вершин дерева вверх к корню и реально отсечения могут начаться только после того, как получена хотя бы одна точная минимаксная оценка промежуточной вершины.",рассмотренные правила,ai,0
функция присваивает этой переменной новое значение вычисленное значение формы e.,переменной новое значение вычисленное,ai,0
"в задаче об обезьяне и банане приоритет (значимость) различий можно установить, например, следующим образом: различие в четвертом, затем во втором, затем в третьем и первом элементах описания состояния задачи.",банане приоритет,ai,0
"значение оценочной функции est определяется как сумма числа фишек, стоящих не на своих местах, и длины пути (глубины) оцениваемого состояния-вершины в дереве поиска.",состояния,ai,0
указанные в виде стрелок направления соответствуют движению от вершины-аргумента применяемого оператора к результирующей вершине.,вершины-аргумента применяемого,ai,0
для определенности будем рассматривать задачу выигрыша игрока плюс и соответственно поиска достаточно хорошего его первого хода от заданной конфигурации.,выигрыша игрока,ai,0
"два основных подвида слепого поиска, различающиеся порядком раскрытия вершин, это поиск вширь и поиск вглубь.",подвида,ai,0
"тогда при сравнении состояний (то, п, тя, 0) и (тя, п, то, 1) выявляются три различия соответственно в первых, третьих и четвертых элементах этих списков.",четвертых элементах,ai,0
"в случае успеха поиска в качестве значения функции выдается хвост списка l, начиная с найденного атома, в случае же неуспеха выдается nil.",случае,ai,0
"функции is goal и opening можно определить так: (defun is goal (state) (eq (car(last state) 'a))) (defun opening (state) (prog (dlist ;список формируемых дочерних состояний; townl townn; последний и следующий город маршрута; new roads ; списки дорог между городами; ) (setq roads '((a b)(a d)(a e)(a g)(b d)(b c)(c d)(c h) (d e)(d h)(e g)(h g)(e h))) ; расширение списка путей(дорог) между городами: (setq roads (add ways roads)) ; последний город маршрута: (setq townl (car(last state))) ; цикл поиска соседних с городом townl городов, в которые ; может вести маршрут: opc (setq new (find townl roads)) (cond ((null new) (return dlist))) (setq townn (car new)) (setq roads (cadr new)) (cond ((or (and (eq townn 'a)(eql (length state)7)) (not (member townn state)) ) (setq dlist (cons(append state(list townn)) dlist)))) (go opc) )) так как наличие дороги (пути) между городами x и y означает также наличие пути между y и x, то первоначальный список дорог между городами должен быть расширен симметричными связями-путями это выполняет вспомогательная функция add ways: (defun add ways (rlist) (cond ((null rlist) ()) (t (cons (car rlist) (cons (list (cadar rlist) (caar rlist)) (add ways(cdr rlist))) )))) вспомогательная функция find выполняет поиск города-соседа для заданного города town: (defun find (town roads) (cond ((null roads) ()) ((eq town (caar roads)) (list (cadar roads)(cdr roads)) ) (t (find town (cdr roads))) )) приведем теперь для сравнения реализацию функций is goal и opening на языке плэнер для их применения в функции depth first search поиска вглубь.",список дорог,ai,0
первая функция устанавливает глубину дочерних вершин и вычисляет их эвристическую оценку.,дочерних вершин,ai,0
"каждый указатель есть трехэлементный список из идентификатора родительской вершины, идентификатора дочерней вершины и названия связывающего их оператора.",названия,ai,0
"тем самым схема состояния описывает целое множество состояний, а не только одно, а схема оператора определяет все множество действий некоторого типа.",множество состояний,ai,0
"напомним, что, как и прежде, первый элемент этого списка уникальный идентификатор состояния, второй собственно описание состояния, а третий элемент глубина соответствующей этому состоянию вершины в дереве поиска.",третий элемент глубина соответствующей,ai,0
"2.6.2 схема просмотра и/или-дерева отвлекаясь от многочисленных деталей организации поиска на и/или-графах общего вида, рассмотрим только на схему раскрытия вершин и формирования решающего дерева при поиске в графах-деревьях.",формирования решающего,ai,0
"например, для шашек в качестве простейшей статической функции может быть взят перевес в количестве шашек (и дамок) у игрока плюс.",перевес,ai,0
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",состояний,ai,0
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,плэнер-алгоритмы,ai,0
"заметим, что существуют задачи, для которых нельзя найти оценочную функцию, обеспечивающую во всех случаях как эффективность, так и допустимость эвристического поиска.",допустимость эвристического,ai,0
"ключевая идея редукции состоит в том, что для перемещения всей пирамидки необходимо переложить самый нижний диск 3, а это возможно, только если располагающаяся над ним пирамидка из двух меньших дисков 1 и 2 перенесена на колышек в см. рис.",идея редукции,ai,0
"числовые индексы имен остальных вершин показывают порядок, в котором эти вершины строились алгоритмом перебора вглубь.",имен остальных,ai,0
функция присваивает этой переменной новое значение вычисленное значение формы e.,функция,ai,0
"видно, что поскольку каждый раз выбор вершины с минимальной оценкой производится внутри всего построенного к текущему моменту дерева перебора, то раскрываемые друг за другом вершины могут располагаться в отдаленных друг от друга частях дерева.",частях дерева,ai,0
"у этой традиции, сложившейся почти за 30 лет существования теории эвристического поиска, существует важная причина.",существования теории эвристического поиска,ai,0
из-за такого усложнения описания состояния несколько сложнее становится предотвращающая зацикливание проверка в функции depth first search.,усложнения,ai,0
"отметим, что для аналогичной задачи w(7+) решающий граф построить не удастся (начальная вершина неразрешима); таким образом, у игрока плюс нет выигрышной стратегии в этой игре.",стратегии,ai,0
"вспомогательные функции opening и is goal зависят от конкретной решаемой задачи, а вспомогательная функция q sort выполняет упорядочение (по неубыванию их оценок) порожденных дочерних вершин (q sort реализует алгоритм быстрой сортировки).",вершин,ai,0
рассмотренные рекурсивные процедуры могут быть легко детализированы для получения либо простого поиска вглубь (при произвольном выборе вершины на шаге 3 or-процедуры) или получения алгоритма подъема на холм (если список glist упорядочен по неубыванию эвристической оценочной функции и на шаге 3 or-процедуры выбирается вершина с наименьшей оценкой).,функции,ai,0
"язык плэнер учитывает эту потребность и предлагает для такой проверки механизм сопоставления с образцом, который реализует встроенная функция is: [is pat e] здесь pat это образец, который задает требуемую структуру списка, а значение аргумента e тот список (обозначим его e), который проверяется на соответствие данному образцу.",соответствие,ai,0
"в общем случае в процессе решения возможно возникновение многих подобных точек выбора, называемых обычно точками бектрекинга или развилками; к каждой из таких точек может потребоваться возврат для выбора других вариантов решения.",подобных точек,ai,0
"функция проверяет, совпадает ли какой-нибудь элемент (верхнего уровня) этого списка со значением аргумента e1.",уровня,ai,0
"для игры крестики-нолики на фиксированном квадрате возможна такая статиче ская оценочная функция: + , если p есть позиция выигрыша игрока плюс e(p) = , если p есть позиция выигрыша игрока минус (nl+ +nc+ +nd+ ) (nl +nc +nd ) в остальных случаях где: + очень большое положительное число; очень маленькое отрицательное число; nl+, nc+, nd+ соответственно число строк, столбцов и диагоналей, открытых для игрока плюс (т.е. где он еще может поставить три выигрышных крестика подряд); nl , nc , nd аналогичные числа для игрока минус.",выигрыша игрока,ai,0
функция вычисляет количество элементов (верхнего уровня) этого списка.,верхнего уровня,ai,0
"ключевая идея редукции состоит в том, что для перемещения всей пирамидки необходимо переложить самый нижний диск 3, а это возможно, только если располагающаяся над ним пирамидка из двух меньших дисков 1 и 2 перенесена на колышек в см. рис.",ключевая идея,ai,0
"он вычисляется по формуле p = l / n , где l длина найденного пути до цели (она равна глубине целевой вершины); n общее число вершин, построенных в ходе перебора.",глубине,ai,0
"язык плэнер учитывает эту потребность и предлагает для такой проверки механизм сопоставления с образцом, который реализует встроенная функция is: [is pat e] здесь pat это образец, который задает требуемую структуру списка, а значение аргумента e тот список (обозначим его e), который проверяется на соответствие данному образцу.",функция,ai,0
"функция сравнивает значения своих аргументов, которые должны быть атомами-идентификаторами.",идентификаторами,ai,0
двумя составными элементами процесса решения задач в теории эвристического поиска является представление (формализация) задач и собственно решение поиск.,решение,ai,0
"2.1 разновидности поиска как уже отмечалось, поиск в пространстве состояний базируется на последовательном построении (переборе) вершин графа состояний до тех пор, пока не будет обнаружено целевое состояние.",состояний,ai,0
в задаче об обезьяне естественно связать различия и операторы-кандидаты в ключевые следующим образом: различие в первом элементе списка-описания состояния (положение обезьяны в плоскости пола) операторы перейти и передвинуть.,кандидаты,ai,0
"поскольку глубина поиска ограничена, то будучи примененным к деревьям-пространствам состояний, описанный базовый алгоритм поиска вглубь всегда заканчивает работу.",деревьям,ai,0
"2.6.2 схема просмотра и/или-дерева отвлекаясь от многочисленных деталей организации поиска на и/или-графах общего вида, рассмотрим только на схему раскрытия вершин и формирования решающего дерева при поиске в графах-деревьях.",вершин,ai,0
вычисленное значение формы становится значением функции f. операции над списками (car l) значением аргумента l должен быть непустой список; значением же функции является первый элемент верхнего уровня этого списка.,значением аргумента,ai,0
"если неравенство h1(v) h2(v) верно для всех вершин пространства состояний, не являющихся целевыми, а -алгоритм, использующий эвристическую составляющую h2(v), называется более информированным, чем а -алгоритм с функцией h1(v).",состояний,ai,0
"причем в обоих случаях отсечение было неглубоким, поскольку необходимая для соблюдения соот ветствующего правила отсечения альфа- или бета-величина находилась в непосредственно предшествующей к точке отсечения вершине.",соблюдения соот,ai,0
"в ходе поиска также построено 12 вершин (раскрыто 7), вершины перенумерованы в том порядке, в котором они были построены.",вершины,ai,0
"[pset v e] это аналог функции set, т.е. переменной, имя которой является значением аргумента v, присваивается новое значение значение аргумента e.",значение значение аргумента,ai,0
"к ним относятся: атомы (значение атома - сам атом), обращения к переменным с префиксом ""."" (значением является текущее значение переменной), списки в круглых скобках (значением является список из значений элементов исходного списка) и обращения к функциям, имеющие вид [f a1 a2 ... an], где f - имя функции, а ai - ее аргументы.",значение атома,ai,0
"решающее дерево заканчивается на позициях, выигрышных для плюса, и содержит полную стратегию достижения им выигрыша: для каждого возможного продолжения игры, выбранного противником, в дереве есть ответный ход, приводящий к победе.",выигрыша,ai,0
алгоритмы поиска решения оба рассмотренных подхода к решению задач представление в пространстве состояний и метод редукции задач предполагают поиск на графе соответствующего вида.,пространстве,ai,0
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",функций общего,ai,0
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",оценок,ai,0
"программа на лиспе представляет собой последовательность форм, и ее выполнение заключается в последовательном вычислении этих форм.",последовательность,ai,0
"предполагается, что в каждом списке-описании состояния, кроме идентификатора состояния и собственно описания состояния задачи, содержится также третий элемент глубина этого состояния-вершины в дереве поиска.",идентификатора,ai,0
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",проведения отсечений,ai,0
"(heuristic search initstate) )) 2.6 поиск на и/или-графах 2.6.1 особенности поиска и/или-граф, называемый также графом целей (задач), неявно задается при формализации задачи с использованием метода редукции, путем описания исходной задачи, операторов сведения задачи к подзадачам и множества элементарных задач.",исходной задачи,ai,0
"в таком случае список е соответствует образцу-списку pat, если у этих списков равное число элементов и если их элементы попарно соответствуют друг другу (эти соответствия проверяются последовательно слева направо).",равное число,ai,0
"как и в случае поиска в пространстве состояний, все алгоритмы перебора на и/или-графе можно описать, опираясь на операцию раскрытия очередной вершины графа, означающую применение к ней (точнее, к соответствующему состоянию) всех возможных операторов редукции, порождающих дочерние вершины.",состояний,ai,0
"действительно, просмотр осуществляется как последовательный поиск, или перебор вершин, в пространстве состояний.",последовательный поиск,ai,0
"очевидно, что такой локальный выбор среди только что построенных дочерних вершин реализовать гораздо проще, чем глобальный выбор вершины во всем дереве перебора.",перебора,ai,0
"обычно эта задача решается путем последовательного преобразования интеграла к выражению, содержащему известные табличные интегралы.",табличные интегралы,ai,0
"как и в случае алгоритмов слепого поиска, множество порождаемых алгоритмом вершин и указателей образует дерево, в листьях которого находятся нераскрытые вершины.",случае алгоритмов слепого поиска,ai,0
значение функции их максимум.,значение,ai,0
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",минимаксной процедуре процесс построения,ai,0
"отметим, что на шаге 3, выбирая из списка open первый элемент-вершину, мы тем самым выбираем вершину с минимальной оценкой, поскольку список open всегда упорядочен по неубыванию хранящихся в нем оценок вершин-состояний (это обеспечивается вспомогательной функцией merge).",список,ai,0
"если да, то значение функции равно t, иначе ().",значение функции равно,ai,0
"причины усложнения алгоритмов поиска на и/или-графах связаны с тем, что более сложной становится проверка условий окончания перебора, т.е. разрешимости исходной задачи.",условий,ai,0
"очевидно, что если и-вершин в этом графе нет, то получаем обычный граф-пространство состояний, для поиска в котором можно использовать рассмотренные в настоящей главе алгоритмы, но из-за наличия в общем случае в графе таких вершин нужна модификация алгоритмов, существенно их усложняющая.",модификация,ai,0
"алгоритм перебора вширь на и/или-дереве непременно обнаруживает то решающее дерево, самая глубокая заключительная вершина которого имеет минимальную глубину (если, конечно, решение задачи вообще существует).",самая глубокая заключительная вершина,ai,0
"решением этой задачи будет подходящая последовательность сдвигов фишек, например: передвинуть фишку 8 вверх, фишку 6 влево и т.д. рис.",последовательность сдвигов фишек,ai,0
"заметим, что часть получаемых таким образом операторов редукции (как, например, операторы, соответствующие правилу интегрирования по частям или правилу интегрирования суммы функций), действительно редуцируют исходную задачу и порождают и-вершину в и/или-графе, в то время как алгебраические и тригонометрические подстановки и тождества (как, например, деление числителя на знаменатель или дополнение до полного квадрата) лишь заменяют одно подынтегральное выражение на другое, порождая, таким образом, или-вершины.",вершины,ai,0
на рис.1(а) изображены две конфигурации фишек.,конфигурации,ai,0
"немаловажно, что алгоритмы слепого перебора описаны нами в форме, пригодной для их программирования с использованием любого языка, не только языка программирования задач искусственного интеллекта.",искусственного интеллекта,ai,0
"в общем случае, эта оценка может быть получена при наличии оценки хотя бы одной дочерней вершины.",случае,ai,0
"действительно, запоминание всех альтернатив продолжения поиска (нераскрытых вершин) осуществляется в списке open, на шаге 3 производится выбор варианта-альтернативы, а возврат к этому шагу для выбора следующей альтернативы осуществляется на шагах 4 и 5.",вершин,ai,0
"4.2 язык программирования плэнер в языке плэнер программа и обрабатываемые ею данные записываются в виде выражений, к которым относятся: атомы (идентификаторы и числа), обращения к переменным, состоящие из префикса и имени переменной (например, .x), и списки, представляющие собой последовательности выражений заключенные в круглые, квадратные или угловые скобки (например, [elem 1(a b c)]).",выражений заключенные,ai,0
"если в развилке уже не оказалось нерассмотренных альтернатив, то неуспех возвращает программу к предыдущей развилке.",предыдущей развилке,ai,0
"встроенный механизм возвратов языка плэнер совсем не облегчает программирование других разновидностей поиска перебора вширь и эвристического поиска, и оно выполняется обычно без использования этого механизма, т.е. почти так же, как и в языках программирования без встроенного бектрекинга.",других разновидностей поиска,ai,0
ниже приводятся тексты лисп-функций breadth first search (поиска вширь) и limited depth search (огра ниченного поиска вглубь) от начального состояния startstate.,начального состояния,ai,0
"встроенный механизм бектрекинга позволяет упростить разработку поисковой программы, укорачивая ее текст это демонстрирует приведенная в разделе 2.4 плэнерская функция deрth first search, реализующая поиск вглубь (без ограничения глубины).",программы,ai,0
"в этом случае развилка бы ставилась при каждом обращении к рекурсивной функции поиска, и в типичном случае каждое рекурсивное обращение соответствовало бы шагу вниз по дереву перебора.",рекурсивное обращение,ai,0
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",списка,ai,0
"предполагается, что в каждом списке-описании состояния, кроме идентификатора состояния и собственно описания состояния задачи, содержится также третий элемент глубина этого состояния-вершины в дереве поиска.",элемент,ai,0
"примеры статических оценок позиций игры ""крестики-нолики"" подчеркнем, что с помощью статической оценочной функции оцениваются только концевые вершины дерева игры, для оценок же промежуточных вершин, как и начальной вершины, используется минимакс ный принцип, основанный на следующей простой идее.",оценок позиций,ai,0
но в случае поиска на произвольном графе (и в этом отличие от деревьев-пространств) одно и тоже состояние может быть продублировано в разных частях построенного дерева поиска: граф как бы разворачивается в дерево путем дублирования некоторых его частей.,отличие,ai,0
"язык плэнер учитывает эту потребность и предлагает для такой проверки механизм сопоставления с образцом, который реализует встроенная функция is: [is pat e] здесь pat это образец, который задает требуемую структуру списка, а значение аргумента e тот список (обозначим его e), который проверяется на соответствие данному образцу.",потребность,ai,0
"2.1 разновидности поиска как уже отмечалось, поиск в пространстве состояний базируется на последовательном построении (переборе) вершин графа состояний до тех пор, пока не будет обнаружено целевое состояние.",пространстве,ai,0
"отметим, что за исключением последних форм в каждой ветви (они используются для вычисления значения условного выражения), в качестве форм ei,j имеет смысл использовать только такие, которые имеют при вычислении побочный эффект, например, присваивание переменной значения и т.п. другие специальные функции (quote e) или 'e это функция блокировки вычислений: она выдает в качестве значения свой аргумент, не вычисляя его.",значения условного,ai,0
"в принципе, используя математическую индукцию и рассуждая, как показано на примере, несложно доказать следующее утверждение: альфа-бета процедура всегда приводит к тому же результату (наилучшему первому ходу), что и простая минимаксная процедура той же глубины.",принципе,ai,0
"2.5.3 игра в восемь (лисп) граф-пространство состояний для головоломки-игры в восемь достаточно велик (в игре в пятнадцать фишек он на порядок больше), поэтому хотя в принципе применимы алгоритмы слепого поиска, предпочтителен все же эвристический поиск.",принципе применимы,ai,0
самый распространенный способ использования эвристической информации введение так называемой эвристической оценочной функции.,способ использования,ai,0
для поиска указателя к очередной вершине решающего пути функция использует вспомогательную функцию look for .,поиска,ai,0
"при таком способе редукции задач самый важный вопрос состоит в том, как найти кандидаты в ключевые операторы.",способе редукции задач самый,ai,0
"аргумент ее не вычисляется, в качестве ее аргумента должен быть задан идентификатор одна из меток ближайшей объемлющей блочной функции.",ближайшей объемлющей блочной функции,ai,0
"при этом роль, аналогичную операторам в пространстве состояний, играют операторы, сводящие задачи в подзадачи.",пространстве,ai,0
рассмотренные рекурсивные процедуры могут быть легко детализированы для получения либо простого поиска вглубь (при произвольном выборе вершины на шаге 3 or-процедуры) или получения алгоритма подъема на холм (если список glist упорядочен по неубыванию эвристической оценочной функции и на шаге 3 or-процедуры выбирается вершина с наименьшей оценкой).,неубыванию,ai,0
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",переупорядочивание вершин,ai,0
дальнейшая формализация решения задачи с использованием пространства состояний предполагает выбор некоторой конкретной формы описания состояний задачи.,конкретной формы,ai,0
"эти величины необходимы для проверки условий правил отсечений, поэтому отсечения не могут быть выполнены, пока величины не определены (альфа-отсечение пока неизвестна величина bmin, а бета-отсечение пока неизвестна amaх ).",неизвестна величина,ai,0
"нильсон, игры и математические задачи берутся не потому, что они просты и ясны, а потому, что они при минимальных структурах дают нам наибольшую сложность...",математические задачи,ai,0
"все это можно представить в виде 4-элементного списка (полоб, вертоб, полящ, цель), где полоб положение обезьяны на полу (это может быть двухэлементный вектор координат); полящ положение ящика на полу; вертоб это символ п или я в зависимости от того, где находится обезьяна, на полу или на ящике; цель это число 0 или 1 в зависимости от того, достала ли обезьяна бананы или нет.",полоб положение обезьяны,ai,0
"(pn en,1 en,2 ... en,kn)) (n 1, ki 1) функция последовательно вычисляет первые элементы своих аргументов предикаты pi.",аргументов предикаты,ai,0
ключевой оператор может быть использован для следующего способа сведения исходной задачи к подзадачам.,следующего способа сведения исходной,ai,0
"например: (caddr l) (car(cdr(cdr l))) предполагается, что список-аргумент l у всех этих функций-суперпозиций, как и у ниже описываемой функции nth, содержит необходимое число элементов (в противном случае вычисление программы прерывается сообщением об ошибке).",аргумент,ai,0
"например, для шашек в качестве простейшей статической функции может быть взят перевес в количестве шашек (и дамок) у игрока плюс.",количестве,ai,0
"для эвристического поиска в и/или-графе был предложен и исследован алгоритм, являющийся аналогом а -алгоритма в пространстве состояний, и получивший название ао -алгоритма [нильсон73, разделы 5.6, 5.7; нильсон85, раздел 3.2].",алгоритм,ai,0
значением функции mm evalp является либо вычисленная оценка вершины position (при depth>0) либо список дочерних для position позиций с их числовыми оценками (при depth=0).,значением,ai,0
"после построения каждой новой вершины графа надо как-то определять, не стала ли разрешима начальная вершина.",новой вершины,ai,0
"один из способов, предложенных и опробованных впервые в одной из наиболее известных систем искусственного интеллекта gps [слейгл, глава 8], заключается в выявлении различий для начального и целевого состояний задачи.",систем,ai,0
"в заключение отметим, что статическая оценочная функция и альфа-бета процедура две непременные составляющие почти всех компьютерных игро вых программ (в том числе коммерческих).",процедура,ai,0
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",оценочной функций общего вида,ai,0
"(defun breadth first search (startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; goal ;целевая вершина;) ;шаг 1:; (setq open (list (list 's0 startstate))) ;шаг 2:; вs (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;шаги 4,5:; (setq deslist (opening current)) (cond((setq goal(check goals deslist)) (return (solution goal reflist)) )) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go bs))) (setq open (append open deslist)) ; построение указателей и занесение их в общий список:; (setq reflist (append (connect deslist current) reflist)) (go вs) )) нижеследующая лисп-функция limited depth search поиска вглубь имеет два аргумента: кроме начального состояния startstate в число ее аргументов включена граничная глубина limdepth.",список указателей,ai,0
2.4 лисп- и плэнер-алгоритмы поиска в пространстве состояний 2.4.1 слепой поиск на лиспе реализация алгоритмов слепого перебора на языке программирования лисп не представляет особых затруднений.,реализация алгоритмов,ai,0
для поиска указателя к очередной вершине решающего пути функция использует вспомогательную функцию look for .,вершине решающего,ai,0
различие в четвертом элементе (содержимое руки обезьяны) оператор схватить.,оператор,ai,0
"работая в соответствии с этой эвристикой, gps применяла несколько схем редукции задач, и на основе выявления различий между объектами задачи и применения уменьшающих эти различия операторов рекурсивно формировала систему (дерево) целей (задач и подзадач).",основе,ai,0
"в последнем случае, однако, дерево перебора может содержать дубликаты состояний и возможно зацикливание алгоритма.",зацикливание,ai,0
"эта пред варительная оценка вершины w4 может быть уточнена в дальнейшем, но в соответствии с минимаксным принципом возможно только ее уменьшение, и это уменьшение не повлияет на оценку вершины w0+, поскольку последняя, опять же согласно минимаксному принципу, может только увеличиваться.",оценку вершины,ai,0
"например: (caddr l) (car(cdr(cdr l))) предполагается, что список-аргумент l у всех этих функций-суперпозиций, как и у ниже описываемой функции nth, содержит необходимое число элементов (в противном случае вычисление программы прерывается сообщением об ошибке).",случае вычисление,ai,0
краткие сведения о языках лисп и плэнер 4.1 язык программирования лисп в языке лисп все действия описываются в виде функций.,краткие сведения,ai,0
"пример и/или-графа сформулируем общее рекурсивное определение разрешимости вершины в и/или-графе: заключительные вершины разрешимы, так как они соответствуют элементарным задачам; или-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима по крайней мере одна из ее дочерних вершин; и-вершина, не являющаяся заключительной, разрешима тогда и только тогда, когда разрешима каждая из ее дочерних вершин.",рекурсивное определение разрешимости,ai,0
"если current неразрешима, то выход из текущей процедуры с сообщением о неуспехе, иначе перейти на следующий шаг.",следующий шаг,ai,0
вычисляемая для каждого состояния эвристическая оценка хранится как четвертый элемент списка-описания состояния.,элемент списка,ai,0
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",момент,ai,0
"если это так, то такую вершину не надо снова помещать в список open (таким образом, разрывается цикл графа-пространства и обрывается соответствующая ветвь дерева перебора).",ветвь дерева перебора,ai,0
"таким образом, число концевых вершин в дереве игры равно 9!=362880, но многие пути в этом дереве обрываются раньше на заключительных вершинах.",многие пути,ai,0
"математическое исследование алгоритма эвристического поиска, прежде всего условий, гарантирующих нахождение им решения, было проведено для эвристических оценочных функций специального вида и для более сложной задачи, чем рассматриваемая до сих пор задача поиска произвольного решающего пути до целевой вершины.",математическое исследование алгоритма,ai,0
"таким образом, в общем случае необходим процесс перебора операторов-кандидатов, каждый из которых образует свое множество результирующих задач (этот перебор и означает поиск на и/или-графе задачи).",кандидатов,ai,0
"видно, что в алгоритме поиска в глубину сначала идет поиск вдоль одного пути, пока не будет достигнута установленная граничная глубина, затем рассматриваются альтернативные пути той же или меньшей глубины, которые отличаются от первого пути лишь последней (концевой) вершиной, после чего рассматриваются пути, отличающиеся последними двумя вершинами, и т.д. рис.14.",меньшей глубины,ai,0
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",перспективность нераскрытых вершин пространства,ai,0
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",разбиения эвристическую оценочную функцию,ai,0
"в соответствии с предположениями, сделанными в предыдущем разделе, состояние задачи (конфигурация игры) представляется списком из следующих элементов: идентификатор состояния (используются атомы s1,s2,s3, ... генерируемые встроенной лисповской функцией gensym); собственно описание состояния список из номеров фишек, записанных последовательно по рядам квадрата; число-глубина состояния-вершины в дереве перебора; числовая эвристическая оценка состояния.",дереве перебора,ai,0
"таким образом, понятие информированности отражает один из аспектов понятия эвристической силы оценочной функции при поиске в пространстве состояний.",функции,ai,0
"действительно, запоминание всех альтернатив продолжения поиска (нераскрытых вершин) осуществляется в списке open, на шаге 3 производится выбор варианта-альтернативы, а возврат к этому шагу для выбора следующей альтернативы осуществляется на шагах 4 и 5.",выбор варианта,ai,0
"алгоритм перебора называют допустимым (или состоятельным), если для произвольного графа он всегда заканчивает свою работу построением оптимального пути к цели, при условии, что такой путь существует.",работу построением оптимального пути,ai,0
"эти величины необходимы для проверки условий правил отсечений, поэтому отсечения не могут быть выполнены, пока величины не определены (альфа-отсечение пока неизвестна величина bmin, а бета-отсечение пока неизвестна amaх ).",проверки,ai,0
"значит, в общем случае оператор является частично определенной функцией отображения состояний.",отображения,ai,0
[max n1 n2 ... nk] (k 2) значениями аргументов должны быть числа.,значениями,ai,0
"такой же приоритет может быть и у операторов, уменьшающих эти различия.",различия,ai,0
"действительно, в первой и в третьей задачах требуется переместить всего два диска, вторая же задача может рассматриваться как элементарная, так как ее решение состоит ровно из одного хода перемещения диска 3 на колышек с. в первой и третьей задачах можно вновь применить метод редукции задач, и свести их к элементар ным задачам.",хода перемещения,ai,0
"статическая оценочная функция, будучи применена к некоторой вершине-конфигурации игры, дает числовое значение, оценивающее различные достоинства этой игровой позиции.",значение,ai,0
"пример такой структуры приведен на рис.10(а): задача g может быть решена путем решения либо задач d1 и d2, либо e1, e2 и e3 либо задачи f. при этом ребра, относящиеся к одному и тому же множеству подзадач, связываются специальной дугой.",множеству,ai,0
"основу этого алгоритма составляет цикл последовательного раскрытия (шаги 2-5) концевых вершин (листьев) дерева перебора, хранящихся в списке open.",последовательного раскрытия,ai,0
"встроенный механизм бектрекинга позволяет упростить разработку поисковой программы, укорачивая ее текст это демонстрирует приведенная в разделе 2.4 плэнерская функция deрth first search, реализующая поиск вглубь (без ограничения глубины).",плэнерская функция,ai,0
"так же как в пространстве состояний, применяются: поиск вширь (вершины раскрываются в том порядке, в котором строились); поиск вглубь (в первую очередь раскрываются те вершины, которые были построены последними, глубина поиска обычно ограничивается); подъем на холм и эвристический поиск (выбор вершины для раскрытия производится на основе эвристических оценок вершин).",основе,ai,0
"например, в игре в пятнадцать или в восемь пространство состояний состоит из всех конфигураций фишек, которые могут быть образованы в результате возможных перемещений фишек.",результате возможных,ai,0
"в графе-пространстве состояний этому оператору обычно соответствует дуга, связывающая две практически отдельные части графа.",оператору,ai,0
"(push е v) в качестве второго аргумента этой функции (он не вычисляется) должно быть задано имя переменной, в качестве первого произвольная форма.",функции,ai,0
"именно с этим связана одна из слабостей применяемого в системе gps подхода: процедуры вычисления различий и уменьшающих их операторов должны быть отдельно реализованы для каждой конкретной задачи (или для очень узкой предметной области, включающей несколько видов задач), в противном случае снижалась эффективность решения задач.",операторов,ai,0
"жирными дугами (стрелками) показан решающий путь, состоящий из четырех операторов: перейти (тя); передвинуть (тб); взобраться; схватить.",стрелками,ai,0
"данное пособие представляет собой введение в теорию эвристического поиска один из наиболее разработанных разделов области исследований, известной под названием искусственный интеллект .",разделов области исследований,ai,0
"4.2 язык программирования плэнер в языке плэнер программа и обрабатываемые ею данные записываются в виде выражений, к которым относятся: атомы (идентификаторы и числа), обращения к переменным, состоящие из префикса и имени переменной (например, .x), и списки, представляющие собой последовательности выражений заключенные в круглые, квадратные или угловые скобки (например, [elem 1(a b c)]).",скобки,ai,0
"этот способ предлагает опреде ленную организацию перебора всех возможных вариантов решения задачи, число которых может быть велико.",организацию перебора,ai,0
"ключевая идея этой эвристики такова: поиск различий между тем, что дано в поставленной задаче, и тем, что надо получить; последовательное устранение найденных различий с помощью подходящих средств операций.",эвристики такова,ai,0
"это преобразование включает в себя, вообще говоря, проведение указателей от дочерних вершин к их родительским эти указатели необходимы для определения разрешимых и неразрешимых вершин и решающего графа (последний состоит только из разрешимых вершин).",проведение указателей,ai,0
"если для игры в пятнадцать средством формализации выступает язык программирования лисп или паскаль, то операторы задачи могут быть описаны в виде четырех соответствующих функций языка.",язык программирования,ai,0
"каждая из них получает на вход вершину goal соответствующего типа и список ее дочерних вершин glist, результат процедуры либо решающее дерево с корнем в вершине goal, либо сообщение о неуспехе (неразрешимости этой вершины).",дерево,ai,0
"отметим, что комментарием в плэнере считается любой текст между знаком процента (%) и ближайшей точкой с запятой (;).",точкой,ai,0
"2.4.3 эвристический поиск на лиспе возвращаясь вновь к языку лисп, приведем текст лисповской функции heuristic search, реализующей эвристический поиск в пространстве состояний с использованием эвристической оценочной функции est, зависящей от конкретной поисковой задачи.",состояний,ai,0
"аналогично, поиск ничейной стратегии, исходя из некоторой конкретной позиции, ведется в процессе доказательства того, что игра может быть сведена к ничьей.",ничьей,ai,0
"2.6.2 схема просмотра и/или-дерева отвлекаясь от многочисленных деталей организации поиска на и/или-графах общего вида, рассмотрим только на схему раскрытия вершин и формирования решающего дерева при поиске в графах-деревьях.",поиска,ai,0
"причины усложнения алгоритмов поиска на и/или-графах связаны с тем, что более сложной становится проверка условий окончания перебора, т.е. разрешимости исходной задачи.",графах,ai,0
"кроме того, само найденное целевое состояние может считаться решением, поскольку представляет список городов, входящих в искомый маршрут.",искомый маршрут,ai,0
(setq v e) это аналог оператора присваивания.,присваивания,ai,0
"если значение очередного из них не равно nil ( ложь ), то функция, не вычисляя оставшиеся аргументы, заканчивает свою работу со значением этого аргумента, в противном случае она переходит к вычислению следующего аргумента.",следующего аргумента,ai,0
"задача о ханойской башне эта задача легко может быть формализована в пространстве состояний: состояние задачи задается списком из трех элементов, каждый из которых указывает местоположение соответствующего диска (первый элемент первого диска, второй второго, третий третьего).",элемент,ai,0
"в комнате находятся обезьяна, ящик и связка бананов, которая подвешена к потолку настолько высоко, что обезьяна может до нее дотянуться, только встав на ящик.",связка,ai,0
"а-алгоритм эвристического поиска с функцией h(v), удовлетворяющей этому условию, получил название а -алгоритма [нильсон73, разделы 3.7-3.9; лорьер, раздел 5.6].",функцией,ai,0
"состояние, полученное в результате применения ключевого оператора op к состоянию s (s sop).",оператора,ai,0
"в вершинах графа указаны соответствующие задачи/подзадачи, заключительные вершины заключены в двойные рамки.",задачи,ai,0
"тогда начальное состояние задачи описывается списком (то, п, тя, 0), а целевое состояние задается как любой список, последний элемент которого равен 1.",начальное состояние,ai,0
"к ним относятся: атомы (значение атома - сам атом), обращения к переменным с префиксом ""."" (значением является текущее значение переменной), списки в круглых скобках (значением является список из значений элементов исходного списка) и обращения к функциям, имеющие вид [f a1 a2 ... an], где f - имя функции, а ai - ее аргументы.",список,ai,0
"в алгоритме подъема на холм , применяемом для поиска в пространстве состояний, роль функции метода подъема на гору играет эвристическая оценочная функция, взятая с обратным знаком.",подъема,ai,0
"для игры в пятнадцать или в восемь удобнее выделить четыре оператора, соответствующие перемещениям пустой клетки (фишки- пустышки ) влево, вправо, вверх, вниз.",соответствующие перемещениям пустой клетки,ai,0
"если неравенство h1(v) h2(v) верно для всех вершин пространства состояний, не являющихся целевыми, а -алгоритм, использующий эвристическую составляющую h2(v), называется более информированным, чем а -алгоритм с функцией h1(v).",вершин пространства,ai,0
"если значение очередного из них равно () ( ложь ), то функция, не вычисляя оставшиеся аргументы, заканчивает свою работу со значением (), а иначе переходит к вычислению следующего аргумента.",функция,ai,0
"глубина часто используется при подсчете эвристической оценки, поэтому будем считать, что аргументом функции est является список из двух элементов: собственно описания состояния и глубины соответствующей вершины.",элементов,ai,0
вычисленное значение формы становится значением функции f. операции над списками (car l) значением аргумента l должен быть непустой список; значением же функции является первый элемент верхнего уровня этого списка.,аргумента,ai,0
"в противоположность слепому поиску, эвристический поиск использует априорную, эвристическую информацию об общем виде пространства состояний и/или о том, где в этом пространстве расположена цель, поэтому для раскрытия обычно выбирается наиболее перспективная вершина.",перспективная вершина,ai,0
пусть h (v) стоимость оптимального пути из произвольной вершины v в целевую вершину.,вершины,ai,0
"как и при переборе в пространстве состояний, ограничение глубины может воспрепятствовать нахождению решения, но существующее в пределах ограничения решающее дерево будет найдено обязательно.",ограничение,ai,0
"для иллюстрации этого подхода рассмотрим один из вариантов известной головоломки задачи о ханойской башне, или пирамидке.",пирамидке,ai,0
"тогда начальное состояние задачи описывается списком (то, п, тя, 0), а целевое состояние задается как любой список, последний элемент которого равен 1.",элемент,ai,0
"при использовании же продук ционного языка, эти операторы задаются в виде правил продукций вида: исход ное состояние результирующее состояние (см. [нильсон73, раздел 2.2]).",состояние,ai,0
"кроме этих двух функций часто используются функции, задающие их суперпозиции.",суперпозиции,ai,0
"иначе функция запоминает развилку, альтернативами которой является то, что функция в качестве своего значения может выдать любой элемент из этого списка.",элемент,ai,0
функция присваивает этой переменной новое значение вычисленное значение формы e.,новое значение вычисленное значение,ai,0
"она может использоваться только внутри блочной функции prog, поскольку завершает вычисление ближайшей объемлющей блочной функции, устанавливая ее значение равным значению аргумента e. (go e) функция реализует переход по метке.",вычисление ближайшей,ai,0
"значением функции ab evalp (как и mm evalp) является либо вычисленная оценка позиции pos (при depth>0), либо список дочерних для pos позиций с их числовыми оценками (при depth=0).",вычисленная оценка,ai,0
"она может использоваться только внутри блочной функции prog, поскольку завершает вычисление ближайшей объемлющей блочной функции, устанавливая ее значение равным значению аргумента e. (go e) функция реализует переход по метке.",значение,ai,0
"в задаче об обезьяне и банане приоритет (значимость) различий можно установить, например, следующим образом: различие в четвертом, затем во втором, затем в третьем и первом элементах описания состояния задачи.",приоритет,ai,0
"при этом подходе производится анализ исходной задачи с целью выделения такого набора подзадач, решив которые, мы решим исходную задачу.",набора подзадач,ai,0
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",вершин список-описание,ai,0
в общем случае для полной редукции исходной задачи необходимо перепробовать несколько операторов.,задачи необходимо,ai,0
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",возврат,ai,0
определим также стоимость любого пути в графе-пространстве как сумму стоимостей входящих в путь дуг.,графе-пространстве,ai,0
"в качестве начального состояния взята та же самая конфигурация игры в восемь, что и в примере на рис.13.",конфигурация,ai,0
"к примеру, можно упорядочить операторы редукции по степени их полезности, и приписать больший приоритет операторам, соответствующим правилам интегрирования суммы и интегрирования по частям.",полезности,ai,0
"для этого используется несколько правил интегрирования, в том числе: правило интегрирования суммы функций, правило интегрирования по частям, правило вынесения постоянного множителя за знак интегрирования, а также применение алгебраических и тригонометрических подстановок и использование различных алгебраических и тригонометрических тождеств.",тригонометрических тождеств,ai,0
"встроенный механизм возвратов языка плэнер совсем не облегчает программирование других разновидностей поиска перебора вширь и эвристического поиска, и оно выполняется обычно без использования этого механизма, т.е. почти так же, как и в языках программирования без встроенного бектрекинга.",языках,ai,0
"в случае положительного исхода проверки значением функции является само проверяемое состояние, в ином случае значение равно().",значением функции,ai,0
"это отличие статических и минимаксных оценок существенно для активных , динамичных позиций игры (например, в шашках и шахматах к ним относятся конфигурации, в которых возникает угроза взятия одной или нескольких фигур).",оценок,ai,0
"если этот список пуст, функция вырабатывает неуспех, который автоматически возвращает программу к предыдущей ее развилке.",программу,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",варианта-,ai,0
"решающее дерево заканчивается на позициях, выигрышных для плюса, и содержит полную стратегию достижения им выигрыша: для каждого возможного продолжения игры, выбранного противником, в дереве есть ответный ход, приводящий к победе.",стратегию,ai,0
"представленная в решающем графе выигрышная стратегия может быть сформулирована словесно так: если в очередном ходе игрок плюс берет одну монету, то в следующем ходе минус должен взять две, а если плюс берет две монеты, то минус должен забрать одну.",очередном ходе игрок,ai,0
"2.5.1 задача о коммивояжере (лисп и плэнер) в задаче о коммивояжере состояние задачи описывается как список городов, которые коммивояжер уже посетил к настоящему моменту, и пространство состояний представляет собой дерево, причем ограниченной глубины.",состояний,ai,0
"как правило, pat это список, причем в простейшем случае его элементами являются простые образцы, к которым относятся все простые формы (атомы, обращения к переменным с префиксом ""."" и т.д.) и обращения к переменным с префиксом "" "" (например, y).",элементами,ai,0
"все рассмотренные выше лисп-функции называются селекторами, так как они выбирают определенные элементы списков.",элементы,ai,0
"описанные ниже лисп-функции для игры в восемь могут быть пригодны и для игры в пятнадцать, так как размер стороны игрового квадрата, равный 3, используется в них как глобальная переменная size.",игрового квадрата,ai,0
"кроме этих двух функций часто используются функции, задающие их суперпозиции.",функций,ai,0
"программа на лиспе представляет собой последовательность форм, и ее выполнение заключается в последовательном вычислении этих форм.",вычислении,ai,0
"в качестве возможной формы описания задач может быть взята символьная строка, содержащая запись подынтегральной функции и переменной интегрирования (если последняя не фиксирована заранее).",формы описания задач,ai,0
"видно, что поскольку каждый раз выбор вершины с минимальной оценкой производится внутри всего построенного к текущему моменту дерева перебора, то раскрываемые друг за другом вершины могут располагаться в отдаленных друг от друга частях дерева.",перебора,ai,0
"причем, поскольку множество операторов предполагается одним и тем же для всех задач/подзадач, то в их описаниях оно в явном виде может не фигурировать.",множество,ai,0
"сформулируем теперь правила прерывания перебора, или отсечения ветвей игрового дерева: перебор можно прервать ниже любой и-вершины, бета-величина которой не больше, чем альфа-величина одной из предшествующих ей или-вершин (включая корневую вершину дерева); перебор можно прервать ниже любой или-вершины, альфа-величина которой не меньше, чем бета-величина одной из предшествующих ей и вершин.",корневую вершину дерева,ai,0
"если значение очередного из них равно nil ( ложь ), то функция, не вычисляя оставшиеся аргументы, заканчивает свою работу со значением nil, а иначе переходит к вычислению следующего аргумента.",работу,ai,0
"в идеальном случае, когда известна сама оценка h (v), и она используется в качестве h(v), а -алгоритм находит оптимальный решающий путь сразу, без раскрытия ненужных вершин.",качестве,ai,0
"глубина часто используется при подсчете эвристической оценки, поэтому будем считать, что аргументом функции est является список из двух элементов: собственно описания состояния и глубины соответствующей вершины.",подсчете эвристической,ai,0
"в то же время основной механизм решения задач в системе gps не был проблемно-ориентированным: он представлял собой реализацию универсального эвристического метода решения задач, часто применяемого человеком, и известного как анализ целей и средств (means-ends analysis).",время основной,ai,0
"в таких случаях, как и во всех сложных играх, вместо нереальной задачи поиска полной игровой стратегии решается, как правило, более простая задача поиск для заданной позиции игры достаточно хорошего первого хода.",правило,ai,0
"иными словами, для ао -алгоритма верна аналогичная теорема о допустимости, гарантирующая нахождение решения с минимальной стоимостью (так называемого оптимального дерева) при условии, что дерево решения существует.",решения,ai,0
"напомним, что, как и прежде, первый элемент этого списка уникальный идентификатор состояния, второй собственно описание состояния, а третий элемент глубина соответствующей этому состоянию вершины в дереве поиска.",описание,ai,0
"тем самым в алгоритмах поиска на и/или-графах нужна более сложная организация списков открытых и закрытых вершин (вершины могут быть двух типов, и при этом для вершины каждого типа может быть уже установлена ее разрешимость или неразрешимость).",сложная организация списков,ai,0
"в таком случае список е соответствует образцу-списку pat, если у этих списков равное число элементов и если их элементы попарно соответствуют друг другу (эти соответствия проверяются последовательно слева направо).",список,ai,0
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",случай эвристического,ai,0
"в противоположность слепому поиску, эвристический поиск использует априорную, эвристическую информацию об общем виде пространства состояний и/или о том, где в этом пространстве расположена цель, поэтому для раскрытия обычно выбирается наиболее перспективная вершина.",противоположность слепому,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",процесса решения,ai,0
"вначале функция выдает как свое значение первый элемент списка и завершает на этом работу, после чего программа продолжает свои вычисления.",значение первый элемент списка,ai,0
"в этой функции поиска (как и в следующей) идентификаторы open, closed, current имеют тот же смысл, что и в рассмотренных в разделах 2.2.1 и 2.2.2 описаниях базовых алгоритмов.",алгоритмов,ai,0
"причем, как побочный эффект сопоставления, данная последова тельность, заключенная в круглые скобки, становится новым значением переменной (правда, опять же только в случае общего соответствия списка е образцу pat).",последова,ai,0
"режим возвратов, который упрощает реализацию различных поисковых алгоритмов, использующих перебор вариантов.",перебор,ai,0
"1.2 редукция задач 1.2.1 основные понятия кроме уже рассмотренного подхода представления задач в пространстве состояний для решения ряда задач возможен и другой, более сложный подход.",решения ряда задач,ai,0
"в случае положительного исхода проверки значением функции является само проверяемое состояние, в ином случае значение равно().",ином случае,ai,0
конец or-процедуры.,конец or-процедуры,ai,0
"вторая функция выполняет слияние двух упорядоченных (по невозрастанию эвристической оценки) списков состояний в результирующий упорядоченный список: (defun add depth est (dn slist) (cond ((null slist) ()) (t (cons (list (caar slist) (cadar slist) dn (est (list (cadar slist) dn)) ) (add depth est dn (cdr slist))) ) )) (defun merge (l1 l2) (cond ((null l1) l2) ((null l2) l1) ((> (car (cdddar l1)) (car(cdddar l2))) (cons (car l2) (merge l1 (cdr l2)))) (t (cons (car l1) (merge (cdr l1) l2))) )) 2.4.4 алгоритм подъема на холм на плэнере метод подъема на холм можно рассматривать как обобщение поиска в глубину, при котором на каждом шаге вглубь от некоторой вершины среди ее дочерних вершин для раскрытия выбирается наиболее перспективная вершина, т.е. с наименьшей оценкой (в классическом переборе в глубину этот выбор делается произвольно).",оценки,ai,0
обратный поиск возможен в случае обратимости операторов задачи.,обратимости операторов,ai,0
"граф игры ""последний проигрывает"" в большинстве игр, представляющих интерес, таких как шашки и шахматы, построить полные решающие деревья и найти полные игровые стратегии не представляется возможным.",большинстве,ai,0
"(defun limited depth search (startstate limdepth) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины; ) ;шаг 1: занесение начальной вершины (ее глубина равна 0):; ; в список нераскрытых вершин:; (setq open (list (list 's0 startstate 0))) ;шаг 2:; ls (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;определение глубины текущей вершины:; (setq depth (caddr current)) (cond ((is goal current) ;/шаг 6/; (return (solution current reflist)))) ;шаг 4:; (cond ((eql depth limdepth) (go ls))) ;шаг 5:раскрытие вершины, исключение повторных вершин и; ; модификация списков указателей и нераскрытых вершин:; (setq deslist (opening current)) (setq deslist (retain new deslist)) (cond ((null deslist) (go ls))) (setq open (append (add depth (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go ls) )) функция limited depth search применяет все описанные выше вспомогательные функции, а также описанную ниже функцию add depth, заносящую число dn (величину глубины) в описания всех дочерних состояний из списка dlist: (defun add depth (dn dlist) (cond ((null dlist) ()) (t (cons (list (caar dlist) (cadar dlist) dn) (add depth dn (cdr dlist))) ))) 2.4.2 поиск вглубь на плэнере для сравнения трудоемкости программирования поиска вглубь на языках лисп и плэнер приведем текст плэнерской функции deрth first search, выполняющей поиск вглубь от заданного состояния st, но без ограничения глубины (чтобы ограничить глубину, необходимо добавить в эту функцию дополнительный аргумент граничную глубину, и несколько простых действий).",сравнения трудоемкости программирования,ai,0
"то, что форма e имеет значение v, будем обозначать следующим образом: e v. программа на плэнере представляет собой последовательность форм, ее выполнение заключается в вычислении этих форм.",значение,ai,0
"теперь для обнаружения в списке reslist вершин, эквивалентных порожденному состоянию, вместо встроенной плэнерской функции memb нужна вспомогательная функция smemb.",функция,ai,0
"алгоритм равных цен представляет собой более общий вариант метода перебора вширь, при котором вершины раскрываются в порядке возрастания стоимости g(v), т.е. в первую очередь раскрывается вершина из списка нераскрытых вершин, для которой величина g имеет наименьшее значение.",алгоритм,ai,0
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",вычисление оценки очередной дочерней,ai,0
краткие сведения о языках лисп и плэнер 4.1 язык программирования лисп в языке лисп все действия описываются в виде функций.,языках,ai,0
"как и ранее, вершины, непосредственно следующие за некоторой вершиной, т.е. получившиеся в результате применения к ней допустимых операторов, будем называть дочерними, а саму исходную вершину родительской.",вершиной,ai,0
"вторая функция выполняет слияние двух упорядоченных (по невозрастанию эвристической оценки) списков состояний в результирующий упорядоченный список: (defun add depth est (dn slist) (cond ((null slist) ()) (t (cons (list (caar slist) (cadar slist) dn (est (list (cadar slist) dn)) ) (add depth est dn (cdr slist))) ) )) (defun merge (l1 l2) (cond ((null l1) l2) ((null l2) l1) ((> (car (cdddar l1)) (car(cdddar l2))) (cons (car l2) (merge l1 (cdr l2)))) (t (cons (car l1) (merge (cdr l1) l2))) )) 2.4.4 алгоритм подъема на холм на плэнере метод подъема на холм можно рассматривать как обобщение поиска в глубину, при котором на каждом шаге вглубь от некоторой вершины среди ее дочерних вершин для раскрытия выбирается наиболее перспективная вершина, т.е. с наименьшей оценкой (в классическом переборе в глубину этот выбор делается произвольно).",глубину,ai,0
"числовые индексы имен остальных вершин показывают порядок, в котором эти вершины строились алгоритмом перебора вглубь.",числовые индексы имен,ai,0
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",внутренние характеристики,ai,0
"на рис.2 показана часть пространства состояний для игры в пятнадцать: в каждой вершине помещена та конфигурация фишек, которую она представляет.",часть пространства состояний,ai,0
"значит, в этой игре возможен полный просмотр дерева и нахождение выигрышной стратегии.",стратегии,ai,0
"отметим, что таким образом определяется обычная лисп-функция, т.е. функция с фиксированным количеством аргументов, которые всегда вычисляются при обращении к ней.",количеством аргументов,ai,0
дальнейшая формализация решения задачи с использованием пространства состояний предполагает выбор некоторой конкретной формы описания состояний задачи.,пространства,ai,0
"в ней используются 3 колышка (обозначим их буквами a, b, c) и 3 диска разного диаметра, которые можно нанизывать на колышки через отверстия в центре.",диаметра,ai,0
"выбирается один из вариантов, и программа продолжает свою работу.",работу,ai,0
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",нераскрытых вершин пространства,ai,0
"предикат is goal проверяет, является ли ее аргумент целевым состоянием.",предикат,ai,0
"если просматриваемое пространство не содержит целевого состояния, результатом этой функции будет неуспех, и процесс возврата вернет управление к последней по времени развилке, возникшей перед входом в функцию deрth first search.",просматриваемое пространство,ai,0
"первое их слагаемое d(v) есть стоимость пути к вершине v при стоимости всех дуг с(va,vb)=1.",стоимость пути,ai,0
"функция вычисляет эту форму и строит новый список, первый элемент которого вычисленное значение, а хвост список, являющийся значением переменной v. результирующий список становится новым значением переменной v и значением самой функции push.",первый элемент,ai,0
"(defun breadth first search (startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; goal ;целевая вершина;) ;шаг 1:; (setq open (list (list 's0 startstate))) ;шаг 2:; вs (cond ((null open) (return ()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) ;шаги 4,5:; (setq deslist (opening current)) (cond((setq goal(check goals deslist)) (return (solution goal reflist)) )) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go bs))) (setq open (append open deslist)) ; построение указателей и занесение их в общий список:; (setq reflist (append (connect deslist current) reflist)) (go вs) )) нижеследующая лисп-функция limited depth search поиска вглубь имеет два аргумента: кроме начального состояния startstate в число ее аргументов включена граничная глубина limdepth.",глубина,ai,0
"отметим, что комментарием в плэнере считается любой текст между знаком процента (%) и ближайшей точкой с запятой (;).",знаком,ai,0
"будем далее предполагать, что задачи и подзадачи решаются в пространстве состояний и записываются как (s i, o, sg), где s i и sg соответственно начальное и целевое состояния, причем множество o операторов преобразований состояний может быть опущено в случае его постоянности (неизменности).",o операторов преобразований,ai,0
"очевидно, желательны представления с малыми пространствами состояний, но нахождение удачных представлений, сужающих пространство поиска, требует обычно некоторого дополнительного анализа решаемой задачи.",малыми пространствами состояний,ai,0
поиск в пространстве состояний можно представить как процесс постепенного раскрытия вершин и проверки свойств порождаемых вершин.,процесс постепенного раскрытия вершин,ai,0
"например, в шашках игровая позиция включает задание положений на доске всех шашек, в том числе дамок.",задание,ai,0
"процедуры поиска в пространстве состояний различаются несколькими характеристиками, основными из которых являются: использование эвристической информации; порядок раскрытия (перебора) вершин;",порядок раскрытия,ai,0
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",шагов алгоритмов слепого перебора,ai,0
"представление задач в пространстве состояний 1.1.1 основные понятия типичным представителем класса задач, для которых подходит представление в пространстве состояний, является головоломка, известная как игра в пятнадцать см. рис.1(а).",типичным представителем,ai,0
"для этого используется несколько правил интегрирования, в том числе: правило интегрирования суммы функций, правило интегрирования по частям, правило вынесения постоянного множителя за знак интегрирования, а также применение алгебраических и тригонометрических подстановок и использование различных алгебраических и тригонометрических тождеств.",использование различных,ai,0
"заметим, что поиск вглубь можно рассматривать как частный случай эвристического поиска с оценочной функцией est(v) = d(v) , а поиск вширь с оценочной функцией est(v) = 1/d(v) , где d(v) глубина вершины v. чтобы модифицировать рассмотренный алгоритм для перебора на произвольных графах-пространствах состояний, необходимо предусмотреть в нем реакцию на случай построения дочерних вершин, которые уже имеются либо в списке раскрытых, либо в списке нераскрытых вершин.",перебора,ai,0
функция по очереди вычисляет свои аргументы.,функция,ai,0
"в качестве возможной формы описания задач может быть взята символьная строка, содержащая запись подынтегральной функции и переменной интегрирования (если последняя не фиксирована заранее).",качестве возможной формы описания,ai,0
основные шаги базового алгоритма ограниченного поиска вглубь (с граничной глубиной d) таковы: шаг 1.,базового алгоритма,ai,0
"для формализации и изучения игровых стратегий в классе игр с полной информацией может быть использован подход, основанный на редукции задач.",стратегий,ai,0
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",вычисление оценки,ai,0
"функции is goal и opening можно определить так: (defun is goal (state) (eq (car(last state) 'a))) (defun opening (state) (prog (dlist ;список формируемых дочерних состояний; townl townn; последний и следующий город маршрута; new roads ; списки дорог между городами; ) (setq roads '((a b)(a d)(a e)(a g)(b d)(b c)(c d)(c h) (d e)(d h)(e g)(h g)(e h))) ; расширение списка путей(дорог) между городами: (setq roads (add ways roads)) ; последний город маршрута: (setq townl (car(last state))) ; цикл поиска соседних с городом townl городов, в которые ; может вести маршрут: opc (setq new (find townl roads)) (cond ((null new) (return dlist))) (setq townn (car new)) (setq roads (cadr new)) (cond ((or (and (eq townn 'a)(eql (length state)7)) (not (member townn state)) ) (setq dlist (cons(append state(list townn)) dlist)))) (go opc) )) так как наличие дороги (пути) между городами x и y означает также наличие пути между y и x, то первоначальный список дорог между городами должен быть расширен симметричными связями-путями это выполняет вспомогательная функция add ways: (defun add ways (rlist) (cond ((null rlist) ()) (t (cons (car rlist) (cons (list (cadar rlist) (caar rlist)) (add ways(cdr rlist))) )))) вспомогательная функция find выполняет поиск города-соседа для заданного города town: (defun find (town roads) (cond ((null roads) ()) ((eq town (caar roads)) (list (cadar roads)(cdr roads)) ) (t (find town (cdr roads))) )) приведем теперь для сравнения реализацию функций is goal и opening на языке плэнер для их применения в функции depth first search поиска вглубь.",городами,ai,0
"двойной рамкой обведена найденная целевая вершина, она построена двенадцатой.",двенадцатой,ai,0
"значением функции alpha beta является дочерняя для instate вершина-позиция, соответст вующая наилучшему ходу.",вершина,ai,0
"заметим, что оценки всех вершин этой ветви дерева совпадают, и оценка начальной вершины равна оценке концевой вершины этой ветви.",оценки,ai,0
"найденный путь не обязательно оптимален (возможно, существует более дешевый, еще не найденный путь из начальной вершины в v), однако стоимость найденного пути может быть использована в качестве оценки искомого пути минимальной стоимости из начальной вершины до v, т.е. в качестве первого слагаемого g(v) эвристической функции.",качестве первого,ai,0
"задача о коммивояжере: схема дорог между городами состояние решаемой задачи можно задать как список городов, которые коммивояжер уже посетил к текущему моменту.",состояние,ai,0
"например, если для игры в восемь в качестве второй составляющей эвристической функции взять h(v)=2 s(v), то в ряде случаев такая функция будет убыстрять поиск и позволит решать более трудные задачи, но условие допустимости перестанет выполняться (так как для начального состояния на рис.15: h (v) 2 s(v) ).",функция,ai,0
"алгоритмы же упорядоченного перебора с применением эвристик не настолько уменьшают просматриваемую часть дерева игры, чтобы дать существенное, на несколько порядков, сокращение времени поиска.",применением эвристик,ai,0
"(defun heuristic search(startstate) (prog (open closed current deslist ;список дочерних вершин; reflist ;список указателей; depth ;глубина текущей вершины;) ;шаг 1:; (setq open (list(list 's0 startstate 0 (est (list startstate 0)) ))) ;шаг 2:; hs (cond ((null open) (return()))) ;шаг 3:; (setq current (car open)) (setq open (cdr open)) (setq closed (cons current closed)) (setq depth (caddr current)) ;шаг 4:; (cond ((is goal current) (return (solution current reflist)))) ;шаг 5:; (setq deslist (opening current)) ; исключение повторных вершин-состояний:; (setq deslist (retain new deslist)) (cond ((null deslist) (go нs))) ;шаг 6:; (setq open (merge (add depth est (add1 depth) deslist) open)) (setq reflist (append (connect deslist current) reflist)) (go hs) )) данная лисповская функция использует (как и ранее рассмотренные функции breadth first search и limited depth search) вспомогательные функции opening, solution, is goal, connect, est (которые зависят от конкретной поисковой задачи) и ранее определенную функцию retain new, а также еще две вспомогательные функции add depth est и merge.",поисковой задачи,ai,0
"2.3.2 допустимость алгоритма эвристического поиска важным является вопрос, может ли алгоритм эвристического перебора с оценочной функций общего вида (на которую не накладывается никаких ограничений) гарантировать нахождение решающего пути за конечное число шагов в тех случаях, когда решение существует (как это гарантирует алгоритм поиска вширь).",решение,ai,0
"поскольку глубина перебора в функции deрth first search никак не ограничена, то окончание работы алгоритма гарантировано только в случае поиска в ограниченных пространствах состояний.",поиска,ai,0
"если затем окажется, что этот вариант неуспешен, тогда вырабатывается т.н. неуспех, по которому программа автоматически откатывается к последней (по времени) развилке, отменяя при этом все изменения (в значениях переменных и т.п.), произведенные на неуспешном пути, и в этой развилке выбирается следующий вариант, после чего программа снова идет вперед .",вариант,ai,0
значением аргумента функции go должен быть идентификатор одна из меток ближайшей объемлющей блочной функции.,значением,ai,0
2.2.2 поиск вглубь для формулировки алгоритма поиска вглубь необходимо определить понятие глубины вершины в дереве поиска.,вершины,ai,0
"если глубина вершины current равна граничной глубине d, то перейти к шагу 2, в ином случае перейти к следующему шагу.",ином случае,ai,0
"поэтому в случае программирования этой задачи на языке лисп можно упростить соответствующие лисп-функции слепого поиска, например, breadth first search, обойдясь без указателей и идентификаторов вершин, а также без функций solution, connect и retain new.",случае программирования,ai,0
"исключение составляет случай, когда множество задач состоит только из одного элемента, в этом случае будет образована ровно одна вершина, будем для определенности считать ее или-вершиной.",вершиной,ai,0
"она может использоваться только внутри блочной функции prog, поскольку завершает вычисление ближайшей объемлющей блочной функции, устанавливая ее значение равным значению аргумента e. (go e) функция реализует переход по метке.",блочной функции,ai,0
дальнейшая формализация решения задачи с использованием пространства состояний предполагает выбор некоторой конкретной формы описания состояний задачи.,дальнейшая формализация решения задачи,ai,0
"при решении задач методом редукции, как и при решении в пространстве состояний, может возникнуть необходимость перебора.",методом,ai,0
"для задачи v(xs) схема сведения игровых задач к подзадачам аналогична: ходам игрока плюс будут соответствовать и-вершины, а ходам минуса или-вершины, заключительные же вершины будут соответство вать позициям, выигрышным для игрока минус.",позициям,ai,0
"примеры списков: (()(a b 1(c))class) (45 89 (()())) пустой список () имеет в лиспе и другое обозначение nil, причем он одновременно относится и к атомам, и к спискам.",атомам,ai,0
"в графе, показанном на рис.11, начальной является вершина p0, а заключительными вершины p1, p4, p5, p7 и p8 (они изображены жирными кружками).",кружками,ai,0
"каждая из них получает на вход вершину goal соответствующего типа и список ее дочерних вершин glist, результат процедуры либо решающее дерево с корнем в вершине goal, либо сообщение о неуспехе (неразрешимости этой вершины).",результат,ai,0
функция производит поиск заданного атома на верхнем уровне заданного списка.,функция,ai,0
"поэтому в случае программирования этой задачи на языке лисп можно упростить соответствующие лисп-функции слепого поиска, например, breadth first search, обойдясь без указателей и идентификаторов вершин, а также без функций solution, connect и retain new.",функции,ai,0
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",оценок промежуточных,ai,0
.dst)] [cond ([is goal .dst] [return .reslist]) (t [go cs])] ])] эта функция является усложнением ранее рассмотренной плэнерской функции depth first search (добавлено обращение к функции q sort).,функция,ai,0
"алгоритмы поиска формулируются проще для и/или-графов, являющихся деревьями: при этом организация перебора значительно упрощается, поскольку любая задача (цель) может встретиться в таком графе-дереве ровно один раз.",поиска,ai,0
"этот элемент нужен, чтобы исключить тривиальные (см. раздел 2.2.1) повторы состояний при раскрытии вершин.",элемент нужен,ai,0
"цель поиска на и/или-графе показать, что разрешима исходная задача, т.е. начальная вершина.",вершина,ai,0
"предполагается, что обезьяна может ходить по комнате, двигать по полу ящик, взбираться на него и хватать бананы.",полу ящик,ai,0
"редукция игровых задач последовательное применение к исходной конфигурации игры данной схемы редукции порождает и/или-дерево (и/или-граф), которое называют деревом (графом) игры.",исходной конфигурации игры,ai,0
"значением функции является n-й от начала элемент этого списка, причем элементы списка нумеруются, начиная с 0.",элементы,ai,0
функция solution с двумя аргументами найденным целевым состоянием и списком всех указателей дерева перебора вырабатывает список-решение задачи (решающий путь).,аргументами,ai,0
"вырабатываемое функцией значение это дочерняя для instate позиция, соответствующая искомому наилучшему ходу.",позиция,ai,0
"в подобных случаях свойство, которому должно удовлетворять целевое состояние, должно быть описано исчерпывающим образом, к примеру, путем задания булевской функции, реализующей проверку нужного свойства состояния задачи.",подобных случаях свойство,ai,0
"это же значение является значением и самой функции setq, однако оно, как правило, не используется.",значение,ai,0
"процесс редукции продолжается, пока исходная задача не будет сведена к набору элементарных задач, решение которых известно.",набору,ai,0
"действительно, во второй функции вклад каждой фишки в общую оценку-сумму s(v) либо равен 0 (фишка стоит уже на своем месте), либо не меньше 1 (в противном случае), в первой же функции этот вклад в k(v) соответственно либо равен 0, либо равен 1.",общую оценку-сумму,ai,0
"именно с этим связана одна из слабостей применяемого в системе gps подхода: процедуры вычисления различий и уменьшающих их операторов должны быть отдельно реализованы для каждой конкретной задачи (или для очень узкой предметной области, включающей несколько видов задач), в противном случае снижалась эффективность решения задач.",процедуры вычисления различий,ai,0
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",оценок,ai,0
"перечисленные составляющие задают неявно граф-пространство состояний, в котором необходимо найти решение задачи.",решение задачи,ai,0
"3.3 альфа-бета процедура в минимаксной процедуре процесс построения частичного дерева игры отделен от процесса оценивания вершин, и это приводит к тому, что в целом минимаксная процедура оказывается неэффективной стратегией поиска хорошего первого хода.",процесса оценивания вершин,ai,0
методы поиска реше ний: пер. с англ.,методы,ai,0
"операторы могли включать предусловия (условия применимости), выполнение которых было необходимо для их успешного применения, в этом случае gps сводила исходную задачу к задаче достижения нужного условия.",условия,ai,0
6 (диски перенумерованы в порядке возрастания диаметра).,порядке,ai,0
"данное пособие представляет собой введение в теорию эвристического поиска один из наиболее разработанных разделов области исследований, известной под названием искусственный интеллект .",области исследований,ai,0
"он вычисляется по формуле p = l / n , где l длина найденного пути до цели (она равна глубине целевой вершины); n общее число вершин, построенных в ходе перебора.",равна глубине,ai,0
2.2.1 поиск вширь базовый алгоритм поиска вширь состоит из следующей последова тельности шагов: шаг 1.,базовый алгоритм,ai,0
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",проверка,ai,0
"ясно, что описание состояния этой задачи должно включать следующие сведения: местоположение обезьяны в комнате в горизонтальной плоскости пола и по вертикали (т.е. на полу она или на ящике), местоположение ящика на полу и наличие у обезьяны бананов.",следующие сведения,ai,0
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",дерева,ai,0
"пусть целью поиска будет не просто нахождение решающего пути, а нахождение оптимального решающего пути решающего пути с минимальной стоимостью.",пути решающего,ai,0
"схематическое изображение редукции задач если считать, что вершины d и e соответствуют описаниям альтернативных путей решения исходной задачи, то вершину g можно назвать или-вершиной, так как задача g разрешима или способом d, или способом e, или способом f. аналогично вершины d и e можно назвать и-вершинами, поскольку каждый из соответствующих им способов требует решения всех подчиненных задач, что и обозначается специальной дугой.",изображение редукции,ai,0
"в идеальном случае, когда известна сама оценка h (v), и она используется в качестве h(v), а -алгоритм находит оптимальный решающий путь сразу, без раскрытия ненужных вершин.",вершин,ai,0
"для этого могут применяться любые подходящие структуры строки, массивы, списки, деревья и т.п. например, для игры в пятнадцать или восемь наиболее естественной формой описания состояния будет двумерный массив.",естественной формой описания состояния,ai,0
"в алгоритме подъема на холм , применяемом для поиска в пространстве состояний, роль функции метода подъема на гору играет эвристическая оценочная функция, взятая с обратным знаком.",алгоритме подъема,ai,0
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",последовательность шагов формулируемого ниже,ai,0
"блочная и связанные с ней функции (prog (v1 v2 ... vn) e1 e2 ... ek) (n 0, k 1) эту специальную функцию называют блочной , поскольку ее вычисление напоминает выполнение блоков в других языках программирования.",специальную функцию,ai,0
"часто используются также дополнительные эвристические приемы в самой альфа-бета процедуре [слейгл, глава 2; нильсон 73, раздел 5.14]: направленное (эвристическое) отсечение неперспективных ветвей: например, построение дерева игры обрывается на пассивных позициях и к ним применяется статическая оценочная функция, для активных же позиций поиск продолжается дальше до нужной глубины или даже глубже, поскольку на это можно использовать время, сэкономленное вследствие отсечения ветвей; последовательное углубление, при котором альфа-бета процедура применяется неоднократно: сначала до некоторой небольшой глубины (например, 2), а затем глубина увеличивается с каждой итерацией, причем после каждой итерации выполняется переупорядочение всех дочерних вершин с тем, чтобы увеличить число отсечений в последующих итерациях; фиксированное упорядочение вершин при спуске-построении дерева вглубь, при котором в первую очередь строится и раскрывается дочерняя вершина, оцениваемая как более перспективная (эта оценка может быть проведена как с помощью статической оценочной функции, так и более простой, хотя и менее надежной эвристической функции); динамическое упорядочение вершин, при котором каждый раз после уточнения минимаксных оценок и проведения отсечений производится переупорядочивание вершин во всем построенном к текущему моменту дереве (с помощью некоторой эвристической функции) и для дальнейшего раскрытия выбирается наиболее перспективная вершина (заметим, что по существу это означает переход от классического перебора вглубь к алгоритму упорядочен ного перебора на и/или-графах).",переупорядочивание,ai,0
"таким образом, в общем случае необходим процесс перебора операторов-кандидатов, каждый из которых образует свое множество результирующих задач (этот перебор и означает поиск на и/или-графе задачи).",случае необходим процесс перебора,ai,0
"если же решающего пути нет, то в случае конечного пространства состояний алгоритм завершит работу (с сообщением о неудаче поиска), в случае же бесконечного пространства алгоритм не остановится.",пространства состояний алгоритм,ai,0
"действительно, в первой и в третьей задачах требуется переместить всего два диска, вторая же задача может рассматриваться как элементарная, так как ее решение состоит ровно из одного хода перемещения диска 3 на колышек с. в первой и третьей задачах можно вновь применить метод редукции задач, и свести их к элементар ным задачам.",колышек с.,ai,0
"после прерывания перебора предварительные оценки вершин в точках отсечения остаются неуточненными, но, как уже отмечалось, это не препятствует правильному нахождению предварительных оценок всех предшествующих вершин, как и точной оценки корневой вершины и ее дочерних вершин, а значит, и искомого наилучшего первого хода.",точной оценки корневой вершины,ai,0
"в пособии рассматриваются два подхода к решению задач и, соответственно, два способа представления подход с использованием пространства состояний и подход, основанный на редукции задач.",способа,ai,0
"вспомогательные функции opening и is goal зависят от конкретной решаемой задачи, а вспомогательная функция q sort выполняет упорядочение (по неубыванию их оценок) порожденных дочерних вершин (q sort реализует алгоритм быстрой сортировки).",дочерних вершин,ai,0
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",простая модификация,ai,0
"(heuristic search initstate) )) 2.6 поиск на и/или-графах 2.6.1 особенности поиска и/или-граф, называемый также графом целей (задач), неявно задается при формализации задачи с использованием метода редукции, путем описания исходной задачи, операторов сведения задачи к подзадачам и множества элементарных задач.",задачи,ai,0
"если неравенство h1(v) h2(v) верно для всех вершин пространства состояний, не являющихся целевыми, а -алгоритм, использующий эвристическую составляющую h2(v), называется более информированным, чем а -алгоритм с функцией h1(v).",функцией,ai,0
"однако этот случай соответствует полному отсутствию какой-нибудь эвристической информации о задаче, и оценочная функция est не имеет никакой эвристической силы, т.е. не сокращает возникающий перебор.",информации,ai,0
"для иллюстрации этого подхода рассмотрим один из вариантов известной головоломки задачи о ханойской башне, или пирамидке.",подхода рассмотрим,ai,0
после этого функция последовательно вычисляет остальные свои аргументы формы ei.,функция,ai,0
"применяемая оценочная функция такова, что при прочих равных преимущество имеет менее глубокая вершина.",функция такова,ai,0
в этом случае происходит возврат к текущей развилке для выбора следующей дочерней вершины.,выбора следующей,ai,0
"второе же слагаемое h(v) может быть предложено исходя из эвристических соображений, свойственных конкретной решаемой задаче, как некоторая характеристика-оценка текущей вершины v (близости ее к цели).",вершины,ai,0
"как правило, в начале программы определяются новые функции, а затем следуют обращения к ним.",новые функции,ai,0
"для иллюстрации этого подхода рассмотрим один из вариантов известной головоломки задачи о ханойской башне, или пирамидке.",ханойской башне,ai,0
"что касается формы описания задач/подзадач, то часто их удобно описывать в терминах пространства состояний, т.е. задавая начальное состояние и множество операторов, а также целевое состояние или его свойства.",терминах,ai,0
"(last l) значением функции является список из одного элемента последнего элемента верхнего уровня списка-аргумента l. например, если переменная x имеет своим значением список (p(q r)), а переменная y список (t), то значение формы (cons x y) равно ((p(q r))t), значение формы (list x y) равно ((p(q r))(t)), значение формы (append x y) равно (p(q r) t); значение формы (last x) равно ((q r)).",элемента,ai,0
"к примеру, если переменная x имеет своим значением список (p(q r)7), то значение формы (nth 2 x) равно 7, так же как и значение формы (caddr x).",список,ai,0
"2.6.2 схема просмотра и/или-дерева отвлекаясь от многочисленных деталей организации поиска на и/или-графах общего вида, рассмотрим только на схему раскрытия вершин и формирования решающего дерева при поиске в графах-деревьях.",графах-деревьях,ai,0
"были доказаны важные свойства этого алгоритма, прежде всего, утверждение о его допустимости.",допустимости,ai,0
"возврат же к предыдущей по времени возникновения развилке (т.е. точке бектрекинга, организованной на предыдущем шаге цикла и лежащей на один шаг вверх в дереве перебора) будет инициирован самой функцией among в двух следующих случаях.",самой функцией,ai,0
язык лисп для персональных эвм.,язык лисп,ai,0
"именно эти указатели позволят восстановить путь назад к начальной вершине после того, как будет построена целевая вершина.",указатели,ai,0
x a) .state]]] [define opening (state) [prog ((roads ((a b)(a d)(a e)(a g)(b d)(b c) (c d)(c h)(d e)(d h)(e g)(h g)(e h))) town x y z (dlist()) %список дочерних состояний; ),список дочерних,ai,0
"функции is goal и opening можно определить так: (defun is goal (state) (eq (car(last state) 'a))) (defun opening (state) (prog (dlist ;список формируемых дочерних состояний; townl townn; последний и следующий город маршрута; new roads ; списки дорог между городами; ) (setq roads '((a b)(a d)(a e)(a g)(b d)(b c)(c d)(c h) (d e)(d h)(e g)(h g)(e h))) ; расширение списка путей(дорог) между городами: (setq roads (add ways roads)) ; последний город маршрута: (setq townl (car(last state))) ; цикл поиска соседних с городом townl городов, в которые ; может вести маршрут: opc (setq new (find townl roads)) (cond ((null new) (return dlist))) (setq townn (car new)) (setq roads (cadr new)) (cond ((or (and (eq townn 'a)(eql (length state)7)) (not (member townn state)) ) (setq dlist (cons(append state(list townn)) dlist)))) (go opc) )) так как наличие дороги (пути) между городами x и y означает также наличие пути между y и x, то первоначальный список дорог между городами должен быть расширен симметричными связями-путями это выполняет вспомогательная функция add ways: (defun add ways (rlist) (cond ((null rlist) ()) (t (cons (car rlist) (cons (list (cadar rlist) (caar rlist)) (add ways(cdr rlist))) )))) вспомогательная функция find выполняет поиск города-соседа для заданного города town: (defun find (town roads) (cond ((null roads) ()) ((eq town (caar roads)) (list (cadar roads)(cdr roads)) ) (t (find town (cdr roads))) )) приведем теперь для сравнения реализацию функций is goal и opening на языке плэнер для их применения в функции depth first search поиска вглубь.",следующий город маршрута,ai,0
тогда оптимальность найденного алгоритмом решения будет гарантирована.,решения,ai,0
"(push е v) в качестве второго аргумента этой функции (он не вычисляется) должно быть задано имя переменной, в качестве первого произвольная форма.",произвольная форма,ai,0
при максимальном числе отсечений строится и оценивается мини мальное число концевых вершин.,вершин,ai,0
"слепой поиск на и/или-дереве, как и в пространстве состояний, неэффективен, поэтому предпочтителен алгоритм эвристического поиска, при котором для очередного раскрытия выбирается наиболее перспективная вершина в дереве перебора, точнее, перспективная вершина в поддереве, являющемся кандидатом на решающее дерево.",пространстве,ai,0
"[define q sort (list) [prog (el parts) [cond ([fin el list] [return ()] )] [set parts [do parts .el .list]] (<q sort [1 .parts]> .el <q sort [2 .parts]>) ]] [define do parts (el list) [prog ( e (p1 ()) key (p2 ()) ) [set key [est .el]] d [cond ([fin e list] [return (.p1 .p2)] ([gt .key [est .e]] [set p1 (.e !.p1)]) (t [set p2 (.e !.p2)] )] [go d] ]] 2.5 решения модельных задач рассмотрим теперь реализацию вспомогательных функций opening, solution, is goal, connect для примеров представлений задач в простран стве состояний, рассмотренных в первой главе.",функций,ai,0
программирование на языке пролог для искусст венного интеллекта: пер. с англ.,искусст,ai,0
"схематическое изображение редукции задач если считать, что вершины d и e соответствуют описаниям альтернативных путей решения исходной задачи, то вершину g можно назвать или-вершиной, так как задача g разрешима или способом d, или способом e, или способом f. аналогично вершины d и e можно назвать и-вершинами, поскольку каждый из соответствующих им способов требует решения всех подчиненных задач, что и обозначается специальной дугой.",путей решения исходной,ai,0
"очевидно, желательны представления с малыми пространствами состояний, но нахождение удачных представлений, сужающих пространство поиска, требует обычно некоторого дополнительного анализа решаемой задачи.",поиска,ai,0
"отметим также, что значение, присвоенной переменной, может быть использовано в оставшейся части образца-списка: [is (a x .x a) (a b b a)] t и x:= b, [is (a x .x a) (a b a a)] () и x не меняет значения.",значения,ai,0
"заметим, что часть получаемых таким образом операторов редукции (как, например, операторы, соответствующие правилу интегрирования по частям или правилу интегрирования суммы функций), действительно редуцируют исходную задачу и порождают и-вершину в и/или-графе, в то время как алгебраические и тригонометрические подстановки и тождества (как, например, деление числителя на знаменатель или дополнение до полного квадрата) лишь заменяют одно подынтегральное выражение на другое, порождая, таким образом, или-вершины.",интегрирования,ai,0
"таким образом, в подходе к решению задачи с использованием пространства состояний задача рассматривается как тройка (s i , o, sg) , где si начальное состояние; o конечное множество операторов, действующих на не более чем счетном множестве состояний; sg целевое состояние.",использованием пространства состояний,ai,0
"на каждом шаге рекурсии она оценивает вершину-позицию position, находящуюся на глубине depth и имеющую тип deptype: ""или"" при deptype=т и ""и"" при deptype=().",позицию,ai,0
"если это так, то такую вершину не надо снова помещать в список open (таким образом, разрывается цикл графа-пространства и обрывается соответствующая ветвь дерева перебора).",список,ai,0
"вообще же, нередка ситуация, когда эвристика, сильно сокращающая перебор для одних задач (начальных и целевых состояний), в то же время для других задач либо не уменьшает перебор (решение задачи может искаться даже дольше, чем с использованием слепого поиска), либо вовсе не обеспечивает обнаружение решающего пути.",нередка,ai,0
"описание каждого состояния задается списком, первый элемент которого это уникальный идентификатор состояния (число или атом), а второй элемент собственно описание состояния задачи.",задачи,ai,0
"последняя процедура (или таблица) должна также устанавливать приоритет различий и операторов, т.е. порядок их выбора в случаях, когда выявлено несколько различий и возможно применение нескольких ключевых операторов.",таблица,ai,0
"как и в случае поиска в пространстве состояний, все алгоритмы перебора на и/или-графе можно описать, опираясь на операцию раскрытия очередной вершины графа, означающую применение к ней (точнее, к соответствующему состоянию) всех возможных операторов редукции, порождающих дочерние вершины.",операцию раскрытия очередной вершины,ai,0
"успешно или нет завершилось вычисление очередного выражения программы, далее будет вычисляться следующее выражение.) в каких местах программы ставить развилки и с какими альтернативами, считать ли выбранный путь вычисления неуспешным и когда вырабатывать неуспех за все это отвечает автор программы.",выбранный путь,ai,0
"причем, как побочный эффект сопоставления, данная последова тельность, заключенная в круглые скобки, становится новым значением переменной (правда, опять же только в случае общего соответствия списка е образцу pat).",общего соответствия,ai,0
"заметим, что если у некоторой вершины и/или-графа имеется ровно одна дочерняя вершина, то последнюю можно считать как и вершиной, так и или-вершиной такова, например, вершина f на рис.10(б).",вершина f,ai,0
"видно, что в алгоритме поиска в глубину сначала идет поиск вдоль одного пути, пока не будет достигнута установленная граничная глубина, затем рассматриваются альтернативные пути той же или меньшей глубины, которые отличаются от первого пути лишь последней (концевой) вершиной, после чего рассматриваются пути, отличающиеся последними двумя вершинами, и т.д. рис.14.",вершинами,ai,0
"при этом структура на рис.10(а) преобразуется в структуру, изображенную на рис.10(б): для двух из трех альтернативных множеств подзадач добавлены соответственно вершины d и e. рис.",структуру,ai,0
в вершинах дерева помещены соответствующие описания состояний.,соответствующие описания,ai,0
"требуется переместить все диски на колышек с, соблюдая следующие правила.",колышек,ai,0
"практическое значение этой теоремы в том, что для допустимости а алгоритма достаточно найти какую-либо нижнюю грань функции h (v) и использовать ее в качестве h(v)",практическое значение,ai,0
"в вершинах графа указаны соответствующие задачи/подзадачи, заключительные вершины заключены в двойные рамки.",вершинах,ai,0
ниже приводятся тексты лисп-функций breadth first search (поиска вширь) и limited depth search (огра ниченного поиска вглубь) от начального состояния startstate.,тексты лисп-функций,ai,0
"у этой традиции, сложившейся почти за 30 лет существования теории эвристического поиска, существует важная причина.",важная причина,ai,0
"(list e1 e2 ... en) (n 1) эта функция имеет произвольное количество аргументов, из значений которых она строит список (количество элементов на верхнем уровне результирующего списка равно количеству аргументов).",произвольное количество,ai,0
реализация этого алгоритма на языке плэнер приводится в следующем разделе настоящей главы.,плэнер,ai,0
"при первом обращении к функции ab evalp (внутри функции alpha beta) смысл ее аргументов такой: исходная позиция pos (т.е. корневая вершина) имеет тип т, находится на глубине 0, величины amax и bmin неизвестны.",корневая вершина,ai,0
"это преобразование включает в себя, вообще говоря, проведение указателей от дочерних вершин к их родительским эти указатели необходимы для определения разрешимых и неразрешимых вершин и решающего графа (последний состоит только из разрешимых вершин).",указателей,ai,0
"таким образом, в общем случае необходим процесс перебора операторов-кандидатов, каждый из которых образует свое множество результирующих задач (этот перебор и означает поиск на и/или-графе задачи).",процесс,ai,0
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",зацикливания,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",другие альтернативы,ai,0
"будем придерживаться общепринятого соглашения, по которому значение статической оценочной функции тем больше, чем больше преимуществ имеет игрок плюс (над игроком минус) в оцениваемой позиции.",значение статической,ai,0
поэтому равно подходящими являются все алгоритмы слепого поиска перебор вширь и вглубь (даже без ограничения глубины).,поиска перебор,ai,0
"рассмотрим теперь функции, называемые конструкторами: они строят новый список, который и выдают в качестве своего результата.",функции,ai,0
"если аргументы равны, то значение функции равно t, иначе nil.",функции,ai,0
"таким образом, число концевых вершин в дереве игры равно 9!=362880, но многие пути в этом дереве обрываются раньше на заключительных вершинах.",вершин,ai,0
"[hasval v] значением аргумента должно быть имя переменной, существующей в данный момент (ею может быть, например, локальная переменная объемлющего блока).",аргумента,ai,0
"если список glist не пуст, то перейти на шаг 3, в ином случае закончить текущую процедуру, выдав в качестве результата сформированный решающий граф для задачи-цели goal .",качестве результата сформированный,ai,0
установить в качестве решающего графа для задачи goal саму эту вершину и перейти на следующий шаг.,следующий шаг,ai,0
"заметим попутно, что язык плэнер, по сравнению с прологом, предлагает более гибкие средства управления бектрекингом, краткое описание этих средств находится в разделе 4.2 пособия.",прологом,ai,0
"оценим размер полного дерева игры: начальная вершина имеет 9 дочерних вершин, каждая из которых в свою очередь имеет 8 дочерних; каждая вершина глубины 2 имеет 7 дочерних и т.д.",дерева,ai,0
"оценим размер полного дерева игры: начальная вершина имеет 9 дочерних вершин, каждая из которых в свою очередь имеет 8 дочерних; каждая вершина глубины 2 имеет 7 дочерних и т.д.",вершина глубины,ai,0
"алгоритмы поиска формулируются проще для и/или-графов, являющихся деревьями: при этом организация перебора значительно упрощается, поскольку любая задача (цель) может встретиться в таком графе-дереве ровно один раз.",организация,ai,0
"впрочем, если оценочная функция учитывает только внутренние характеристики вершин-состояний, то для предотвращения зацикливания требуется более простая модификация алгоритма надо просто исключить дублирование состояний в списках open и closed, оставляя в них лишь по одному состоянию (именно этот простой способ и реализован во всех лисп-алгоритмах поиска раздела 2.4).",дублирование,ai,0
"если затем окажется, что этот вариант неуспешен, тогда вырабатывается т.н. неуспех, по которому программа автоматически откатывается к последней (по времени) развилке, отменяя при этом все изменения (в значениях переменных и т.п.), произведенные на неуспешном пути, и в этой развилке выбирается следующий вариант, после чего программа снова идет вперед .",значениях,ai,0
"в исходной точке процесса к начальному состоянию применяется тот или иной оператор и строится новая вершина-состояние, а также дуги, связывающие ее с корневой вершиной.",вершиной,ai,0
"игровое дерево, построенное альфа-бета процедурой продолжим для нашего примера процесс поиска в глубину с одновременным вычислением предварительных (и точных, где это возможно) оценок вершин вплоть до момента, когда построены уже вершины w4 , w5+ и две дочерних последней, которые оцениваются статической функцией.",вершин,ai,0
"причины усложнения алгоритмов поиска на и/или-графах связаны с тем, что более сложной становится проверка условий окончания перебора, т.е. разрешимости исходной задачи.",исходной задачи,ai,0
"на самом же деле фишки часто не могут двигаться по кратчайшей траектории из-за того, что на ней расположены другие фишки, поэтому длина (стоимость) оптимального решения h (v) будет не меньше s(v).",деле фишки,ai,0
в разделе 2.4 настоящей главы приводится реализация этих алгоритмов на языке программирования лисп [семенов].,настоящей главы,ai,0
"представление задач в пространстве состояний 1.1.1 основные понятия типичным представителем класса задач, для которых подходит представление в пространстве состояний, является головоломка, известная как игра в пятнадцать см. рис.1(а).",головоломка,ai,0
"[define ab evalp (lambda (pos depth deptype amax bmin) [prog (d (movelist ()) pvalue dvalue) % 1: установка развилки из всех дочерних для pos вершин (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .pos> ())]] % 2: если развилка закрыта, то возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue)] ] )] % 3: проверка возможности отсечения и отсечение - возврат на предыдущий уровень рекурсии (встроенная функция permex реализует досрочный выход с заданным значением из заданной функции, при этом уничтожает все развилки, возникшие после входа в заданную функцию); [cond ([and [neq .depth 0] [hasval pvalue]] [cond (.deptype [cond ([and [num .bmin] [ge .pvalue .bmin]] [permex .pvalue ab evalp]) ]) (t [cond ([and [num .amax] [le .pvalue .amax]] [permex .pvalue ab evalp])] )])] % 4: вычисление оценки очередной дочерней вершины: либо применение статической оценочной функции, либо рекурсивное обращение к рассматриваемой функции; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [ab evalp .d [+ 1 .depth] [not .deptype] [cond ([and [hasval pvalue] .deptype] [cond ([num .amax] [max .amax .pvalue]) (t .pvalue)]) (t .amax)] [cond ([and [hasval pvalue] [not .deptype]] [cond ([num .bmin] [min .bmin .pvalue]) (t .pvalue) ]) (t .bmin)] ]] )] % 5: пересчет предварительной оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue])] ]) (t [pset pvalue .dvalue] )] % 6: в случае исходной позиции пересчитываем список ходов (дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",список,ai,0
"(heuristic search initstate) )) 2.6 поиск на и/или-графах 2.6.1 особенности поиска и/или-граф, называемый также графом целей (задач), неявно задается при формализации задачи с использованием метода редукции, путем описания исходной задачи, операторов сведения задачи к подзадачам и множества элементарных задач.",множества,ai,0
"4.2 язык программирования плэнер в языке плэнер программа и обрабатываемые ею данные записываются в виде выражений, к которым относятся: атомы (идентификаторы и числа), обращения к переменным, состоящие из префикса и имени переменной (например, .x), и списки, представляющие собой последовательности выражений заключенные в круглые, квадратные или угловые скобки (например, [elem 1(a b c)]).",язык программирования,ai,0
"если этот список пуст, то функция ничего не делает и выдает значение т.",список,ai,0
для обоих подходов описываются используемые алгоритмы поиска решения.,алгоритмы поиска решения,ai,0
"начальное же состояние определяется как список (a), а целевое как любой допустимый список, начинающийся и кончающийся элементом a. для определенных таким образом состояний операторы задачи могут соответствовать перемещениям между городами (т.е. дугам графа рис.3) получаем таким образом 13 операторов.",состояний,ai,0
"определение новых функций для этого служит встроенная функция defun, к которой возможно любое из следующих обращений: (defun f (lambda(v1 v2 ... vn) e)) (n 0) (defun f (v1 v2 ... vn) e) значением этой функциональной формы является имя определяемой функции, т.е. f. побочным же эффектом вычисления этой формы будет опре деление новой лисповской функции с именем f, аргументами (формальными параметрами) vi и телом e - формой, зависящей от vi.",определяемой функции,ai,0
"решение задачи ищется в пространстве состояний множестве всех состояний, достижимых из начального состояния при помощи заданных операторов.",состояний,ai,0
"2.5.3 игра в восемь (лисп) граф-пространство состояний для головоломки-игры в восемь достаточно велик (в игре в пятнадцать фишек он на порядок больше), поэтому хотя в принципе применимы алгоритмы слепого поиска, предпочтителен все же эвристический поиск.",порядок,ai,0
"причем и при поиске в пространствах-деревьях, и при поиске в пространствах-графах, построенная алгоритмом структура из вершин и указателей всегда образует дерево (дерево перебора), поскольку указатели от дочерних вершин ссылаются только на одну порождающую вершину.",алгоритмом структура,ai,0
"2.3.1 алгоритм эвристического поиска последовательность шагов формулируемого ниже базового алгоритма эвристического (упорядоченного) перебора похожа на последовательность шагов алгоритмов слепого перебора, отличие заключается в использовании эвристической оценочной функции.",шагов алгоритмов,ai,0
"очевидно, желательны представления с малыми пространствами состояний, но нахождение удачных представлений, сужающих пространство поиска, требует обычно некоторого дополнительного анализа решаемой задачи.",удачных представлений,ai,0
"применяемая оценочная функция такова, что при прочих равных преимущество имеет менее глубокая вершина.",преимущество,ai,0
"заметим, что от выбора формы описания состояния зависит в общем случае сложность задания операторов задачи, которые должны быть также определены при формализации задачи в пространстве состояний.",состояния,ai,0
"функция ab evalp (как и mm evalp) использует вспомогательные функции, определение которых зависит от конкретной игры: opening, вычисляющую для заданной позиции игры список дочерних вершин-позиций, и stat est статическую оценочную функцию.",функцию,ai,0
"один из способов, предложенных и опробованных впервые в одной из наиболее известных систем искусственного интеллекта gps [слейгл, глава 8], заключается в выявлении различий для начального и целевого состояний задачи.",известных систем искусственного интеллекта,ai,0
"операторы будут обозначаться соответственно именами-атомами right, left, up, down; а пустышка (пустая клетка) как # .",именами-атомами,ai,0
"[define mm evalp (lambda (position depth deptype) [prog (d %дочерняя позиция; (movelist ()) %список ходов-позиций); pvalue dvalue) %оценки текущей и дочерней позиций; % 1: установка развилки, включающей все дочерние вершины текущей позиции (список () добавлен в развилку, чтобы ""поймать"" момент ее закрытия); [set d [among (<opening .position> ())]] % 2: если развилка закрыта - возврат функцией подсчитанной оценки; [cond ([empty .d] [return [cond ([eq .depth 0] .movelist) (t .pvalue) ]] )] % 3: вычисление оценки очередной дочерней позиции: либо применение статической функции, либо рекурсивный спуск; [cond ([eq .depth [- .n 1]] [set dvalue [stat est .d]]) (t [set dvalue [mm evalp .d [+ 1 .depth] [not .deptype]]] )] % 4: пересчет оценки текущей позиции по минимаксному принципу; [cond ([hasval pvalue] [pset pvalue [cond (.deptype [max .pvalue .dvalue]) (t [min .pvalue .dvalue]) ]]) (t [pset pvalue .dvalue]) ] % 5: при необходимости пересчет для исходной позиции списка ходов(дочерних позиций) с их оценками; [cond ([eq .depth 0] [pset movelist (!.movelist",возврат функцией подсчитанной оценки,ai,0
"в области искусственного интеллекта и теории поиска под эвристической информацией понимается все то, что относится к конкретной решаемой задаче и служит более эффективному ее решению.",поиска,ai,0
"поэтому значение оценочной функции для вновь построенной дочерней вершины, входящей в список open или closed, может понизиться, и надо скорректировать старую оценку вершины, заменив ее на новую, меньшую.",список,ai,0
"исходя из оценки первой дочерней вершины начальная вершина w0+, соответст вующая исходной позиции игры, к этому моменту уже предварительно оценена величиной 3.",вершины начальная,ai,0
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",аргумент-список вершин,ai,0
"в ходе рекурсивного процесса сортировки применяется вспомогательная функция do parts, которая разбивает свой аргумент-список вершин на два списка вершин (соответственно с меньшими и большими оценками) и использует для этого разбиения эвристическую оценочную функцию est, воплощающую эвристическую информацию о решаемой задаче.",списка,ai,0
"мощным приемом сужения пространств состояний является применение так называемых схем состояний и схем операторов, в которых для описаний состояний и операторов используются переменные.",мощным приемом,ai,0
"рассмотренный пример показывает, сколь важен для успешного и эффективного решения задачи выбор определенного представления.",эффективного решения задачи,ai,0
"предполагается также, что используемая алгоритмом операция раскрытия вершин организована таким образом, что она не порождает никакое состояние, идентичное состоянию в уже построенной вершине, являющейся родительской для раскрываемой вершины.",операция раскрытия вершин,ai,0
"в случае положительного исхода проверки значением функции является само проверяемое состояние, в ином случае значение равно().",случае значение,ai,0
"заметим, что функция s(v) не учитывает должным образом трудность обмена местами двух соседних фишек, а поэтому ее эвристическая сила в принципе может быть повышена.",обмена местами,ai,0
"суть бектрекинга состоит в том, чтобы в каждой точке процесса решения задачи, где существует несколько априори равноправных альтернативных вариантов (путей) дальнейшего продолжения, выбрать один из них и следовать ему, предварительно запомнив другие альтернативы для того, чтобы в случае неуспешности выбранного варианта-пути вернуться в точку выбора и выбрать для продолжения решения другой возможный вариант-путь.",альтернативных вариантов,ai,0
"в этом случае развилка бы ставилась при каждом обращении к рекурсивной функции поиска, и в типичном случае каждое рекурсивное обращение соответствовало бы шагу вниз по дереву перебора.",типичном случае,ai,0
"[fin v1 v2] значением обоих аргументов должны быть имена переменных (обозначим их v1 и v2), существующих в данный момент, причем переменная v2 должна иметь значение и им должен быть список.",список,ai,0
"то значение функции равно t ( истина ), а иначе равно () ( ложь ).",истина,ai,0
"первая функция, select max выбирает из своего единственного аргумента-списка, состоящего из позиций и их оценок, позицию с наибольшей оценкой: [define select max (lambda (list) [prog (elem max elem) [fin max elem list] sm [cond ([fin elem list] [return [2 .max elem]]) ([gt [1 .elem] [1 .max elem]] [set max elem .elem])] [go sm]] )] функция mm evalp с тремя аргументами является главной рекурсивной функцией, оценивающей вершины дерева игры по минимаксному принципу.",аргумента-списка,ai,0
"для формализации и изучения игровых стратегий в классе игр с полной информацией может быть использован подход, основанный на редукции задач.",информацией,ai,0
значение данной формы становится значением функции f при аргументах ai .,данной формы,ai,0
"отметим, что за исключением последних форм в каждой ветви (они используются для вычисления значения условного выражения), в качестве форм ei,j имеет смысл использовать только такие, которые имеют при вычислении побочный эффект, например, присваивание переменной значения и т.п. другие специальные функции (quote e) или 'e это функция блокировки вычислений: она выдает в качестве значения свой аргумент, не вычисляя его.",последних форм,ai,0
"так же как в пространстве состояний, применяются: поиск вширь (вершины раскрываются в том порядке, в котором строились); поиск вглубь (в первую очередь раскрываются те вершины, которые были построены последними, глубина поиска обычно ограничивается); подъем на холм и эвристический поиск (выбор вершины для раскрытия производится на основе эвристических оценок вершин).",раскрытия,ai,0
"итак, для представления задачи в пространстве состояний необходимо определить следующее: форму описания состояний задачи и описание начального состояния; множество операторов и их воздействий на описания состояний; множество целевых состояний или же описание их свойств.",описания,ai,0
[define is goal(state) [prog (x y z) [is ( x y z 1) [1 .state]] ]] [define opening (state) [prog(x y z (dlist ()) % список дочерних вершин; pc % точка текущего положения обезьяны; p1 p2 % две другие точки-константы пола;,точка текущего положения обезьяны,ai,0
"поэтому в случае программирования этой задачи на языке лисп можно упростить соответствующие лисп-функции слепого поиска, например, breadth first search, обойдясь без указателей и идентификаторов вершин, а также без функций solution, connect и retain new.",случае,ai,0
"этот способ предлагает опреде ленную организацию перебора всех возможных вариантов решения задачи, число которых может быть велико.",перебора,ai,0
"причем и при поиске в пространствах-деревьях, и при поиске в пространствах-графах, построенная алгоритмом структура из вершин и указателей всегда образует дерево (дерево перебора), поскольку указатели от дочерних вершин ссылаются только на одну порождающую вершину.",дерево,ai,0
"в последнем случае, однако, дерево перебора может содержать дубликаты состояний и возможно зацикливание алгоритма.",дубликаты состояний,ai,0
"стоимость пути от начальной вершины до вершины v в дереве перебора, а h(v) эвристическая оценка оптимального пути из вершины v в целевую вершину, является допустимым, если h(v) h (v) для всех вершин v пространства состояний.",дереве,ai,0
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",зрения достижения цели,ai,0
"определение новых функций для этого служит встроенная функция defun, к которой возможно любое из следующих обращений: (defun f (lambda(v1 v2 ... vn) e)) (n 0) (defun f (v1 v2 ... vn) e) значением этой функциональной формы является имя определяемой функции, т.е. f. побочным же эффектом вычисления этой формы будет опре деление новой лисповской функции с именем f, аргументами (формальными параметрами) vi и телом e - формой, зависящей от vi.",аргументами,ai,0
"сформулируем сначала правила вычисления оценок вершин дерева игры, в том числе предварительных оценок промежуточных вершин, которые для удобства будем называть альфа- и бета-величинами: концевая вершина игрового дерева оценивается статической оценочной функцией сразу, как только она построена; промежуточная вершина предварительно оценивается по минимакс ному принципу, как только стала известна оценка хотя бы одной из ее дочерних вершин; каждая предварительная оценка пересчитывается (уточняется) всякий раз, когда получена оценка еще одной дочерней вершины; предварительная оценка или-вершины (альфа-величина) полагается равной наибольшей из вычисленных к текущему моменту оценок ее дочерних вершин; предварительная оценка и-вершины (бета-величина) полагается равной наименьшей из вычисленных к текущему моменту оценок ее дочерних вершин.",бета-величинами,ai,0
"однако считается, что оценки, полученные с помощью минимаксной процедуры, более надежные меры относительного достоин ства промежуточных вершин, чем оценки, полученные прямым применением статической оценочной функции.",ства промежуточных,ai,0
"(defun is goal (state) (equal (cdadr state) goalstate )) (defun est (s) (prog (len g n) (setq len (cadr s)) (setq n 0) (setq s (cdar s)) (setq g goalstate) ;одновременный просмотр списков-описаний ; заданного и целевого состояний: es (cond ((null s) (return (+ n len)) )) (cond ((neq(car s )(car g )) (setq n (add1 n)))) (pop s) (pop g) (go es) )) (defun opening (state) (prog (op st dlist k i j el) ; выделение составных элементов описания состояния: (setq st (cadr state)) (setq op (car st)) (setq st (cdr st)) (setq state st) (setq k 0) ; поиск порядкового номера к пустышки в списке: op (setq el (car st)) (setq k (add1 k)) (cond ((neq el '#) (setq st(cdr st)) (go op))) ; вычисление номера ряда и номера столбца пустышки : (setq j (/ k size)) (setq i (add1 (- j (rem j)))) (setq j (rem k size)) ; поочередно проверка возможности движения пустышки ; вправо/влево/вверх/вниз (за счет анализа оператора op ; исключаем в дереве поиска тривиальные циклы (т.е. возврат ; после применения двух операторов в исходное состояние): (cond ((and (neq op 'left) (< j size)) (add state 'right k (add1 k)) )) (cond ((and (neq op 'right) (> j 1)) (add state 'left k (sub1 k)) )) (cond ((and (neq op 'down) (> i 1)) (add state 'up k (- k size)) )) (cond ((and (neq op 'up) (< i size)) (add state 'down k (+ k size)) )) (return dlist) )) при раскрытии использована вспомогательная функция add state, добавляющая в список дочерних вершин список-описание новой вершины из двух элементов: идентификатора этой вершины (его генерирует функция gensym) и списка номеров фишек.",номера столбца,ai,0
"в заключение отметим, что статическая оценочная функция и альфа-бета процедура две непременные составляющие почти всех компьютерных игро вых программ (в том числе коммерческих).",программ,ai,0
"вспомогательные функции opening и is goal зависят от конкретной решаемой задачи, а вспомогательная функция q sort выполняет упорядочение (по неубыванию их оценок) порожденных дочерних вершин (q sort реализует алгоритм быстрой сортировки).",функции,ai,0
"если же решающего пути нет, то в случае конечного пространства состояний алгоритм завершит работу (с сообщением о неудаче поиска), в случае же бесконечного пространства алгоритм не остановится.",неудаче поиска,ai,0
самый распространенный способ использования эвристической информации введение так называемой эвристической оценочной функции.,информации введение,ai,0
"если этот список пуст, функция вырабатывает неуспех, который автоматически возвращает программу к предыдущей ее развилке.",функция,ai,0
".reslist .dst)] [cond ([is goal .dst] [return .reslist]) (t [go ds])] ])] из программных средств управления бектрекингом (в языке плэнер он называется режимом возвратов подробнее об этом см. раздел 4.2) в приведенном тексте используется только функция among, организующая точку выбора альтернатив (развилку).",выбора альтернатив,ai,0
при выбранной форме описания задач результирующие подзадачи естественно интерпретируются как задачи нахождения пути между определенными состояниями-вехами в пространстве состояний.,определенными состояниями,ai,0
"видно, что в алгоритме поиска в глубину сначала идет поиск вдоль одного пути, пока не будет достигнута установленная граничная глубина, затем рассматриваются альтернативные пути той же или меньшей глубины, которые отличаются от первого пути лишь последней (концевой) вершиной, после чего рассматриваются пути, отличающиеся последними двумя вершинами, и т.д. рис.14.",поиска,ai,0
"показано [нильсон73, раздел 5.14], что в случае, когда самые сильные ходы рассматриваются первыми, количество концевых вершин глубины n, которые будут построены и оценены альфа-бета процедурой, примерно равно числу концевых вершин, которые были бы построены и оценены на глубине n/2 обычной минимаксной процедурой.",количество концевых вершин глубины,ai,0
"однако этот случай соответствует полному отсутствию какой-нибудь эвристической информации о задаче, и оценочная функция est не имеет никакой эвристической силы, т.е. не сокращает возникающий перебор.",перебор,ai,0
рассмотренные рекурсивные процедуры могут быть легко детализированы для получения либо простого поиска вглубь (при произвольном выборе вершины на шаге 3 or-процедуры) или получения алгоритма подъема на холм (если список glist упорядочен по неубыванию эвристической оценочной функции и на шаге 3 or-процедуры выбирается вершина с наименьшей оценкой).,процедуры,ai,0
"2.3 эвристический поиск идея, лежащая в основе эвристического поиска, состоит в том, чтобы с помощью эвристической информации оценивать перспективность нераскрытых вершин пространства состояний (с точки зрения достижения цели) и выбирать для продолжения поиска наиболее перспективную вершину.",помощью эвристической,ai,0
"для повышения эффективности поиска необходимо вычислять оценки (статические и минимаксные) вершин одновременно с построением игрового дерева и не рассматривать вершины, которые хуже уже построенных вершин.",повышения эффективности,ai,0
все эти функции входят в наиболее известные версии лиспа - common lisp и mulisp [семенов].,версии лиспа,ai,0
